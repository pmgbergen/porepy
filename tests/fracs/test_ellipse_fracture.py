"""Test functionality related to ellipse_fracture module."""

import numpy as np
import pytest
import gmsh
import porepy as pp
from porepy.fracs import ellipse_fracture


@pytest.mark.parametrize(
    "ellipse_fracture_params",
    [
        (np.array([3.0, 4.0, 5.0]), 2.0, 1.0, np.pi / 6.0, np.pi / 4.0, np.pi / 8.0),
        (np.array([8.0, 7.0, 6.0]), 2.5, 0.5, np.pi / 6.0, np.pi / 4.0, np.pi / 8.0),
    ],
)
def test_ellipse_fracture_center(ellipse_fracture_params):
    # parse the parameters
    center, major_axis, minor_axis, major_axis_angle, strike_angle, dip_angle = (
        ellipse_fracture_params
    )

    center_known = ellipse_fracture_params[0]
    fracture = ellipse_fracture.EllipticFracture(
        center, major_axis, minor_axis, major_axis_angle, strike_angle, dip_angle
    )
    assert np.allclose(center_known, fracture.center)


def test_ellipse_fracture_tags():
    gmsh.initialize()
    try:
        frac1 = ellipse_fracture.EllipticFracture(
            np.array([3.0, 4.0, 5.0]), 2.0, 1.0, np.pi / 6.0, np.pi / 4.0, np.pi / 8.0
        )
        frac2 = ellipse_fracture.EllipticFracture(
            np.array([8.0, 7.0, 6.0]), 2.5, 0.5, np.pi / 6.0, np.pi / 4.0, np.pi / 8.0
        )
        tag1 = frac1.fracture_to_gmsh_3D()
        tag2 = frac2.fracture_to_gmsh_3D()
        assert tag1 != tag2
    finally:
        gmsh.finalize()


@pytest.mark.parametrize(
    "ellipse_fracture_params",
    [
        (np.array([3.0, 4.0, 5.0]), 2.0, 1.0, np.pi / 6.0, np.pi / 4.0, np.pi / 8.0),
        (np.array([8.0, 7.0, 6.0]), 2.5, 0.5, np.pi / 6.0, np.pi / 4.0, np.pi / 8.0),
    ],
)
def test_gmsh_ellipse_nodes(ellipse_fracture_params):
    center, major_axis, minor_axis, major_axis_angle, strike_angle, dip_angle = (
        ellipse_fracture_params
    )
    """
    This test is used for checking whether the boundary nodes lies in the plane of the ellipse.
    Boundary nodes are generated by Gmsh. 
    """
    gmsh.initialize()
    try:
        fracture = ellipse_fracture.EllipticFracture(
            center, major_axis, minor_axis, major_axis_angle, strike_angle, dip_angle
        )
        tag = fracture.fracture_to_gmsh_3D()

        gmsh.model.occ.synchronize()

        boundary_curves = gmsh.model.getBoundary(
            [(2, tag)], oriented=False, recursive=False
        )

        gmsh.model.mesh.generate(2)

        node_tags_all = []
        for dim, ctag in boundary_curves:
            node_tags, _, _ = gmsh.model.mesh.getNodes(1, ctag, includeBoundary=True)
            if len(node_tags):
                node_tags_all.append(np.array(node_tags, dtype=np.int64))

        boundary_node_tags = np.unique(np.concatenate(node_tags_all))

        pts = []
        for t in boundary_node_tags:
            coord, _, _, _ = gmsh.model.mesh.getNode(int(t))
            pts.append(coord)

        boundary_points = np.array(pts).reshape(-1, 3)

        dis_error = plane_check(boundary_points, center, strike_angle, dip_angle)

        assert np.abs(dis_error).max() <= 1e-3
    finally:
        gmsh.finalize()


def plane_check(points_xyz, center, strike_angle, dip_angle):
    """
    Check whether the given points are located in the plane defined by strike and dip.
    """
    P = np.asarray(points_xyz)
    c = np.asarray(center).ravel()
    phi = float(strike_angle)
    theta = float(dip_angle)

    n = np.array(
        [np.sin(theta) * np.sin(phi), -np.sin(theta) * np.cos(phi), np.cos(theta)],
    )
    n /= np.linalg.norm(n)

    dis_error = (P - c) @ n
    return dis_error


@pytest.mark.parametrize(
    "ellipse_fracture_params",
    [
        (np.array([3.0, 4.0, 5.0]), 2.0, 1.0, np.pi / 6.0, np.pi / 4.0, np.pi / 8.0),
        (np.array([8.0, 7.0, 6.0]), 2.5, 0.5, np.pi / 6.0, np.pi / 4.0, np.pi / 8.0),
    ],
)
def test_fracture_geometry(ellipse_fracture_params):
    center, major_axis, minor_axis, major_axis_angle, strike_angle, dip_angle = (
        ellipse_fracture_params
    )
    fracture = ellipse_fracture.EllipticFracture(
        center, major_axis, minor_axis, major_axis_angle, strike_angle, dip_angle
    )
    domain = _standard_domain()
    mdg = _create_mdg([fracture], domain)
    frac_nodes = mdg.subdomains(dim=2)[0].nodes
    dis = plane_check(frac_nodes.T, center, strike_angle, dip_angle)
    assert np.abs(dis).max() <= 1e-6


def _standard_domain(modify: bool = False) -> dict | pp.Domain:
    """Create a standard domain for testing purposes."""
    bbox = {"xmin": -2, "xmax": 2, "ymin": -2, "ymax": 2, "zmin": -2, "zmax": 2}
    if modify:
        return bbox
    else:
        domain = pp.Domain(bbox)
        return domain


def _create_mdg(
    fractures, domain=None, mesh_args: dict | None = None, constraints=None
) -> pp.MixedDimensionalGrid:
    """Create a mixed-dimensional grid from a list of fractures."""
    if mesh_args is None:
        mesh_args = {"mesh_size_bound": 1, "mesh_size_frac": 1, "mesh_size_min": 0.1}
    network = pp.create_fracture_network(fractures, domain=domain)
    if constraints is None:
        mdg = network.mesh(mesh_args)
    else:
        mdg = network.mesh(mesh_args, constraints=constraints)
    return mdg
