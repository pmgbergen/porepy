<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>porepy.utils.adtree &mdash; PorePy 1.5 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="canonical" href="https://pmgbergen.github.io/porepy/_modules/porepy/utils/adtree.html" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >
            <a href="../../../index.html" class="icon icon-home"> PorePy
          </a>
              <div class="version">
                docs/alpha
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docsrc/howto/howto-docstring.html">1. How-To docstring</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docsrc/porepy/porepy.html">porepy package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.html">porepy.fracs package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture.html">porepy.fracs.fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_importer.html">porepy.fracs.fracture_importer module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_network_2d.html">porepy.fracs.fracture_network_2d module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html">porepy.fracs.fracture_network_3d module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.gmsh_interface.html">porepy.fracs.gmsh_interface module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.line_fracture.html">porepy.fracs.line_fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.meshing.html">porepy.fracs.meshing module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.msh_2_grid.html">porepy.fracs.msh_2_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.non_conforming.html">porepy.fracs.non_conforming module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.plane_fracture.html">porepy.fracs.plane_fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.simplex.html">porepy.fracs.simplex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.split_grid.html">porepy.fracs.split_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.structured.html">porepy.fracs.structured module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.tools.html">porepy.fracs.tools module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.utils.html">porepy.fracs.utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.wells_3d.html">porepy.fracs.wells_3d module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.html">porepy.geometry package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.bounding_box.html">porepy.geometry.bounding_box module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.constrain_geometry.html">porepy.geometry.constrain_geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.distances.html">porepy.geometry.distances module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.geometry_property_checks.html">porepy.geometry.geometry_property_checks module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.half_space.html">porepy.geometry.half_space module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.intersections.html">porepy.geometry.intersections module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.map_geometry.html">porepy.geometry.map_geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.point_in_polyhedron_test.html">porepy.geometry.point_in_polyhedron_test module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.html">porepy.grids package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.html">porepy.grids.standard_grids package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.md_grids_2d.html">porepy.grids.standard_grids.md_grids_2d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.md_grids_3d.html">porepy.grids.standard_grids.md_grids_3d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.utils.html">porepy.grids.standard_grids.utils module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.coarsening.html">porepy.grids.coarsening module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.grid.html">porepy.grids.grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.grid_extrusion.html">porepy.grids.grid_extrusion module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.match_grids.html">porepy.grids.match_grids module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.md_grid.html">porepy.grids.md_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.mortar_grid.html">porepy.grids.mortar_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.partition.html">porepy.grids.partition module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.point_grid.html">porepy.grids.point_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.refinement.html">porepy.grids.refinement module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.simplex.html">porepy.grids.simplex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.structured.html">porepy.grids.structured module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.html">porepy.models package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.abstract_model.html">porepy.models.abstract_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.contact_mechanics_biot_model.html">porepy.models.contact_mechanics_biot_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.contact_mechanics_model.html">porepy.models.contact_mechanics_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.incompressible_flow_model.html">porepy.models.incompressible_flow_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.run_models.html">porepy.models.run_models module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.slightly_compressible_flow_model.html">porepy.models.slightly_compressible_flow_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.thm_model.html">porepy.models.thm_model module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.html">porepy.numerics package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.html">porepy.numerics.ad package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.discretizations.html">porepy.numerics.ad.discretizations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.equation_manager.html">porepy.numerics.ad.equation_manager module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.forward_mode.html">porepy.numerics.ad.forward_mode module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.functions.html">porepy.numerics.ad.functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.grid_operators.html">porepy.numerics.ad.grid_operators module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.operator_functions.html">porepy.numerics.ad.operator_functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.operators.html">porepy.numerics.ad.operators module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.time_derivatives.html">porepy.numerics.ad.time_derivatives module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fem.html">porepy.numerics.fem package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fem.rt0.html">porepy.numerics.fem.rt0 module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.html">porepy.numerics.fracture_deformation package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.conforming_propagation.html">porepy.numerics.fracture_deformation.conforming_propagation module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.contact_conditions.html">porepy.numerics.fracture_deformation.contact_conditions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.propagate_fracture.html">porepy.numerics.fracture_deformation.propagate_fracture module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.propagation_model.html">porepy.numerics.fracture_deformation.propagation_model module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.html">porepy.numerics.fv package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.biot.html">porepy.numerics.fv.biot module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.fv_elliptic.html">porepy.numerics.fv.fv_elliptic module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.fvutils.html">porepy.numerics.fv.fvutils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.mass_matrix.html">porepy.numerics.fv.mass_matrix module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.mpfa.html">porepy.numerics.fv.mpfa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.mpsa.html">porepy.numerics.fv.mpsa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.source.html">porepy.numerics.fv.source module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.tpfa.html">porepy.numerics.fv.tpfa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.upwind.html">porepy.numerics.fv.upwind module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.html">porepy.numerics.interface_laws package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.abstract_interface_law.html">porepy.numerics.interface_laws.abstract_interface_law module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.cell_dof_face_dof_map.html">porepy.numerics.interface_laws.cell_dof_face_dof_map module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.contact_mechanics_interface_laws.html">porepy.numerics.interface_laws.contact_mechanics_interface_laws module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.elliptic_discretization.html">porepy.numerics.interface_laws.elliptic_discretization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.elliptic_interface_laws.html">porepy.numerics.interface_laws.elliptic_interface_laws module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.hyperbolic_interface_laws.html">porepy.numerics.interface_laws.hyperbolic_interface_laws module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linalg.html">porepy.numerics.linalg package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linalg.matrix_operations.html">porepy.numerics.linalg.matrix_operations module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.html">porepy.numerics.mixed_dim package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler.html">porepy.numerics.mixed_dim.assembler module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler_filters.html">porepy.numerics.mixed_dim.assembler_filters module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.dof_manager.html">porepy.numerics.mixed_dim.dof_manager module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.nonlinear.html">porepy.numerics.nonlinear package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.nonlinear.nonlinear_solvers.html">porepy.numerics.nonlinear.nonlinear_solvers module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.solvers.html">porepy.numerics.solvers package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.solvers.andersonacceleration.html">porepy.numerics.solvers.andersonacceleration module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.html">porepy.numerics.vem package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.dual_elliptic.html">porepy.numerics.vem.dual_elliptic module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.hybrid.html">porepy.numerics.vem.hybrid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.mass_matrix.html">porepy.numerics.vem.mass_matrix module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.mvem.html">porepy.numerics.vem.mvem module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.vem_source.html">porepy.numerics.vem.vem_source module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.discretization.html">porepy.numerics.discretization module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.displacement_correlation.html">porepy.numerics.displacement_correlation module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linear_solvers.html">porepy.numerics.linear_solvers module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.time_step_control.html">porepy.numerics.time_step_control module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.html">porepy.params package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.bc.html">porepy.params.bc module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.data.html">porepy.params.data module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.fluid.html">porepy.params.fluid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.parameter_dictionaries.html">porepy.params.parameter_dictionaries module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.rock.html">porepy.params.rock module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.tensor.html">porepy.params.tensor module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.html">porepy.utils package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.derived_discretizations.html">porepy.utils.derived_discretizations package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.derived_discretizations.implicit_euler.html">porepy.utils.derived_discretizations.implicit_euler module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.accumarray.html">porepy.utils.accumarray module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.adtree.html">porepy.utils.adtree module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.array_operations.html">porepy.utils.array_operations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.common_constants.html">porepy.utils.common_constants module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.default_domains.html">porepy.utils.default_domains module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.error.html">porepy.utils.error module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.graph.html">porepy.utils.graph module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.grid_utils.html">porepy.utils.grid_utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.interpolation_tables.html">porepy.utils.interpolation_tables module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.mcolon.html">porepy.utils.mcolon module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.permutations.html">porepy.utils.permutations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.setmembership.html">porepy.utils.setmembership module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.sort_points.html">porepy.utils.sort_points module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.tags.html">porepy.utils.tags module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.tangential_normal_projection.html">porepy.utils.tangential_normal_projection module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.html">porepy.viz package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.exporter.html">porepy.viz.exporter module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.fracture_visualization.html">porepy.viz.fracture_visualization module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.plot_grid.html">porepy.viz.plot_grid module</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PorePy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">porepy.utils.adtree</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for porepy.utils.adtree</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; Module containing the implementation of an alternating digital tree (ADT)</span>
<span class="sd">for 3D geometric searching and intersection problems.</span>

<span class="sd">See the following works: 10.1002/nme.1620310102 and 10.1201/9781420050349 section 14.</span>

<span class="sd">Let [a, b) be the interval that contains the points that we want to insert</span>
<span class="sd">in a binary tree. We then divide the interval into two equal parts: all</span>
<span class="sd">the points in the interval [a, (a+b)/2) will be inserted in the left</span>
<span class="sd">subtree, while the points in the interval [(a+b)/2, b ) will be placed</span>
<span class="sd">in the right subtree. The reasoning is then iterated to the next</span>
<span class="sd">level for each subtree.</span>

<span class="sd">                    [0, 1)</span>
<span class="sd">                    /    \</span>
<span class="sd">                   /      \</span>
<span class="sd">                  /        \</span>
<span class="sd">           [0, 0.5)         [0.5, 1)</span>
<span class="sd">           /   |              |     \</span>
<span class="sd">          /    |              |      \</span>
<span class="sd">         /     |              |       \</span>
<span class="sd">[0, 0.25)   [0.25, 0.5)   [0.5, 0.75)  [0.75, 1)</span>

<span class="sd">When inserting the following nodes</span>
<span class="sd">A = 0.1, B = 0.6, C = 0.7, D = 0.8, E = 0.2 and F = 0.1</span>
<span class="sd">in the tree, we get the following</span>

<span class="sd">                      A</span>
<span class="sd">                    /    \</span>
<span class="sd">                   /      \</span>
<span class="sd">                 E          B</span>
<span class="sd">                / \        / \</span>
<span class="sd">               /   \      /   \</span>
<span class="sd">              F   -1     C     D</span>

<span class="sd">The first element A is added as the root. The second element B check if its</span>
<span class="sd">coordinate (in this case is a single value) is smaller than 0.5. If so, it goes</span>
<span class="sd">on the left part of the tree starting from the root otherwise on the right part.</span>
<span class="sd">Now, since B = 0.6 it goes on the right part. Now are with the node C,</span>
<span class="sd">we need to check as before if its coordinate is smaller than 0.5 (so it goes on the left)</span>
<span class="sd">or bigger than 0.5 (so it goes on the right). Since it is 0.7 it goes on the right and being</span>
<span class="sd">already taken by B we need to go one level down. We check now if its coordinate is</span>
<span class="sd">smaller (left) or bigger (right) than 0.75. Since it&#39;s smaller we proceed on the left</span>
<span class="sd">part and being empty we add it. The insertion is not related to the parent but to</span>
<span class="sd">which level and coordinate a node has. For the multi-dimension case we alternate</span>
<span class="sd">the dimension by each level, so first we check the abscissa</span>
<span class="sd">(again with left and right decided as before) and then the</span>
<span class="sd">ordinate and so on. We detail a bit more here in the sequel.</span>

<span class="sd">In the multi-dimensional case, the ADT is organized in the same way, but</span>
<span class="sd">the subdivision takes place alternately for the various coordinates:</span>
<span class="sd">if the structure must contain n-dimensional points, at the i-th level</span>
<span class="sd">of the tree the subdivision is carried out with respect to the j-th</span>
<span class="sd">coordinate, where j is the remainder of the i / n division.</span>
<span class="sd">We immediately observe that the n-dimensional &quot;points&quot;, the structure</span>
<span class="sd">contains true points in 2 or 3 dimensions, and rectangles or</span>
<span class="sd">parallelepipeds, which can be represented by &quot;points&quot; in 4 and 6</span>
<span class="sd">dimensions, with the writing (xmin, ymin, zmin, xmax, ymax, zmax).</span>
<span class="sd">Other geometrical objects are represented by their bounding box.</span>
<span class="sd">To avoid floating point problems, all the &quot;points&quot; are rescaled in [0, 1].</span>

<span class="sd">A search in the tree gives a list of all possible nodes that may</span>
<span class="sd">intersect the given one.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span> <span class="k">as</span> <span class="n">sps</span>

<span class="kn">import</span> <span class="nn">porepy</span> <span class="k">as</span> <span class="nn">pp</span>


<div class="viewcode-block" id="ADTNode"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.utils.adtree.html#porepy.utils.adtree.ADTNode">[docs]</a><span class="k">class</span> <span class="nc">ADTNode</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple bookkeeping class that contains the basic information of a tree node.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        key (Any): any key related to the node</span>
<span class="sd">        box (np.ndarray): the bounding box associated to the node</span>
<span class="sd">        child (list): list of identification of right and left children, if a children is not</span>
<span class="sd">            present is marked as -1.</span>
<span class="sd">        parent (int): identification of the parent node, marked -1 if not present (the root</span>
<span class="sd">            of a tree)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">box</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialize the node.</span>
<span class="sd">        The physical dimension associated to the node represents the dimension of the object.</span>
<span class="sd">        For a 3d element is 3, for 2d elements is 2, for 1d elements is 1, for 0d elements</span>
<span class="sd">        is 1. The latter can be seen as the degenerate case of a 1d element.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (Any): The key associated to the node</span>
<span class="sd">            box (np.ndarray): The bounding box of the node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">box</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">child</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Implementation of __str__&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Node with key: &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Child nodes: &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">child</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Parent node: &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Bounding box: &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Implementation of __repr__&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;key: &quot;</span>
            <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot; left child: &quot;</span>
            <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="o">+</span> <span class="s2">&quot; right child: &quot;</span>
            <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="o">+</span> <span class="s2">&quot; parent: &quot;</span>
            <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot; box: &quot;</span>
            <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span></div>


<div class="viewcode-block" id="ADTree"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.utils.adtree.html#porepy.utils.adtree.ADTree">[docs]</a><span class="k">class</span> <span class="nc">ADTree</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ADT structure, it is possible to fill the tree by giving a PorePy grid and then search for</span>
<span class="sd">    possible intersections. The implementation does not include some features, like removing a</span>
<span class="sd">    node, that are not used so far. Possible extensions in the future.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        tree_dim (int): search dimension of the tree, typically (e.g., when a pp.Grid is</span>
<span class="sd">            given) the double of the phys_dim</span>
<span class="sd">        phys_dim (int): physical dimension of nodes in the tree, e.g., a 2d grid will have</span>
<span class="sd">            phys_dim = 2</span>
<span class="sd">        nodes (list): the list of nodes as ADTNode</span>
<span class="sd">        region_min (float): to scale the bounding box of all the elements in [0, 1]^phys_dim</span>
<span class="sd">            we need the minimum corner point of the all region</span>
<span class="sd">        delta (float): a parameter to scale and get all the bounding box of the elements in</span>
<span class="sd">            [0, 1]^phys_dim</span>
<span class="sd">        LEFT (int): define the index of the left child, being equal to 0</span>
<span class="sd">        RIGHT (int): define the index of the right child, being equal to 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Pre-defined ordering of left and right node</span>
    <span class="n">LEFT</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">RIGHT</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">phys_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialize the tree, if the grid is given then the tree is filled.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            tree_dim (np.ndarray, optional): Set the tree dimension (typically the double of</span>
<span class="sd">                the physical dimension)</span>
<span class="sd">            tree_dim (np.ndarray, optional): Set the physical dimension</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">tree_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">phys_dim</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ADTNode</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">region_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Implementation of __str__&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Tree search dimension: &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_dim</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Physical dimension: &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Number of nodes: &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">For the geometrical scaling in [0, 1], the region minimum: &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region_min</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot; and delta &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Implementation of __repr__&quot;&quot;&quot;</span>

        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Search dimension: &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_dim</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot; physical dimension: &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot; the region minimum: &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region_min</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot; delta: &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot; number of nodes: &quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">))</span>
            <span class="o">+</span> <span class="s2">&quot; list of nodes:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;node &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idn</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">idn</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">s</span>

<div class="viewcode-block" id="ADTree.add_node"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.utils.adtree.html#porepy.utils.adtree.ADTree.add_node">[docs]</a>    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">ADTNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add a new node to the tree. We traverse the tree as previously specified and</span>
<span class="sd">        assign the new node accordingly.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            node (ADTNode): the new node to be added.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># When the tree is empty just add the node as root</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Current level for the dimension to check</span>
        <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Get the first node id, the position in the self.nodes list</span>
        <span class="n">next_node_id</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">box</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">box</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">next_node_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">current_node_id</span> <span class="o">=</span> <span class="n">next_node_id</span>
            <span class="c1"># Get the current search dimension</span>
            <span class="n">search_dim</span> <span class="o">=</span> <span class="n">level</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_dim</span>
            <span class="c1"># We take advantage of the fact that we are only descending</span>
            <span class="c1"># the tree. We then recursively multiply by 2 the coordinate.</span>
            <span class="n">box</span><span class="p">[</span><span class="n">search_dim</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">2.0</span>
            <span class="c1"># Check if the new node go on the right or on the left</span>
            <span class="k">if</span> <span class="n">box</span><span class="p">[</span><span class="n">search_dim</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LEFT</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RIGHT</span>
                <span class="n">box</span><span class="p">[</span><span class="n">search_dim</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">1.0</span>
            <span class="c1"># Take the new node</span>
            <span class="n">next_node_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">current_node_id</span><span class="p">]</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span>
            <span class="n">level</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># The correct position has been found, add informations to its parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">current_node_id</span><span class="p">]</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>

        <span class="c1"># Add the new node to the list</span>
        <span class="n">node</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">current_node_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span></div>

<div class="viewcode-block" id="ADTree.search"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.utils.adtree.html#porepy.utils.adtree.ADTree.search">[docs]</a>    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">ADTNode</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0e-6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Search all possible nodes in the tree that might intersect with the input node.</span>
<span class="sd">        The node is not added to the tree.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            node (ADTNode): Input node</span>
<span class="sd">            tol (float, optional): Geometrical tolerance to avoid floating point problems</span>

<span class="sd">        Returns:</span>
<span class="sd">            nodes (np.ndarray): Sorted, by id, list of nodes id that might intersect the node</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Enlarge the region to avoid floating point problems</span>
        <span class="n">box</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">box</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">box</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">(</span><span class="n">box</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span><span class="p">])</span> <span class="o">-</span> <span class="n">tol</span>
        <span class="n">box</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span> <span class="p">:])</span> <span class="o">+</span> <span class="n">tol</span>

        <span class="c1"># Origin of the sub-tree</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">node_id</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># List of possible intersections</span>
        <span class="n">found</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># List of right parts of the tree that need to be checked.</span>
        <span class="c1"># Each element contains the node_id (position in self.nodes)</span>
        <span class="c1"># the (shifted) origin at the current level and the current</span>
        <span class="c1"># level</span>
        <span class="n">stack</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># To traverse a non-empty binary tree in preorder,</span>
        <span class="c1"># perform the following operations recursively at each node,</span>
        <span class="c1"># starting with the root node:</span>
        <span class="c1"># &gt; visit the root;</span>
        <span class="c1"># &gt; traverse the left subtree;</span>
        <span class="c1"># &gt; traverse the right subtree.</span>
        <span class="k">while</span> <span class="n">node_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># check the left part</span>
            <span class="n">next_node_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># Intersect with the search box, add in case</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_box_intersect</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span><span class="o">.</span><span class="n">box</span><span class="p">):</span>
                    <span class="n">found</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>
                <span class="c1"># Go to the left part of the sub-tree, and check if</span>
                <span class="c1"># it intersects the box. The right part is considered later.</span>
                <span class="n">next_node_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">LEFT</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">next_node_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">search_dim</span> <span class="o">=</span> <span class="n">level</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_dim</span>
                    <span class="k">if</span> <span class="n">search_dim</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">origin</span><span class="p">[</span><span class="n">search_dim</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">box</span><span class="p">[</span><span class="n">search_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span><span class="p">]:</span>
                            <span class="n">next_node_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_dim</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">origin</span><span class="p">[</span><span class="n">search_dim</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="n">box</span><span class="p">[</span><span class="n">search_dim</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span><span class="p">]:</span>
                            <span class="n">next_node_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="c1"># Left sub-tree is neither null nor external, push info onto the stack</span>
                <span class="k">if</span> <span class="n">next_node_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node_id</span><span class="p">,</span> <span class="n">origin</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">level</span><span class="p">))</span>
                    <span class="n">node_id</span> <span class="o">=</span> <span class="n">next_node_id</span>
                    <span class="n">level</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="c1"># Check the right part that are stored in the stack</span>
            <span class="n">level</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">node_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">]</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">node_id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">found</span><span class="p">)</span>
                    <span class="n">info</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">node_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">]</span>
                    <span class="n">origin</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">level</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># Check if the subtree intersects the box. Otherwise set right_link = -1,</span>
                <span class="c1"># pop new node from the stack and adjourn level.</span>
                <span class="c1">#</span>
                <span class="c1"># lev-1 is the level of the parent node, which directs the search.</span>
                <span class="n">search_dim</span> <span class="o">=</span> <span class="p">(</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_dim</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span><span class="p">(</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_dim</span><span class="p">)</span>
                <span class="c1"># reset origin (we have just traversed the tree to the right)</span>
                <span class="n">origin</span><span class="p">[</span><span class="n">search_dim</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span>
                <span class="k">if</span> <span class="n">search_dim</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">origin</span><span class="p">[</span><span class="n">search_dim</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">box</span><span class="p">[</span><span class="n">search_dim</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span><span class="p">]:</span>
                        <span class="n">node_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">origin</span><span class="p">[</span><span class="n">search_dim</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="n">box</span><span class="p">[</span><span class="n">search_dim</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span><span class="p">]:</span>
                        <span class="n">node_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

                <span class="k">if</span> <span class="n">node_id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="c1"># nothing is found, return an empty array</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="ADTree.from_grid"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.utils.adtree.html#porepy.utils.adtree.ADTree.from_grid">[docs]</a>    <span class="k">def</span> <span class="nf">from_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">only_cells</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Function that constructs the tree from a grid by adding one cell at a time.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            g (pp.Grid): The grid to be used to construct the tree</span>
<span class="sd">            only_cells (np.ndarray, optional): Consider only a portion of the cells</span>
<span class="sd">                due to some a-priori estimates of the searching elements.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">g</span>
        <span class="c1"># Get the geometrical information cell-to-nodes</span>
        <span class="n">g_cell_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">cell_nodes</span><span class="p">()</span>
        <span class="n">g_nodes</span><span class="p">,</span> <span class="n">g_cells</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">g_cell_nodes</span><span class="p">)</span>

        <span class="c1"># select which cells to add to the tree</span>
        <span class="k">if</span> <span class="n">only_cells</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">which_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">only_cells</span><span class="p">)</span>

            <span class="c1"># to compute the min and max of the region, and get a more balanced tree,</span>
            <span class="c1"># we need to consider only the cells involved</span>
            <span class="n">which_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">which_cells</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">g_cell_nodes</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">g_cell_nodes</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">which_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">which_nodes</span><span class="p">,</span> <span class="n">g_nodes</span><span class="p">[</span><span class="n">loc</span><span class="p">])</span>
            <span class="n">which_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">which_nodes</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if only_cells is not specified consider all the cells and nodes of the mesh</span>
            <span class="n">which_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">num_cells</span><span class="p">)</span>
            <span class="n">which_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>

        <span class="c1"># data for the normalization of the points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">region_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span><span class="p">,</span> <span class="n">which_nodes</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">region_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span><span class="p">,</span> <span class="n">which_nodes</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">region_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">region_min</span><span class="p">)</span>

        <span class="c1"># loop over the considered cells of the grid</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">which_cells</span><span class="p">:</span>
            <span class="c1"># get the nodes of the current cell</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">g_cell_nodes</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">g_cell_nodes</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">c_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">nodes</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span><span class="p">,</span> <span class="n">g_nodes</span><span class="p">[</span><span class="n">loc</span><span class="p">]]</span>
            <span class="c1"># compute the scaled bounding box</span>
            <span class="n">c_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">(</span><span class="n">c_nodes</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">c_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">(</span><span class="n">c_nodes</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

            <span class="c1"># create the new node</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">ADTNode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">c_min</span><span class="p">,</span> <span class="n">c_max</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Scale the input point to be in the interval [0, 1]</span>

<span class="sd">        Parameters:</span>
<span class="sd">            x (np.ndarray): the point to be scaled</span>

<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray): the scaled point</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">region_min</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_box_intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">box2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Check if two boxes intersect.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            box1 (np.ndarray): the first box</span>
<span class="sd">            box2 (np.ndarray): the second box</span>

<span class="sd">        Returns:</span>
<span class="sd">            (bool): if the two boxes intersect</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">box1</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">box2</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span> <span class="p">:])</span>
            <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">box1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="n">box2</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">phys_dim</span><span class="p">])</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_delta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Compute portion of the [0, 1]^self.dim at the current level</span>

<span class="sd">        Parameters:</span>
<span class="sd">            level (int): current level</span>

<span class="sd">        Returns:</span>
<span class="sd">            (float): current portion of the interval according to the level</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">level</span> <span class="o">/</span> <span class="n">dim</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022 UiB Center for Modeling of Coupled Subsurface Dynamics, GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007..</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>