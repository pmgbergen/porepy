<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>porepy.fracs.fracture_network_3d &mdash; PorePy 1.6.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="canonical" href="https://pmgbergen.github.io/porepy/_modules/porepy/fracs/fracture_network_3d.html" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >
            <a href="../../../index.html" class="icon icon-home"> PorePy
          </a>
              <div class="version">
                1.6.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docsrc/porepy/porepy.html">porepy package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.html">porepy.fracs package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture.html">porepy.fracs.fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_importer.html">porepy.fracs.fracture_importer module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_network_2d.html">porepy.fracs.fracture_network_2d module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html">porepy.fracs.fracture_network_3d module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.gmsh_interface.html">porepy.fracs.gmsh_interface module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.line_fracture.html">porepy.fracs.line_fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.meshing.html">porepy.fracs.meshing module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.msh_2_grid.html">porepy.fracs.msh_2_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.non_conforming.html">porepy.fracs.non_conforming module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.plane_fracture.html">porepy.fracs.plane_fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.simplex.html">porepy.fracs.simplex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.split_grid.html">porepy.fracs.split_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.structured.html">porepy.fracs.structured module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.tools.html">porepy.fracs.tools module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.utils.html">porepy.fracs.utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.wells_3d.html">porepy.fracs.wells_3d module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.html">porepy.geometry package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.bounding_box.html">porepy.geometry.bounding_box module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.constrain_geometry.html">porepy.geometry.constrain_geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.distances.html">porepy.geometry.distances module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.geometry_property_checks.html">porepy.geometry.geometry_property_checks module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.half_space.html">porepy.geometry.half_space module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.intersections.html">porepy.geometry.intersections module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.map_geometry.html">porepy.geometry.map_geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.point_in_polyhedron_test.html">porepy.geometry.point_in_polyhedron_test module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.html">porepy.grids package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.html">porepy.grids.standard_grids package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.md_grids_2d.html">porepy.grids.standard_grids.md_grids_2d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.md_grids_3d.html">porepy.grids.standard_grids.md_grids_3d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.utils.html">porepy.grids.standard_grids.utils module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.boundary_grid.html">porepy.grids.boundary_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.coarsening.html">porepy.grids.coarsening module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.grid.html">porepy.grids.grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.grid_extrusion.html">porepy.grids.grid_extrusion module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.match_grids.html">porepy.grids.match_grids module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.md_grid.html">porepy.grids.md_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.mortar_grid.html">porepy.grids.mortar_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.partition.html">porepy.grids.partition module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.point_grid.html">porepy.grids.point_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.refinement.html">porepy.grids.refinement module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.simplex.html">porepy.grids.simplex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.structured.html">porepy.grids.structured module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.html">porepy.models package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.html">porepy.models.verification_setups package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.manu_flow_comp_frac.html">porepy.models.verification_setups.manu_flow_comp_frac module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.manu_flow_incomp_frac.html">porepy.models.verification_setups.manu_flow_incomp_frac module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.manu_poromech_nofrac.html">porepy.models.verification_setups.manu_poromech_nofrac module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.verifications_utils.html">porepy.models.verification_setups.verifications_utils module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.abstract_equations.html">porepy.models.abstract_equations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.abstract_model.html">porepy.models.abstract_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.constitutive_laws.html">porepy.models.constitutive_laws module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.contact_mechanics_biot_model.html">porepy.models.contact_mechanics_biot_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.contact_mechanics_model.html">porepy.models.contact_mechanics_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.energy_balance.html">porepy.models.energy_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.fluid_mass_balance.html">porepy.models.fluid_mass_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.geometry.html">porepy.models.geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.incompressible_flow_model.html">porepy.models.incompressible_flow_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.mass_and_energy_balance.html">porepy.models.mass_and_energy_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.material_constants.html">porepy.models.material_constants module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.momentum_balance.html">porepy.models.momentum_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.poromechanics.html">porepy.models.poromechanics module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.run_models.html">porepy.models.run_models module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.slightly_compressible_flow_model.html">porepy.models.slightly_compressible_flow_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.solution_strategy.html">porepy.models.solution_strategy module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.thermoporomechanics.html">porepy.models.thermoporomechanics module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.thm_model.html">porepy.models.thm_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.units.html">porepy.models.units module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.html">porepy.numerics package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.html">porepy.numerics.ad package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.discretizations.html">porepy.numerics.ad.discretizations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.equation_manager.html">porepy.numerics.ad.equation_manager module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.equation_system.html">porepy.numerics.ad.equation_system module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.forward_mode.html">porepy.numerics.ad.forward_mode module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.functions.html">porepy.numerics.ad.functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.grid_operators.html">porepy.numerics.ad.grid_operators module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.operator_functions.html">porepy.numerics.ad.operator_functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.operators.html">porepy.numerics.ad.operators module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.time_derivatives.html">porepy.numerics.ad.time_derivatives module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fem.html">porepy.numerics.fem package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fem.rt0.html">porepy.numerics.fem.rt0 module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.html">porepy.numerics.fracture_deformation package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.conforming_propagation.html">porepy.numerics.fracture_deformation.conforming_propagation module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.contact_conditions.html">porepy.numerics.fracture_deformation.contact_conditions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.propagate_fracture.html">porepy.numerics.fracture_deformation.propagate_fracture module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.propagation_model.html">porepy.numerics.fracture_deformation.propagation_model module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.html">porepy.numerics.fv package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.biot.html">porepy.numerics.fv.biot module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.fv_elliptic.html">porepy.numerics.fv.fv_elliptic module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.fvutils.html">porepy.numerics.fv.fvutils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.mass_matrix.html">porepy.numerics.fv.mass_matrix module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.mpfa.html">porepy.numerics.fv.mpfa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.mpsa.html">porepy.numerics.fv.mpsa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.source.html">porepy.numerics.fv.source module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.tpfa.html">porepy.numerics.fv.tpfa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.upwind.html">porepy.numerics.fv.upwind module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.html">porepy.numerics.interface_laws package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.abstract_interface_law.html">porepy.numerics.interface_laws.abstract_interface_law module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.cell_dof_face_dof_map.html">porepy.numerics.interface_laws.cell_dof_face_dof_map module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.contact_mechanics_interface_laws.html">porepy.numerics.interface_laws.contact_mechanics_interface_laws module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.elliptic_discretization.html">porepy.numerics.interface_laws.elliptic_discretization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.elliptic_interface_laws.html">porepy.numerics.interface_laws.elliptic_interface_laws module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.hyperbolic_interface_laws.html">porepy.numerics.interface_laws.hyperbolic_interface_laws module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linalg.html">porepy.numerics.linalg package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linalg.matrix_operations.html">porepy.numerics.linalg.matrix_operations module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.html">porepy.numerics.mixed_dim package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler.html">porepy.numerics.mixed_dim.assembler module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler_filters.html">porepy.numerics.mixed_dim.assembler_filters module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.dof_manager.html">porepy.numerics.mixed_dim.dof_manager module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.nonlinear.html">porepy.numerics.nonlinear package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.nonlinear.nonlinear_solvers.html">porepy.numerics.nonlinear.nonlinear_solvers module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.solvers.html">porepy.numerics.solvers package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.solvers.andersonacceleration.html">porepy.numerics.solvers.andersonacceleration module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.html">porepy.numerics.vem package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.dual_elliptic.html">porepy.numerics.vem.dual_elliptic module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.hybrid.html">porepy.numerics.vem.hybrid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.mass_matrix.html">porepy.numerics.vem.mass_matrix module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.mvem.html">porepy.numerics.vem.mvem module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.vem_source.html">porepy.numerics.vem.vem_source module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.discretization.html">porepy.numerics.discretization module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.displacement_correlation.html">porepy.numerics.displacement_correlation module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linear_solvers.html">porepy.numerics.linear_solvers module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.time_step_control.html">porepy.numerics.time_step_control module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.html">porepy.params package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.bc.html">porepy.params.bc module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.data.html">porepy.params.data module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.fluid.html">porepy.params.fluid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.parameter_dictionaries.html">porepy.params.parameter_dictionaries module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.rock.html">porepy.params.rock module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.tensor.html">porepy.params.tensor module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.html">porepy.utils package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.derived_discretizations.html">porepy.utils.derived_discretizations package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.derived_discretizations.implicit_euler.html">porepy.utils.derived_discretizations.implicit_euler module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.accumarray.html">porepy.utils.accumarray module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.adtree.html">porepy.utils.adtree module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.array_operations.html">porepy.utils.array_operations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.common_constants.html">porepy.utils.common_constants module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.default_domains.html">porepy.utils.default_domains module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.error.html">porepy.utils.error module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.graph.html">porepy.utils.graph module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.grid_utils.html">porepy.utils.grid_utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.interpolation_tables.html">porepy.utils.interpolation_tables module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.mcolon.html">porepy.utils.mcolon module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.permutations.html">porepy.utils.permutations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.porepy_types.html">porepy.utils.porepy_types module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.setmembership.html">porepy.utils.setmembership module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.sort_points.html">porepy.utils.sort_points module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.tags.html">porepy.utils.tags module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.tangential_normal_projection.html">porepy.utils.tangential_normal_projection module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.html">porepy.viz package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.data_saving_model_mixin.html">porepy.viz.data_saving_model_mixin module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.exporter.html">porepy.viz.exporter module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.fracture_visualization.html">porepy.viz.fracture_visualization module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.plot_grid.html">porepy.viz.plot_grid module</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docsrc/howto/howto-docstring.html">1. How to docstring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docsrc/howto/howto-build-docs.html">2. How to build documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PorePy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">porepy.fracs.fracture_network_3d</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for porepy.fracs.fracture_network_3d</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A module for representation and manipulations of fractures and fracture sets.</span>

<span class="sd">The model relies heavily on functions in the computational geometry library.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">meshio</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">ConvexHull</span>

<span class="kn">import</span> <span class="nn">porepy</span> <span class="k">as</span> <span class="nn">pp</span>
<span class="kn">from</span> <span class="nn">porepy.fracs.gmsh_interface</span> <span class="kn">import</span> <span class="n">GmshData3d</span><span class="p">,</span> <span class="n">GmshWriter</span>
<span class="kn">from</span> <span class="nn">porepy.fracs.plane_fracture</span> <span class="kn">import</span> <span class="n">PlaneFracture</span>
<span class="kn">from</span> <span class="nn">porepy.utils</span> <span class="kn">import</span> <span class="n">setmembership</span><span class="p">,</span> <span class="n">sort_points</span>

<span class="kn">from</span> <span class="nn">.gmsh_interface</span> <span class="kn">import</span> <span class="n">Tags</span> <span class="k">as</span> <span class="n">GmshInterfaceTags</span>

<span class="c1"># Module-wide logger</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="FractureNetwork3d"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html#porepy.fracs.fracture_network_3d.FractureNetwork3d">[docs]</a><span class="k">class</span> <span class="nc">FractureNetwork3d</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Collection of Fractures with geometrical information. Facilitates</span>
<span class="sd">    computation of intersections of the fracture. Also incorporates the</span>
<span class="sd">    bounding box of the domain. To ensure</span>
<span class="sd">    that all fractures lie within the box, call impose_external_boundary()</span>
<span class="sd">    _after_ all fractures have been specified.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        _fractures (list of Fracture): All fractures forming the network.</span>
<span class="sd">        intersections (list of Intersection): All known intersections in the</span>
<span class="sd">            network.</span>
<span class="sd">        has_checked_intersections (boolean): If True, the intersection finder</span>
<span class="sd">            method has been run. Useful in meshing algorithms to avoid</span>
<span class="sd">            recomputing known information.</span>
<span class="sd">        tol (double): Geometric tolerance used in computations.</span>
<span class="sd">        domain (dictionary): External bounding box. See</span>
<span class="sd">            impose_external_boundary() for details.</span>
<span class="sd">        tags (dictionary): Tags used on Fractures and subdomain boundaries.</span>
<span class="sd">        mesh_size_min (double): Mesh size parameter, minimum mesh size to be</span>
<span class="sd">            sent to gmsh. Set by insert_auxiliary_points().</span>
<span class="sd">        mesh_size_frac (double): Mesh size parameter. Ideal mesh size, fed to</span>
<span class="sd">            gmsh. Set by insert_auxiliary_points().</span>
<span class="sd">        mesh_size_bound (double): Mesh size parameter. Boundary mesh size, fed to</span>
<span class="sd">            gmsh. Set by insert_auxiliary_points().</span>
<span class="sd">        auxiliary_points_added (boolean): Mesh size parameter. If True,</span>
<span class="sd">            extra points have been added to Fracture geometry to facilitate</span>
<span class="sd">            mesh size tuning.</span>
<span class="sd">        decomposition (dictionary): Splitting of network, accounting for</span>
<span class="sd">            fracture intersections etc. Necessary pre-processing before</span>
<span class="sd">            meshing. Added by split_intersections().</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fractures</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">PlaneFracture</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">domain</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
        <span class="n">run_checks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialize fracture network.</span>

<span class="sd">        Generate network from specified fractures. The fractures will have</span>
<span class="sd">        their index set (and existing values overridden), according to the</span>
<span class="sd">        ordering in the input list.</span>

<span class="sd">        Initialization sets most fields (see attributes) to None.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            fractures (list of Fracture, optional): Fractures that make up the network.</span>
<span class="sd">                Defaults to None, which will create a domain empty of fractures.</span>
<span class="sd">            domain (either dictionary or list of np.arrays): Domain specification. See</span>
<span class="sd">                self.impose_external_boundary() for details.</span>
<span class="sd">            tol (double, optional): Tolerance used in geometric computations. Defaults</span>
<span class="sd">                to 1e-8.</span>
<span class="sd">            run_checks (boolean, optional): Run consistency checks during the network</span>
<span class="sd">                processing. Can be considered a limited debug mode. Defaults to False.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">fractures</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fractures</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># Store intersection information as a dictionary. Keep track of</span>
        <span class="c1"># the intersecting fractures, the start and end point of the intersection line,</span>
        <span class="c1"># and whether the intersection is on the boundary of the fractures.</span>
        <span class="c1"># Note that a Y-type intersection between three fractures is represented</span>
        <span class="c1"># as three intersections.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;first&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">),</span>
            <span class="s2">&quot;second&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">),</span>
            <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
            <span class="s2">&quot;end&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
            <span class="s2">&quot;bound_first&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
            <span class="s2">&quot;bound_second&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">has_checked_intersections</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_checks</span> <span class="o">=</span> <span class="n">run_checks</span>

        <span class="c1"># Initialize with an empty domain. Can be modified later by a call to</span>
        <span class="c1"># &#39;impose_external_boundary()&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span>

        <span class="c1"># Initialize mesh size parameters as empty</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_min</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_frac</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_bound</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Assign an empty tag dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># No auxiliary points have been added</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">auxiliary_points_added</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box_imposed</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="FractureNetwork3d.add"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html#porepy.fracs.fracture_network_3d.FractureNetwork3d.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a fracture to the network.</span>

<span class="sd">        The fracture will be assigned a new index, higher than the maximum</span>
<span class="sd">        value currently found in the network.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            f (Fracture): Fracture to be added.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span></div>

<div class="viewcode-block" id="FractureNetwork3d.copy"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html#porepy.fracs.fracture_network_3d.FractureNetwork3d.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create deep copy of the network.</span>

<span class="sd">        The method will create a deep copy of all fractures, as well as the domain, of</span>
<span class="sd">        the network. Note that if the fractures have had extra points imposed as part</span>
<span class="sd">        of a meshing procedure, these will be included in the copied fractures.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pp.FractureNetwork3d.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fracs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">]</span>

        <span class="n">domain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Get a deep copy of domain, but no need to do that if domain is None</span>
            <span class="n">domain</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">FractureNetwork3d</span><span class="p">(</span><span class="n">fracs</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span></div>

<div class="viewcode-block" id="FractureNetwork3d.num_frac"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html#porepy.fracs.fracture_network_3d.FractureNetwork3d.num_frac">[docs]</a>    <span class="k">def</span> <span class="nf">num_frac</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get number of fractures in the network, not counting planes on</span>
<span class="sd">        the domain boundary.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Number of network fractures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box_imposed</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">)</span>

        <span class="c1"># The boundary is set when the bounding box is imposed.</span>
        <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s2">&quot;boundary&quot;</span><span class="p">][</span><span class="n">fi</span><span class="p">]:</span>
                <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">num</span></div>

<div class="viewcode-block" id="FractureNetwork3d.mesh"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html#porepy.fracs.fracture_network_3d.FractureNetwork3d.mesh">[docs]</a>    <span class="k">def</span> <span class="nf">mesh</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mesh_args</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">dfn</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">file_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">constraints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">write_geo</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">tags_to_transfer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">finalize_gmsh</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">clear_gmsh</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">MixedDimensionalGrid</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Mesh the fracture network, and generate a mixed-dimensional grid.</span>

<span class="sd">        The mesh itself is generated by Gmsh.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            mesh_args (dict): Should contain fields &#39;mesh_size_frac&#39;, &#39;mesh_size_min&#39;,</span>
<span class="sd">                which represent the ideal mesh size at the fracture, and the</span>
<span class="sd">                minimum mesh size passed to gmsh. Can also contain</span>
<span class="sd">                &#39;mesh_size_bound&#39;, which gives the far-field (boundary) mesh</span>
<span class="sd">                size.</span>
<span class="sd">            dfn (boolean, optional): If True, a DFN mesh (of the network, but not</span>
<span class="sd">                the surrounding matrix) is created.</span>
<span class="sd">            file_name (str, optional): Name of file used to communicate with gmsh.</span>

<span class="sd">                defaults to gmsh_frac_file. The gmsh configuration file will be</span>
<span class="sd">                file_name.geo, while the mesh is dumped to file_name.msh.</span>
<span class="sd">            constraints (np.array): Index list of elements in the fracture list that</span>
<span class="sd">                should be treated as constraints in meshing, but not added as separate</span>
<span class="sd">                fracture grids (no splitting of nodes etc.).</span>
<span class="sd">            write_geo (bool, optional): If True (default), the gmsh configuration</span>
<span class="sd">                will be written to a .geo_unrolled file.</span>
<span class="sd">            tags_to_transfer (list of strings, optional): Tags, in self.tags to be</span>
<span class="sd">                transferred to the fracture grids. Provisional functionality.</span>
<span class="sd">            finalize_gmsh (boolean): If True (default), the port to Gmsh is closed when</span>
<span class="sd">                meshing is completed. On repeated invocations of Gmsh in the same Python</span>
<span class="sd">                session, a memory leak in Gmsh may cause reduced performance (written</span>
<span class="sd">                spring 2021). In these cases, it may be better to finalize gmsh externally</span>
<span class="sd">                to this class. See also clear_gmsh.</span>
<span class="sd">            clear_gmsh (boolean, optional): If True, the geometry representation in gmsh</span>
<span class="sd">                is deleted when meshing is completed. This is of use only if finalize_gmsh</span>
<span class="sd">                is set to False, in which case it may be desirable to delete the old</span>
<span class="sd">                geometry before adding a new one. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            MixedDimensionalGrid: Mixed-dimensional mesh.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">file_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="s2">&quot;gmsh_frac_file.msh&quot;</span>

        <span class="n">gmsh_repr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_for_gmsh</span><span class="p">(</span>
            <span class="n">mesh_args</span><span class="p">,</span>
            <span class="n">dfn</span><span class="p">,</span>
            <span class="n">constraints</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">gmsh_writer</span> <span class="o">=</span> <span class="n">GmshWriter</span><span class="p">(</span><span class="n">gmsh_repr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dfn</span><span class="p">:</span>
            <span class="n">dim_meshing</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dim_meshing</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="n">gmsh_writer</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span>
            <span class="n">file_name</span><span class="p">,</span>
            <span class="n">dim_meshing</span><span class="p">,</span>
            <span class="n">write_geo</span><span class="o">=</span><span class="n">write_geo</span><span class="p">,</span>
            <span class="n">finalize</span><span class="o">=</span><span class="n">finalize_gmsh</span><span class="p">,</span>
            <span class="n">clear_gmsh</span><span class="o">=</span><span class="n">clear_gmsh</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">dfn</span><span class="p">:</span>
            <span class="n">subdomains</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fracs</span><span class="o">.</span><span class="n">simplex</span><span class="o">.</span><span class="n">triangle_grid_embedded</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Process the gmsh .msh output file, to make a list of grids</span>
            <span class="n">subdomains</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fracs</span><span class="o">.</span><span class="n">simplex</span><span class="o">.</span><span class="n">tetrahedral_grid_from_gmsh</span><span class="p">(</span>
                <span class="n">file_name</span><span class="p">,</span> <span class="n">constraints</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">tags_to_transfer</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">id_g</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subdomains</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">dfn</span><span class="p">)]):</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">tags_to_transfer</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">tags</span><span class="p">:</span>
                        <span class="n">g</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">id_g</span><span class="p">]</span>

        <span class="c1"># Merge the grids into a mixed-dimensional MixedDimensionalGrid</span>
        <span class="n">mdg</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">meshing</span><span class="o">.</span><span class="n">subdomains_to_mdg</span><span class="p">(</span><span class="n">subdomains</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mdg</span></div>

<div class="viewcode-block" id="FractureNetwork3d.prepare_for_gmsh"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html#porepy.fracs.fracture_network_3d.FractureNetwork3d.prepare_for_gmsh">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_for_gmsh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_args</span><span class="p">,</span> <span class="n">dfn</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GmshData3d</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Process network intersections and write a gmsh .geo configuration file,</span>
<span class="sd">        ready to be processed by gmsh.</span>

<span class="sd">        NOTE: Consider using the mesh() function instead to get a ready MixedDimensionalGrid.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            mesh_args (dict): Should contain fields &#39;mesh_size_frac&#39;, &#39;mesh_size_min&#39;,</span>
<span class="sd">                which represent the ideal mesh size at the fracture, and the</span>
<span class="sd">                minimum mesh size passed to gmsh. Can also contain</span>
<span class="sd">                &#39;mesh_size_bound&#39;, which gives the far-field (boundary) mesh</span>
<span class="sd">                size.</span>
<span class="sd">            dfn (boolean, optional): If True, a DFN mesh (of the network, but not</span>
<span class="sd">                the surrounding matrix) is created.</span>
<span class="sd">            constraints (np.array): Index list of elements in the fracture list that</span>
<span class="sd">                should be treated as constraints in meshing, but not added as separate</span>
<span class="sd">                fracture grids (no splitting of nodes etc.).</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Name of .geo file.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The implementation in this function is fairly straightforward, all</span>
        <span class="c1"># technical difficulties are hidden in other functions.</span>

        <span class="c1"># Impose the boundary of the domain. This may cut and split fractures.</span>
        <span class="c1"># FIXME: When fractures are split or deleted, there will likely be</span>
        <span class="c1"># mapping errors between fracture indices.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dfn</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box_imposed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">impose_external_boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">constraints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">constraints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Find intersections between fractures</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_checked_intersections</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">find_intersections</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Use existing intersections&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;mesh_size_frac&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mesh_args</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Meshing algorithm needs argument mesh_size_frac&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;mesh_size_min&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mesh_args</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Meshing algorithm needs argument mesh_size_min&quot;</span><span class="p">)</span>

        <span class="c1"># Insert auxiliary points for mesh size control. This is done after the</span>
        <span class="c1"># intersections are found, but before the fractures are collected into a</span>
        <span class="c1"># set of edges (see split_intersections).</span>
        <span class="n">mesh_size_frac</span> <span class="o">=</span> <span class="n">mesh_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mesh_size_frac&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">mesh_size_min</span> <span class="o">=</span> <span class="n">mesh_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mesh_size_min&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">mesh_size_bound</span> <span class="o">=</span> <span class="n">mesh_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mesh_size_bound&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_insert_auxiliary_points</span><span class="p">(</span><span class="n">mesh_size_frac</span><span class="p">,</span> <span class="n">mesh_size_min</span><span class="p">,</span> <span class="n">mesh_size_bound</span><span class="p">)</span>

        <span class="c1"># Process intersections to get a description of the geometry in non-</span>
        <span class="c1"># intersecting lines and polygons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_intersections</span><span class="p">()</span>

        <span class="c1"># Having found all intersections etc., the next step is to classify the geometric</span>
        <span class="c1"># objects before representing them in the data format expected by the Gmsh interface.</span>
        <span class="c1"># The classification is somewhat complex, since, for certain applications, it is</span>
        <span class="c1"># necessary with a detailed description of different objects.</span>

        <span class="c1"># Extract geometrical information.</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;points&quot;</span><span class="p">]</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;edges&quot;</span><span class="p">]</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poly_2_segment</span><span class="p">()</span>

        <span class="n">has_boundary</span> <span class="o">=</span> <span class="s2">&quot;boundary&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span>

        <span class="c1"># Get preliminary set of tags for the edges. Also find which edges are</span>
        <span class="c1"># interior to all or only some edges</span>
        <span class="n">edge_tags</span><span class="p">,</span> <span class="n">not_boundary_edge</span><span class="p">,</span> <span class="n">some_boundary_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_classify_edges</span><span class="p">(</span>
            <span class="n">poly</span><span class="p">,</span> <span class="n">constraints</span>
        <span class="p">)</span>

        <span class="c1"># All intersection lines and points on boundaries are non-physical in 3d.</span>
        <span class="c1"># I.e., they are assigned boundary conditions, but are not gridded. Hence:</span>
        <span class="c1"># Remove the points and edges at the boundary</span>
        <span class="n">point_tags</span><span class="p">,</span> <span class="n">edge_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_domain_boundary</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">edge_tags</span><span class="p">)</span>

        <span class="c1"># To ensure that polygons that are constraints, but not fractures, do not</span>
        <span class="c1"># trigger the generation of 1d fracture intersections, or 0d point grids, some</span>
        <span class="c1"># steps are needed.</span>

        <span class="c1"># Count the number of times a lines is defined as &#39;inside&#39; a fracture, and</span>
        <span class="c1"># the number of times this is caused by a constraint</span>
        <span class="n">in_frac_occurrences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">in_frac_occurrences_by_constraints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">poly_ind</span><span class="p">,</span> <span class="n">poly_edges</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;line_in_frac&quot;</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">edge_ind</span> <span class="ow">in</span> <span class="n">poly_edges</span><span class="p">:</span>
                <span class="n">in_frac_occurrences</span><span class="p">[</span><span class="n">edge_ind</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">poly_ind</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">:</span>
                    <span class="n">in_frac_occurrences_by_constraints</span><span class="p">[</span><span class="n">edge_ind</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Count the number of occurrences that are not caused by a constraint</span>
        <span class="n">num_occ_not_by_constraints</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">in_frac_occurrences</span> <span class="o">-</span> <span class="n">in_frac_occurrences_by_constraints</span>
        <span class="p">)</span>

        <span class="c1"># If all but one occurrence of a line internal to a polygon is caused by</span>
        <span class="c1"># constraints, this is likely a fracture.</span>
        <span class="n">auxiliary_line</span> <span class="o">=</span> <span class="n">num_occ_not_by_constraints</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="c1"># .. However, the line may also be caused by a T- or L-intersection</span>
        <span class="n">auxiliary_line</span><span class="p">[</span><span class="n">some_boundary_edge</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># The edge tags for internal lines were set accordingly in self._classify_edges.</span>
        <span class="c1"># Update to auxiliary line if this was really what we had.</span>
        <span class="n">edge_tags</span><span class="p">[</span><span class="n">auxiliary_line</span><span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">AUXILIARY_LINE</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># .. and we&#39;re done with edges (until someone defines a new special case)</span>
        <span class="c1"># Next, find intersection points.</span>

        <span class="c1"># Count the number of times a point is referred to by an intersection</span>
        <span class="c1"># between two fractures. If this is more than one, the point should</span>
        <span class="c1"># have a 0-d grid assigned to it.</span>
        <span class="c1"># Here, we must account for lines that are internal, but not those that have</span>
        <span class="c1"># been found to be triggered by constraints.</span>
        <span class="n">intersection_edge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">not_boundary_edge</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">auxiliary_line</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># All intersection points should occur at least twice</span>
        <span class="n">isect_p</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="n">intersection_edge</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">num_occ_isect_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">isect_p</span><span class="p">)</span>
        <span class="c1"># All points that occur more than once could be intersection points</span>
        <span class="n">prelim_intersection_candidate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">num_occ_isect_pt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># We should also consider points that are both on a fracture tip and a domain</span>
        <span class="c1"># boundary line - these will be added to the fracture and boundary points below.</span>
        <span class="n">domain_boundary_line</span> <span class="o">=</span> <span class="n">edge_tags</span> <span class="o">==</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">DOMAIN_BOUNDARY_LINE</span><span class="o">.</span><span class="n">value</span>
        <span class="n">fracture_tip_line</span> <span class="o">=</span> <span class="n">edge_tags</span> <span class="o">==</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">FRACTURE_TIP</span><span class="o">.</span><span class="n">value</span>
        <span class="n">domain_boundary_point</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="n">domain_boundary_line</span><span class="p">]</span>
        <span class="n">fracture_tip_point</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="n">fracture_tip_line</span><span class="p">]</span>
        <span class="n">domain_and_tip_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">domain_boundary_point</span><span class="p">,</span> <span class="n">fracture_tip_point</span><span class="p">)</span>

        <span class="n">intersection_point_candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">(</span><span class="n">prelim_intersection_candidate</span><span class="p">,</span> <span class="n">domain_and_tip_point</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># .. however, this is not enough: If a fracture and a constraint intersect at</span>
        <span class="c1"># a domain boundary, the candidate is not a true intersection point.</span>
        <span class="c1"># Loop over all candidates, find all polygons that have this as part of an edge,</span>
        <span class="c1"># and count the number of those polygons that are fractures (e.g. not boundary</span>
        <span class="c1"># or constraint). If there is more than one, this is indeed  a fracture intersection</span>
        <span class="c1"># and an intersection point grid should be assigned.</span>
        <span class="c1"># (Reason for more than one, not two, I believe is: Two fractures crossing will not</span>
        <span class="c1"># make a 0d point by themselves). Point must then come either from a third fracture,</span>
        <span class="c1"># or a constraint. In the latter case, we anyhow need the intersection point as a</span>
        <span class="c1"># grid to get dynamics between the intersection line correctly represented.</span>
        <span class="n">intersection_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Points that are both on a boundary, and on a fracture. This may represent one of</span>
        <span class="c1"># a few cases: A fracture-constraint intersection on a boundary, and/or a fracture</span>
        <span class="c1"># crossing a domain surface boundary.</span>
        <span class="n">fracture_and_boundary_points</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="n">intersection_point_candidates</span><span class="p">:</span>
            <span class="c1"># edges of this point</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">edge_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">edges</span> <span class="o">==</span> <span class="n">pi</span><span class="p">)</span>

            <span class="c1"># Fractures of the edge</span>
            <span class="n">frac_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edge_ind</span><span class="p">:</span>
                <span class="n">frac_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frac_arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;edges_2_frac&quot;</span><span class="p">][</span><span class="n">e</span><span class="p">])</span>
            <span class="c1"># Uniquify.</span>
            <span class="n">unique_fracs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">frac_arr</span><span class="p">)</span>

            <span class="c1"># If the domain has a boundary, classify the polygons of this point as</span>
            <span class="c1"># fracture, fracture or boundary (and tacitly, constraints)</span>
            <span class="k">if</span> <span class="n">has_boundary</span><span class="p">:</span>
                <span class="n">is_boundary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s2">&quot;boundary&quot;</span><span class="p">])[</span><span class="n">unique_fracs</span><span class="p">]</span>
                <span class="n">is_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">unique_fracs</span><span class="p">,</span> <span class="n">constraints</span><span class="p">),</span> <span class="n">is_boundary</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">is_frac_or_boundary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">unique_fracs</span><span class="p">,</span> <span class="n">constraints</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">unique_fracs</span><span class="p">,</span> <span class="n">constraints</span><span class="p">))</span>
                <span class="n">is_frac_or_boundary</span> <span class="o">=</span> <span class="n">is_frac</span>

            <span class="c1"># If more than one fracture share this point, it is an intersection point.</span>
            <span class="c1"># See comment above on why not &gt; 2.</span>
            <span class="k">if</span> <span class="n">is_frac</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">intersection_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
            <span class="c1"># If the point is on a fracture, and on a boundary surface, it will be</span>
            <span class="c1"># classified otherwise.</span>
            <span class="k">if</span> <span class="n">is_frac</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">is_frac_or_boundary</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">is_frac</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fracture_and_boundary_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>

        <span class="c1"># Finally, we have the full set of intersection points (take a good laugh when finding</span>
        <span class="c1"># this line in the next round of debugging).</span>

        <span class="c1"># Candidates that were not intersections. Here we do not consider the boundary-tip</span>
        <span class="c1"># combinations.</span>
        <span class="n">fracture_constraint_intersection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span>
            <span class="n">prelim_intersection_candidate</span><span class="p">,</span> <span class="n">fracture_and_boundary_points</span>
        <span class="p">)</span>

        <span class="c1"># Special tag for intersection between fracture and constraint.</span>
        <span class="c1"># These are not needed in the gmsh postprocessing (will not produce 0d grids),</span>
        <span class="c1"># but it can be useful to mark them for other purposes (EK: DFM upscaling)</span>
        <span class="n">point_tags</span><span class="p">[</span>
            <span class="n">fracture_constraint_intersection</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">FRACTURE_CONSTRAINT_INTERSECTION_POINT</span><span class="o">.</span><span class="n">value</span>

        <span class="n">point_tags</span><span class="p">[</span>
            <span class="n">fracture_and_boundary_points</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">FRACTURE_BOUNDARY_POINT</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># We&#39;re done! Hurrah!</span>

        <span class="c1"># Find points tagged as on the domain boundary</span>
        <span class="n">boundary_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">point_tags</span> <span class="o">==</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">DOMAIN_BOUNDARY_POINT</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">fracture_boundary_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">point_tags</span> <span class="o">==</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">FRACTURE_BOUNDARY_POINT</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Intersections on the boundary should not have a 0d grid assigned</span>
        <span class="n">true_intersection_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span>
            <span class="n">intersection_points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">boundary_points</span><span class="p">,</span> <span class="n">fracture_boundary_points</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;edges&quot;</span><span class="p">],</span> <span class="n">edge_tags</span><span class="p">))</span>

        <span class="c1"># Obtain mesh size parameters</span>
        <span class="n">mesh_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_determine_mesh_size</span><span class="p">(</span><span class="n">point_tags</span><span class="o">=</span><span class="n">point_tags</span><span class="p">)</span>

        <span class="n">line_in_poly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;line_in_frac&quot;</span><span class="p">]</span>

        <span class="n">physical_points</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">GmshInterfaceTags</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="n">fracture_boundary_points</span><span class="p">:</span>
            <span class="n">physical_points</span><span class="p">[</span><span class="n">pi</span><span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">FRACTURE_BOUNDARY_POINT</span>

        <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="n">fracture_constraint_intersection</span><span class="p">:</span>
            <span class="n">physical_points</span><span class="p">[</span>
                <span class="n">pi</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">FRACTURE_CONSTRAINT_INTERSECTION_POINT</span>

        <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="n">boundary_points</span><span class="p">:</span>
            <span class="n">physical_points</span><span class="p">[</span><span class="n">pi</span><span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">DOMAIN_BOUNDARY_POINT</span>

        <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="n">true_intersection_points</span><span class="p">:</span>
            <span class="n">physical_points</span><span class="p">[</span><span class="n">pi</span><span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">FRACTURE_INTERSECTION_POINT</span>

        <span class="c1"># Use separate structures to store tags and physical names for the polygons.</span>
        <span class="c1"># The former is used for feeding information into gmsh, while the latter is</span>
        <span class="c1"># used to tag information in the output from gmsh. They are kept as separate</span>
        <span class="c1"># variables since a user may want to modify the physical surfaces before</span>
        <span class="c1"># generating the .msh file.</span>
        <span class="n">physical_surfaces</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">GmshInterfaceTags</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">polygon_tags</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">GmshInterfaceTags</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">fi</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">):</span>
            <span class="c1"># Translate from numerical tags to the GmshInterfaceTags system.</span>
            <span class="k">if</span> <span class="n">has_boundary</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s2">&quot;boundary&quot;</span><span class="p">][</span><span class="n">fi</span><span class="p">]:</span>
                <span class="n">physical_surfaces</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">DOMAIN_BOUNDARY_SURFACE</span>
                <span class="n">polygon_tags</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">DOMAIN_BOUNDARY_SURFACE</span>
            <span class="k">elif</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">:</span>
                <span class="n">physical_surfaces</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">AUXILIARY_PLANE</span>
                <span class="n">polygon_tags</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">AUXILIARY_PLANE</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">physical_surfaces</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">FRACTURE</span>
                <span class="n">polygon_tags</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">FRACTURE</span>

        <span class="n">physical_lines</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">GmshInterfaceTags</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="n">tag</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">tag</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">FRACTURE_TIP</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">FRACTURE_INTERSECTION_LINE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">DOMAIN_BOUNDARY_LINE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">FRACTURE_BOUNDARY_LINE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">AUXILIARY_LINE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="c1"># Translate from the numerical value of the line to the tag in the</span>
                <span class="c1"># Gmsh interface.</span>
                <span class="n">physical_lines</span><span class="p">[</span><span class="n">ei</span><span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>

        <span class="n">gmsh_repr</span> <span class="o">=</span> <span class="n">GmshData3d</span><span class="p">(</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="n">pts</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
            <span class="n">lines</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span>
            <span class="n">mesh_size</span><span class="o">=</span><span class="n">mesh_size</span><span class="p">,</span>
            <span class="n">polygons</span><span class="o">=</span><span class="n">poly</span><span class="p">,</span>
            <span class="n">physical_surfaces</span><span class="o">=</span><span class="n">physical_surfaces</span><span class="p">,</span>
            <span class="n">polygon_tags</span><span class="o">=</span><span class="n">polygon_tags</span><span class="p">,</span>
            <span class="n">lines_in_surface</span><span class="o">=</span><span class="n">line_in_poly</span><span class="p">,</span>
            <span class="n">physical_points</span><span class="o">=</span><span class="n">physical_points</span><span class="p">,</span>
            <span class="n">physical_lines</span><span class="o">=</span><span class="n">physical_lines</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;edge_tags&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;domain_boundary_points&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;point_tags&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">point_tags</span>

        <span class="k">return</span> <span class="n">gmsh_repr</span></div>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">[</span><span class="n">position</span><span class="p">]</span>

<div class="viewcode-block" id="FractureNetwork3d.intersections_of_fracture"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html#porepy.fracs.fracture_network_3d.FractureNetwork3d.intersections_of_fracture">[docs]</a>    <span class="k">def</span> <span class="nf">intersections_of_fracture</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">frac</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">PlaneFracture</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Get all known intersections for a fracture.</span>

<span class="sd">        If called before find_intersections(), the returned list will be empty.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            frac: A fracture in the network</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.array (Intersection): Array of intersections</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fi</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>  <span class="c1"># need this typing since frac.index might also be None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frac</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">fi</span> <span class="o">=</span> <span class="n">frac</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fi</span> <span class="o">=</span> <span class="n">frac</span><span class="o">.</span><span class="n">index</span>

        <span class="n">isects</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">is_first</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;first&quot;</span><span class="p">])):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;first&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">fi</span><span class="p">:</span>
                <span class="n">isects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">is_first</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;second&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">fi</span><span class="p">:</span>
                <span class="n">isects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">is_first</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="kc">False</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">isects</span><span class="p">,</span> <span class="n">is_first</span></div>

<div class="viewcode-block" id="FractureNetwork3d.find_intersections"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html#porepy.fracs.fracture_network_3d.FractureNetwork3d.find_intersections">[docs]</a>    <span class="k">def</span> <span class="nf">find_intersections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_orig_points</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find intersections between fractures in terms of coordinates.</span>

<span class="sd">        The intersections are stored in the attribute self.Intersections.</span>

<span class="sd">        Handling of the intersections (splitting into non-intersecting</span>
<span class="sd">        polygons, paving the way for gridding) is taken care of by the function</span>
<span class="sd">        split_intersections().</span>

<span class="sd">        Note that find_intersections() should be invoked after external</span>
<span class="sd">        boundaries are imposed. If the reverse order is applied, intersections</span>
<span class="sd">        outside the domain may be identified, with unknown consequences for the</span>
<span class="sd">        reliability of the methods. If intersections outside the bounding box</span>
<span class="sd">        are of interest, these can be found by setting the parameter</span>
<span class="sd">        use_orig_points to True.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            use_orig_points (boolean, optional): Whether to use the original</span>
<span class="sd">                fracture description in the search for intersections. Defaults</span>
<span class="sd">                to False. If True, all fractures will have their attribute p</span>
<span class="sd">                reset to their original value.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_checked_intersections</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Find intersection between fractures&quot;</span><span class="p">)</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># If desired, use the original points in the fracture intersection.</span>
        <span class="c1"># This will reset the field self._fractures.pts, and thus revoke</span>
        <span class="c1"># modifications due to boundaries etc.</span>
        <span class="k">if</span> <span class="n">use_orig_points</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">pts</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">orig_pts</span>

        <span class="c1"># Intersections are found using a method in the comp_geom module, which requires</span>
        <span class="c1"># the fractures to be represented as a list of polygons.</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">pts</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">]</span>

        <span class="c1"># Obtain intersection points, indexes of intersection points for each fracture</span>
        <span class="c1"># information on whether the fracture is on the boundary, and pairs of fractures</span>
        <span class="c1"># that intersect.</span>
        <span class="c1"># We do not include point contacts here - that should be feasible, but the</span>
        <span class="c1"># implementation may require some effort (e.g. point contact in the interior of</span>
        <span class="c1"># a fracture would require embedding points in surfaces in the gmsh specification).</span>
        <span class="n">isect</span><span class="p">,</span> <span class="n">point_ind</span><span class="p">,</span> <span class="n">bound_info</span><span class="p">,</span> <span class="n">frac_pairs</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">intersections</span><span class="o">.</span><span class="n">polygons_3d</span><span class="p">(</span>
            <span class="n">polys</span><span class="p">,</span> <span class="n">include_point_contact</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="c1"># Loop over all pairs of intersection pairs, add the intersections to the</span>
        <span class="c1"># internal list.</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">frac_pairs</span><span class="p">:</span>
            <span class="c1"># Indices of the relevant pairs.</span>
            <span class="n">ind_0</span><span class="p">,</span> <span class="n">ind_1</span> <span class="o">=</span> <span class="n">pair</span>
            <span class="c1"># Find the common indices of intersection points (referring to isect)</span>
            <span class="c1"># and find where they are located in the array point_ind[ind_0]</span>
            <span class="n">common_ind</span><span class="p">,</span> <span class="n">i0</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">setmembership</span><span class="o">.</span><span class="n">ismember_rows</span><span class="p">(</span>
                <span class="n">point_ind</span><span class="p">[</span><span class="n">ind_1</span><span class="p">],</span> <span class="n">point_ind</span><span class="p">[</span><span class="n">ind_0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="c1"># Convert from boolean indices to indices</span>
            <span class="n">common_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">common_ind</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># There should be exactly two intersection points</span>
            <span class="k">assert</span> <span class="n">common_ind</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span>

            <span class="c1"># Do the same exercise with the second fracture</span>
            <span class="n">common_ind_2</span><span class="p">,</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">setmembership</span><span class="o">.</span><span class="n">ismember_rows</span><span class="p">(</span>
                <span class="n">point_ind</span><span class="p">[</span><span class="n">ind_0</span><span class="p">],</span> <span class="n">point_ind</span><span class="p">[</span><span class="n">ind_1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">common_ind_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">common_ind_2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">common_ind_2</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span>

            <span class="c1"># Check if the intersection points form a boundary edge of each of the</span>
            <span class="c1"># fractures. The indexing is a bit involved, but is based on there being</span>
            <span class="c1"># two intersection points for each segment - thus the indices in i0 and i1</span>
            <span class="c1"># must be divided by two.</span>
            <span class="n">on_bound_0</span> <span class="o">=</span> <span class="n">bound_info</span><span class="p">[</span><span class="n">ind_0</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">i0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>
            <span class="n">on_bound_1</span> <span class="o">=</span> <span class="n">bound_info</span><span class="p">[</span><span class="n">ind_1</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>

            <span class="c1"># Add the intersection to the internal storage</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_intersection</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">[</span><span class="n">ind_0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">[</span><span class="n">ind_1</span><span class="p">],</span>
                <span class="n">isect</span><span class="p">[:,</span> <span class="n">point_ind</span><span class="p">[</span><span class="n">ind_1</span><span class="p">][</span><span class="n">common_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]],</span>
                <span class="n">isect</span><span class="p">[:,</span> <span class="n">point_ind</span><span class="p">[</span><span class="n">ind_1</span><span class="p">][</span><span class="n">common_ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]]],</span>
                <span class="n">bound_first</span><span class="o">=</span><span class="n">on_bound_0</span><span class="p">,</span>
                <span class="n">bound_second</span><span class="o">=</span><span class="n">on_bound_1</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Found </span><span class="si">%i</span><span class="s2"> intersections. Elapsed time: </span><span class="si">%.5f</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">),</span>
            <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="FractureNetwork3d.split_intersections"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html#porepy.fracs.fracture_network_3d.FractureNetwork3d.split_intersections">[docs]</a>    <span class="k">def</span> <span class="nf">split_intersections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Based on the fracture network, and their known intersections, decompose</span>
<span class="sd">        the fractures into non-intersecting sub-polygons. These can</span>
<span class="sd">        subsequently be exported to gmsh.</span>

<span class="sd">        The method will add an attribute decomposition to self.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Split intersections&quot;</span><span class="p">)</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># First, collate all points and edges used to describe fracture</span>
        <span class="c1"># boundaries and intersections.</span>
        <span class="n">all_p</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">edges_2_frac</span><span class="p">,</span> <span class="n">is_boundary_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_and_edge_lists</span><span class="p">()</span>

        <span class="c1"># By now, all segments in the grid are defined by a unique set of</span>
        <span class="c1"># points and edges. The next task is to identify intersecting edges,</span>
        <span class="c1"># and split them.</span>
        <span class="n">all_p</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">edges_2_frac</span><span class="p">,</span> <span class="n">is_boundary_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_edge_intersections</span><span class="p">(</span>
            <span class="n">all_p</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">edges_2_frac</span><span class="p">,</span> <span class="n">is_boundary_edge</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_checks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_verify_fractures_in_plane</span><span class="p">(</span><span class="n">all_p</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">edges_2_frac</span><span class="p">)</span>

        <span class="c1"># Store the full decomposition.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;points&quot;</span><span class="p">:</span> <span class="n">all_p</span><span class="p">,</span>
            <span class="s2">&quot;edges&quot;</span><span class="p">:</span> <span class="n">edges</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">),</span>
            <span class="s2">&quot;is_bound&quot;</span><span class="p">:</span> <span class="n">is_boundary_edge</span><span class="p">,</span>
            <span class="s2">&quot;edges_2_frac&quot;</span><span class="p">:</span> <span class="n">edges_2_frac</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">line_in_frac</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fi</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">):</span>
            <span class="n">ei</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">ei_bound</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Find the edges of this fracture, add to either internal or</span>
            <span class="c1"># external fracture list</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">edges_2_frac</span><span class="p">,</span> <span class="n">is_boundary_edge</span><span class="p">)):</span>
                <span class="c1"># Check that the boundary information matches the fractures</span>
                <span class="k">assert</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
                <span class="n">hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">fi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">hit</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">hit</span><span class="p">]:</span>
                        <span class="n">ei_bound</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ei</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">hit</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Non-unique fracture edge relation&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>

            <span class="n">poly</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sort_points</span><span class="o">.</span><span class="n">sort_point_pairs</span><span class="p">(</span><span class="n">edges</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ei_bound</span><span class="p">])</span>
            <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
            <span class="n">line_in_frac</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ei</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;polygons&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">polygons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;line_in_frac&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">line_in_frac</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Finished fracture splitting after </span><span class="si">%.5f</span><span class="s2"> seconds&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_fracs_2_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges_2_frac</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Invert the mapping between edges and fractures.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of list: For each fracture, index of all edges that points to</span>
<span class="sd">                it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f2e</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">)):</span>
            <span class="n">f_l</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges_2_frac</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">f_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ei</span><span class="p">)</span>
            <span class="n">f2e</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_l</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f2e</span>

    <span class="k">def</span> <span class="nf">_point_and_edge_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Obtain lists of all points and connections necessary to describe</span>
<span class="sd">        fractures and their intersections.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray, 3xn: Unique coordinates of all points used to describe</span>
<span class="sd">            the fracture polygons, and their intersections.</span>
<span class="sd">            np.ndarray, 2xn_edge: Connections between points, formed either</span>
<span class="sd">                by a fracture boundary, or a fracture intersection.</span>
<span class="sd">            list: For each edge, index of all fractures that point to the</span>
<span class="sd">                edge.</span>
<span class="sd">            np.ndarray of bool (size=num_edges): A flag telling whether the</span>
<span class="sd">                edge is on the boundary of a fracture.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The workflow is based on first collecting information for all fractures,</span>
        <span class="c1"># next get information for all intersections between fractures.</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Compile list of points and edges&quot;</span><span class="p">)</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># Field for all points in the fracture description</span>
        <span class="n">all_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="c1"># All edges, either as fracture boundary, or fracture intersection</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="c1"># For each edge, a list of all fractures pointing to the edge.</span>
        <span class="n">edges_2_frac</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Field to know if an edge is on the boundary of a fracture.</span>
        <span class="c1"># Not sure what to do with a T-type intersection here</span>
        <span class="n">is_boundary_edge</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># First loop over all fractures. All edges are assumed to be new; we</span>
        <span class="c1"># will deal with coinciding points later.</span>
        <span class="k">for</span> <span class="n">fi</span><span class="p">,</span> <span class="n">frac</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">):</span>
            <span class="n">num_p</span> <span class="o">=</span> <span class="n">all_p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">num_p_loc</span> <span class="o">=</span> <span class="n">frac</span><span class="o">.</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">all_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">all_p</span><span class="p">,</span> <span class="n">frac</span><span class="o">.</span><span class="n">pts</span><span class="p">))</span>

            <span class="n">loc_e</span> <span class="o">=</span> <span class="n">num_p</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_p_loc</span><span class="p">),</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_p_loc</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">num_p_loc</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">edges</span><span class="p">,</span> <span class="n">loc_e</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_p_loc</span><span class="p">):</span>
                <span class="n">edges_2_frac</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">fi</span><span class="p">])</span>
                <span class="n">is_boundary_edge</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="kc">True</span><span class="p">])</span>

        <span class="c1"># Next, add points relating to the intersections between fractures.</span>
        <span class="c1"># Since the intersections are already defined as numpy arrays, this is</span>
        <span class="c1"># relatively straightforward.</span>
        <span class="n">num_isect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">num_p</span> <span class="o">=</span> <span class="n">all_p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Intersection points are added by first all starts, then all ends</span>
        <span class="n">isect_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]))</span>
        <span class="c1"># Intersection edges are offset by the number of fracture edges</span>
        <span class="n">intersection_edges</span> <span class="o">=</span> <span class="n">num_p</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_isect</span><span class="p">),</span> <span class="n">num_isect</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_isect</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="c1"># Merge fields</span>
        <span class="n">all_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">all_p</span><span class="p">,</span> <span class="n">isect_pt</span><span class="p">))</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">edges</span><span class="p">,</span> <span class="n">intersection_edges</span><span class="p">))</span>

        <span class="c1"># Mapping from intersections to their fractures</span>
        <span class="n">isect_2_frac</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;first&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;second&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_isect</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">edges_2_frac</span> <span class="o">+=</span> <span class="n">isect_2_frac</span>

        <span class="c1"># Boolean for intersections being on fracture boundaries</span>
        <span class="n">isect_is_boundary</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;bound_first&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;bound_second&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_isect</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">is_boundary_edge</span> <span class="o">+=</span> <span class="n">isect_is_boundary</span>

        <span class="c1"># Ensure that edges are integers</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Points and edges done. Elapsed time </span><span class="si">%.5f</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
        <span class="p">)</span>
        <span class="c1"># Uniquify the points and edges before returning.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniquify_points_and_edges</span><span class="p">(</span>
            <span class="n">all_p</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">edges_2_frac</span><span class="p">,</span> <span class="n">is_boundary_edge</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_uniquify_points_and_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_p</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">edges_2_frac</span><span class="p">,</span> <span class="n">is_boundary_edge</span><span class="p">):</span>

        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sd">&quot;&quot;&quot;Uniquify points and edges, starting with %i points, %i</span>
<span class="sd">                    edges&quot;&quot;&quot;</span><span class="p">,</span>
            <span class="n">all_p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># We now need to find points that occur in multiple places</span>
        <span class="n">p_unique</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">all_2_unique_p</span> <span class="o">=</span> <span class="n">setmembership</span><span class="o">.</span><span class="n">uniquify_point_set</span><span class="p">(</span>
            <span class="n">all_p</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Update edges to work with unique points</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">all_2_unique_p</span><span class="p">[</span><span class="n">edges</span><span class="p">]</span>

        <span class="c1"># Look for edges that share both nodes. These will be identical, and</span>
        <span class="c1"># will form either an L/Y-type intersection (shared boundary segment),</span>
        <span class="c1"># or a three fractures meeting in a line.</span>
        <span class="c1"># Do a sort of edges before looking for duplicates.</span>
        <span class="n">e_unique</span><span class="p">,</span> <span class="n">unique_ind_e</span><span class="p">,</span> <span class="n">all_2_unique_e</span> <span class="o">=</span> <span class="n">setmembership</span><span class="o">.</span><span class="n">unique_columns_tol</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Update the edges_2_frac map to refer to the new edges</span>
        <span class="n">edges_2_frac_new</span> <span class="o">=</span> <span class="n">e_unique</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)]</span>
        <span class="n">is_boundary_edge_new</span> <span class="o">=</span> <span class="n">e_unique</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">old_i</span><span class="p">,</span> <span class="n">new_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_2_unique_e</span><span class="p">):</span>
            <span class="n">edges_2_frac_new</span><span class="p">[</span><span class="n">new_i</span><span class="p">],</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">edges_2_frac_new</span><span class="p">[</span><span class="n">new_i</span><span class="p">],</span> <span class="n">edges_2_frac</span><span class="p">[</span><span class="n">old_i</span><span class="p">])),</span>
                <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">is_boundary_edge_new</span><span class="p">[</span><span class="n">new_i</span><span class="p">],</span> <span class="n">is_boundary_edge</span><span class="p">[</span><span class="n">old_i</span><span class="p">]))</span>
            <span class="n">is_boundary_edge_new</span><span class="p">[</span><span class="n">new_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

        <span class="n">edges_2_frac</span> <span class="o">=</span> <span class="n">edges_2_frac_new</span>
        <span class="n">is_boundary_edge</span> <span class="o">=</span> <span class="n">is_boundary_edge_new</span>

        <span class="c1"># Represent edges by unique values</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">e_unique</span>

        <span class="c1"># The uniquification of points may lead to edges with identical start</span>
        <span class="c1"># and endpoint. Find and remove these.</span>
        <span class="n">point_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">point_edges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># FIXME: Delete, right?</span>
        <span class="n">unique_ind_e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">unique_ind_e</span><span class="p">,</span> <span class="n">point_edges</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">point_edges</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">del</span> <span class="n">edges_2_frac</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">is_boundary_edge</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span>

        <span class="c1"># Ensure that the edge to fracture map to a list of numpy arrays.</span>
        <span class="c1"># Use unique so that the same edge only refers to an edge once.</span>
        <span class="n">edges_2_frac</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edges_2_frac</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges_2_frac</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="c1"># Sanity check, the fractures should still be defined by points in a</span>
        <span class="c1"># plane.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_checks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_verify_fractures_in_plane</span><span class="p">(</span><span class="n">p_unique</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">edges_2_frac</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sd">&quot;&quot;&quot;Uniquify complete. %i points, %i edges. Elapsed time</span>
<span class="sd">                    %.5f&quot;&quot;&quot;</span><span class="p">,</span>
            <span class="n">p_unique</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">p_unique</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">edges_2_frac</span><span class="p">,</span> <span class="n">is_boundary_edge</span>

    <span class="k">def</span> <span class="nf">_remove_edge_intersections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_p</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">edges_2_frac</span><span class="p">,</span> <span class="n">is_boundary_edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove crossings from the set of fracture intersections.</span>

<span class="sd">        Intersecting intersections (yes) are split, and new points are</span>
<span class="sd">        introduced.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            all_p (np.ndarray, 3xn): Coordinates of all points used to describe</span>
<span class="sd">                the fracture polygons, and their intersections. Should be</span>
<span class="sd">                unique.</span>
<span class="sd">            edges (np.ndarray, 2xn): Connections between points, formed either</span>
<span class="sd">                by a fracture boundary, or a fracture intersection.</span>
<span class="sd">            edges_2_frac (list of np.arrays): One list item per edge, each item is an</span>
<span class="sd">                np.array with indices of all fractures sharing this edge.</span>
<span class="sd">            is_boundary_edge (list of np.arrays): One list item per edge. Each item is</span>
<span class="sd">                an np.array with values 0 or 1, according to whether the edge is on the</span>
<span class="sd">                boundary of a fracture. Ordering of the inner list corresponds to the</span>
<span class="sd">                ordering in edges_2_frac.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The same fields, but updated so that all edges are</span>
<span class="sd">            non-intersecting.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Remove edge intersections&quot;</span><span class="p">)</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># The algorithm loops over all fractures, pulls out edges associated</span>
        <span class="c1"># with the fracture, project to the local 2D plane, and look for</span>
        <span class="c1"># intersections there (direct search in 3D may also work, but this was</span>
        <span class="c1"># a simple option). When intersections are found, the global lists of</span>
        <span class="c1"># points and edges are updated.</span>
        <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">)):</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Remove intersections from fracture </span><span class="si">%i</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">fi</span><span class="p">)</span>

            <span class="c1"># Identify the edges associated with this fracture</span>
            <span class="c1"># It would have been more convenient to use an inverse</span>
            <span class="c1"># relationship frac_2_edge here, but that would have made the</span>
            <span class="c1"># update for new edges (towards the end of this loop) more</span>
            <span class="c1"># cumbersome.</span>

            <span class="c1"># frac_2_edge is a list of arrays of varying size; we need to find</span>
            <span class="c1"># occurrences of fi within those lists. Looping is slow, so we expand</span>
            <span class="c1"># to a standard list (hstack below), and use rldecode to make a mapping</span>
            <span class="c1"># from the expanded list back to the original nested list.</span>
            <span class="n">frac_ind_expanded</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">matrix_operations</span><span class="o">.</span><span class="n">rldecode</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges_2_frac</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges_2_frac</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="n">edges_loc_ind</span> <span class="o">=</span> <span class="n">frac_ind_expanded</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">edges_2_frac</span><span class="p">)</span> <span class="o">==</span> <span class="n">fi</span><span class="p">]</span>
            <span class="n">edges_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">edges</span><span class="p">[:,</span> <span class="n">edges_loc_ind</span><span class="p">],</span> <span class="n">edges_loc_ind</span><span class="p">))</span>

            <span class="n">p_ind_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">edges_loc</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">p_loc</span> <span class="o">=</span> <span class="n">all_p</span><span class="p">[:,</span> <span class="n">p_ind_loc</span><span class="p">]</span>

            <span class="n">p_2d</span><span class="p">,</span> <span class="n">edges_2d</span><span class="p">,</span> <span class="n">p_loc_c</span><span class="p">,</span> <span class="n">rot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points_2_plane</span><span class="p">(</span>
                <span class="n">p_loc</span><span class="p">,</span> <span class="n">edges_loc</span><span class="p">,</span> <span class="n">p_ind_loc</span>
            <span class="p">)</span>

            <span class="c1"># Add a tag to trace the edges during splitting</span>
            <span class="n">edges_2d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges_loc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1"># Obtain new points and edges, so that no edges on this fracture</span>
            <span class="c1"># are intersecting.</span>
            <span class="c1"># It seems necessary to increase the tolerance here somewhat to</span>
            <span class="c1"># obtain a more robust algorithm. Not sure about how to do this</span>
            <span class="c1"># consistent.</span>
            <span class="n">p_new</span><span class="p">,</span> <span class="n">edges_new</span><span class="p">,</span> <span class="n">tags</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">intersections</span><span class="o">.</span><span class="n">split_intersecting_segments_2d</span><span class="p">(</span>
                <span class="n">p_2d</span><span class="p">,</span> <span class="n">edges_2d</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span>
            <span class="p">)</span>
            <span class="c1"># Then, patch things up by converting new points to 3D,</span>

            <span class="c1"># From the design of the functions in cg, we know that new points</span>
            <span class="c1"># are attached to the end of the array. A more robust alternative</span>
            <span class="c1"># is to find unique points on a combined array of p_loc and p_new.</span>
            <span class="n">p_add</span> <span class="o">=</span> <span class="n">p_new</span><span class="p">[:,</span> <span class="n">p_ind_loc</span><span class="o">.</span><span class="n">size</span> <span class="p">:]</span>
            <span class="n">num_p_add</span> <span class="o">=</span> <span class="n">p_add</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Add third coordinate, and map back to 3D</span>
            <span class="n">p_add</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">p_add</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_p_add</span><span class="p">)))</span>

            <span class="c1"># Inverse of rotation matrix is the transpose, add cloud center</span>
            <span class="c1"># correction</span>
            <span class="n">p_add_3d</span> <span class="o">=</span> <span class="n">rot</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p_add</span><span class="p">)</span> <span class="o">+</span> <span class="n">p_loc_c</span>

            <span class="c1"># The new points will be added at the end of the global point array</span>
            <span class="c1"># (if not, we would need to renumber all global edges).</span>
            <span class="c1"># Global index of added points</span>
            <span class="n">ind_p_add</span> <span class="o">=</span> <span class="n">all_p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_p_add</span><span class="p">)</span>
            <span class="c1"># Global index of local points (new and added)</span>
            <span class="n">p_ind_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">p_ind_loc</span><span class="p">,</span> <span class="n">ind_p_add</span><span class="p">))</span>

            <span class="c1"># Add the new points towards the end of the list.</span>
            <span class="n">all_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">all_p</span><span class="p">,</span> <span class="n">p_add_3d</span><span class="p">))</span>

            <span class="n">new_all_p</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">ia</span> <span class="o">=</span> <span class="n">setmembership</span><span class="o">.</span><span class="n">uniquify_point_set</span><span class="p">(</span><span class="n">all_p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span>

            <span class="c1"># Handle case where the new point is already represented in the</span>
            <span class="c1"># global list of points.</span>
            <span class="k">if</span> <span class="n">new_all_p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">all_p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">all_p</span> <span class="o">=</span> <span class="n">new_all_p</span>
                <span class="n">p_ind_exp</span> <span class="o">=</span> <span class="n">ia</span><span class="p">[</span><span class="n">p_ind_exp</span><span class="p">]</span>

            <span class="c1"># The ordering of the global edge list bears no significance. We</span>
            <span class="c1"># therefore plan to delete all edges (new and old), and add new</span>
            <span class="c1"># ones.</span>

            <span class="c1"># First add new edges.</span>
            <span class="c1"># All local edges in terms of global point indices</span>
            <span class="n">edges_new_glob</span> <span class="o">=</span> <span class="n">p_ind_exp</span><span class="p">[</span><span class="n">edges_new</span><span class="p">[:</span><span class="mi">2</span><span class="p">]]</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">edges</span><span class="p">,</span> <span class="n">edges_new_glob</span><span class="p">))</span>

            <span class="c1"># Global indices of the local edges</span>
            <span class="n">edges_loc_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">edges_loc_ind</span><span class="p">)</span>

            <span class="c1"># Append fields for edge-fracture map and boundary tags</span>
            <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">edges_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># Find the global edge index. For most edges, this will be</span>
                <span class="c1"># correctly identified by edges_new[2], which tracks the</span>
                <span class="c1"># original edges under splitting. However, in cases of</span>
                <span class="c1"># overlapping segments, in which case the index of the one edge</span>
                <span class="c1"># may completely override the index of the other (this is</span>
                <span class="c1"># caused by the implementation of split_intersection_segments_2d.</span>
                <span class="c1"># We therefore compare the new edge to the old ones (before</span>
                <span class="c1"># splitting). If found, use the old information; if not, use</span>
                <span class="c1"># index as tracked by splitting.</span>
                <span class="n">is_old</span><span class="p">,</span> <span class="n">old_loc_ind</span> <span class="o">=</span> <span class="n">setmembership</span><span class="o">.</span><span class="n">ismember_rows</span><span class="p">(</span>
                    <span class="n">edges_new_glob</span><span class="p">[:,</span> <span class="n">ei</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">edges</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="n">edges_loc_ind</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">is_old</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># The edge was preserved, with the same indices for start and end</span>
                    <span class="c1"># during splitting. Information on edge-to-fracs, and on whether this</span>
                    <span class="c1"># is a boundary edge is identical to that of the edge before the</span>
                    <span class="c1"># splitting routine. The global index is that of the local edges</span>
                    <span class="c1"># that had the same nodes.</span>
                    <span class="n">glob_ei</span> <span class="o">=</span> <span class="p">[</span><span class="n">edges_loc_ind</span><span class="p">[</span><span class="n">old_loc_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># This edge is formed by splitting of old edges. To recover all,</span>
                    <span class="c1"># exploit information from the splitting of segments.</span>
                    <span class="n">cols_mapped_to_glob_ei</span> <span class="o">=</span> <span class="n">tags</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ei</span>
                    <span class="n">glob_ei</span> <span class="o">=</span> <span class="n">tags</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">cols_mapped_to_glob_ei</span><span class="p">]</span>

                <span class="c1"># Update edge_2_frac and boundary information.</span>
                <span class="n">e2f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">ib</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">gi</span> <span class="ow">in</span> <span class="n">glob_ei</span><span class="p">:</span>
                    <span class="n">e2f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">e2f</span><span class="p">,</span> <span class="n">edges_2_frac</span><span class="p">[</span><span class="n">gi</span><span class="p">]))</span>
                    <span class="n">ib</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ib</span><span class="p">,</span> <span class="n">is_boundary_edge</span><span class="p">[</span><span class="n">gi</span><span class="p">]))</span>

                <span class="c1"># There may de duplicates in e2f (if the size of glob_ei is larger</span>
                <span class="c1"># than 1), but these are removed in the below call to uniquify points</span>
                <span class="c1"># and edges.</span>
                <span class="n">edges_2_frac</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e2f</span><span class="p">)</span>
                <span class="n">is_boundary_edge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ib</span><span class="p">)</span>

            <span class="c1"># Finally, purge the old edges</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">edges_loc_ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># We cannot delete more than one list element at a time. Delete by</span>
            <span class="c1"># index in decreasing order, so that we do not disturb the index</span>
            <span class="c1"># map.</span>
            <span class="n">edges_loc_ind</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="n">edges_loc_ind</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">del</span> <span class="n">edges_2_frac</span><span class="p">[</span><span class="n">ei</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">is_boundary_edge</span><span class="p">[</span><span class="n">ei</span><span class="p">]</span>
            <span class="c1"># And we are done with this fracture. On to the next one.</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Done with intersection removal. Elapsed time </span><span class="si">%.5f</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_checks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_verify_fractures_in_plane</span><span class="p">(</span><span class="n">all_p</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">edges_2_frac</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uniquify_points_and_edges</span><span class="p">(</span>
            <span class="n">all_p</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">edges_2_frac</span><span class="p">,</span> <span class="n">is_boundary_edge</span>
        <span class="p">)</span>

<div class="viewcode-block" id="FractureNetwork3d.fractures_of_points"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html#porepy.fracs.fracture_network_3d.FractureNetwork3d.fractures_of_points">[docs]</a>    <span class="k">def</span> <span class="nf">fractures_of_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a given point, find all fractures that refer to it, either as</span>
<span class="sd">        vertex or as internal.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of int: indices of fractures, one list item per point.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fracs_of_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pts</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pts</span><span class="p">:</span>
            <span class="n">fracs_loc</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># First identify edges that refer to the point</span>
            <span class="n">edge_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;edges&quot;</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
            <span class="n">edges_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;edges&quot;</span><span class="p">][:,</span> <span class="n">edge_ind</span><span class="p">]</span>
            <span class="c1"># Loop over all polygons. If their edges are found in edges_loc,</span>
            <span class="c1"># store the corresponding fracture index</span>
            <span class="k">for</span> <span class="n">poly_ind</span><span class="p">,</span> <span class="n">poly</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;polygons&quot;</span><span class="p">]):</span>
                <span class="n">ismem</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">setmembership</span><span class="o">.</span><span class="n">ismember_rows</span><span class="p">(</span><span class="n">edges_loc</span><span class="p">,</span> <span class="n">poly</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ismem</span><span class="p">):</span>
                    <span class="n">fracs_loc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;polygon_frac&quot;</span><span class="p">][</span><span class="n">poly_ind</span><span class="p">])</span>
            <span class="n">fracs_of_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">fracs_loc</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">fracs_of_points</span></div>

<div class="viewcode-block" id="FractureNetwork3d.close_points"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html#porepy.fracs.fracture_network_3d.FractureNetwork3d.close_points">[docs]</a>    <span class="k">def</span> <span class="nf">close_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In the set of points used to describe the fractures (after</span>
<span class="sd">        decomposition), find pairs that are closer than a certain distance.</span>
<span class="sd">        Intended use: Debugging.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            dist (double): Threshold distance, all points closer than this will</span>
<span class="sd">                be reported.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of tuples: Each tuple contain indices of a set of close</span>
<span class="sd">                points, and the distance between the points. The list is not</span>
<span class="sd">                symmetric; if (a, b) is a member, (b, a) will not be.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c_points</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;points&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">point_pointset</span><span class="p">(</span><span class="n">pt</span><span class="p">[:,</span> <span class="n">pi</span><span class="p">],</span> <span class="n">pt</span><span class="p">[:,</span> <span class="n">pi</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:])</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                <span class="c1"># Indices of close points, with an offset to compensate for</span>
                <span class="c1"># slicing of the point cloud.</span>
                <span class="n">c_points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pi</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">pi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">c_points</span></div>

    <span class="k">def</span> <span class="nf">_verify_fractures_in_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">edges_2_frac</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Essentially a debugging method that verify that the given set of</span>
<span class="sd">        points, edges and edge connections indeed form planes.</span>

<span class="sd">        This has turned out to be a common symptom of trouble.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">fi</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">):</span>

            <span class="c1"># Identify the edges associated with this fracture</span>
            <span class="n">edges_loc_ind</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges_2_frac</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">e</span> <span class="o">==</span> <span class="n">fi</span><span class="p">):</span>
                    <span class="n">edges_loc_ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ei</span><span class="p">)</span>

            <span class="n">edges_loc</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[:,</span> <span class="n">edges_loc_ind</span><span class="p">]</span>
            <span class="n">p_ind_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">edges_loc</span><span class="p">)</span>
            <span class="n">p_loc</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:,</span> <span class="n">p_ind_loc</span><span class="p">]</span>

            <span class="c1"># Run through points_2_plane, to check the assertions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points_2_plane</span><span class="p">(</span><span class="n">p_loc</span><span class="p">,</span> <span class="n">edges_loc</span><span class="p">,</span> <span class="n">p_ind_loc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_points_2_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p_loc</span><span class="p">,</span> <span class="n">edges_loc</span><span class="p">,</span> <span class="n">p_ind_loc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method for rotating a point cloud into its own 2d-plane.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Center point cloud around the origin</span>
        <span class="n">p_loc_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">p_loc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">p_loc</span> <span class="o">-=</span> <span class="n">p_loc_c</span>

        <span class="c1"># Project the points onto the local plane defined by the fracture</span>
        <span class="n">rot</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">map_geometry</span><span class="o">.</span><span class="n">project_plane_matrix</span><span class="p">(</span><span class="n">p_loc</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span>
        <span class="n">p_2d</span> <span class="o">=</span> <span class="n">rot</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p_loc</span><span class="p">)</span>

        <span class="n">extent</span> <span class="o">=</span> <span class="n">p_2d</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">p_2d</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">lateral_extent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lateral_extent</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">*</span> <span class="mi">30</span>

        <span class="c1"># Dump third coordinate</span>
        <span class="n">p_2d</span> <span class="o">=</span> <span class="n">p_2d</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># The edges must also be redefined to account for the (implicit)</span>
        <span class="c1"># local numbering of points</span>
        <span class="n">edges_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">edges_loc</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">edges_loc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">edges_2d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ei</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">p_ind_loc</span> <span class="o">==</span> <span class="n">edges_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ei</span><span class="p">])</span>
            <span class="n">edges_2d</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">ei</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">p_ind_loc</span> <span class="o">==</span> <span class="n">edges_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">ei</span><span class="p">])</span>

        <span class="k">assert</span> <span class="n">edges_2d</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">p_loc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">p_2d</span><span class="p">,</span> <span class="n">edges_2d</span><span class="p">,</span> <span class="n">p_loc_c</span><span class="p">,</span> <span class="n">rot</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Fracture set with &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; planes</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;boundary&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">:</span>
            <span class="n">bnd</span> <span class="o">=</span> <span class="s2">&quot;boundary&quot;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="n">bnd</span><span class="p">])</span><span class="si">}</span><span class="s2"> of the fractures are domain boundaries&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;No boundary information is given&quot;</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">_reindex_fractures</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">fi</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">fi</span>

<div class="viewcode-block" id="FractureNetwork3d.bounding_box"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html#porepy.fracs.fracture_network_3d.FractureNetwork3d.bounding_box">[docs]</a>    <span class="k">def</span> <span class="nf">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Obtain bounding box for fracture network.</span>

<span class="sd">        The box is defined by the external boundary, if imposed, or if not by</span>
<span class="sd">        the maximal extent of the fractures in each direction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dictionary with fields &#39;xmin&#39;, &#39;xmax&#39;, &#39;ymin&#39;, &#39;ymax&#39;, &#39;zmin&#39;,</span>
<span class="sd">                &#39;zmax&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">min_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="n">max_coord</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">:</span>
            <span class="n">min_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">min_coord</span><span class="p">)</span>
            <span class="n">max_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">max_coord</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;xmin&quot;</span><span class="p">:</span> <span class="n">min_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s2">&quot;xmax&quot;</span><span class="p">:</span> <span class="n">max_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s2">&quot;ymin&quot;</span><span class="p">:</span> <span class="n">min_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="s2">&quot;ymax&quot;</span><span class="p">:</span> <span class="n">max_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="s2">&quot;zmin&quot;</span><span class="p">:</span> <span class="n">min_coord</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="s2">&quot;zmax&quot;</span><span class="p">:</span> <span class="n">max_coord</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="FractureNetwork3d.impose_external_boundary"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html#porepy.fracs.fracture_network_3d.FractureNetwork3d.impose_external_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">impose_external_boundary</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">domain</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keep_box</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">area_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="p">,</span>
        <span class="n">clear_gmsh</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">finalize_gmsh</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set an external boundary for the fracture set.</span>

<span class="sd">        There are two permissible data formats for the domain boundary:</span>
<span class="sd">            1) A 3D box, described by its minimum and maximum coordinates.</span>
<span class="sd">            2) A list of polygons (each specified as a np.array, 3xn), that together</span>
<span class="sd">                form a closed polyhedron.</span>

<span class="sd">        If no bounding box is provided, a box will be fitted outside the fracture</span>
<span class="sd">        network.</span>

<span class="sd">        The fractures will be truncated to lay within the bounding</span>
<span class="sd">        box; that is, Fracture.pts will be modified. The original coordinates of</span>
<span class="sd">        the fracture boundary can still be recovered from the attribute</span>
<span class="sd">        Fracture.orig_points.</span>

<span class="sd">        Fractures that are completely outside the bounding box will be deleted</span>
<span class="sd">        from the fracture set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        domain (dictionary or list of np.ndarray): See above for description.</span>
<span class="sd">        keep_box (bool, optional): If True (default), the bounding surfaces will be</span>
<span class="sd">            added to the end of the fracture list, and tagged as boundary.</span>
<span class="sd">        area_threshold (float): Lower threshold for how much of a fracture&#39;s area</span>
<span class="sd">            should be within the bounding box for the fracture to be preserved.</span>
<span class="sd">            Defaults to 1e-4</span>
<span class="sd">        finalize_gmsh and</span>
<span class="sd">        clear_gmsh</span>
<span class="sd">            are needed in the context of potentially non-convex fractures. The values</span>
<span class="sd">            used here should be the same as in a call to self.mesh(); default values</span>
<span class="sd">            should be sufficient for all regular usage.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array: Mapping from old to new fractures, referring to the fractures in</span>
<span class="sd">            self._fractures before and after imposing the external boundary.</span>
<span class="sd">            The mapping does not account for the boundary fractures added to the</span>
<span class="sd">            end of the fracture array (if keep_box) is True.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the FractureNetwork contains no fractures and no domain was passed</span>
<span class="sd">            to this method.</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">:</span>
            <span class="c1"># Cannot automatically calculate external boundary for non-fractured grids.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;A domain must be supplied to constrain non-fractured media.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box_imposed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">polyhedron</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">make_bounding_planes_from_box</span><span class="p">(</span>
                    <span class="n">domain</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">polyhedron</span> <span class="o">=</span> <span class="n">domain</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Compute a bounding box from the extension of the fractures.</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="mf">0.15</span>
            <span class="n">cmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
            <span class="n">cmax</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">:</span>
                <span class="n">cmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">cmin</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">cmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">cmax</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">cmin</span> <span class="o">=</span> <span class="n">cmin</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">cmax</span> <span class="o">=</span> <span class="n">cmax</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="n">dx</span> <span class="o">=</span> <span class="n">overlap</span> <span class="o">*</span> <span class="p">(</span><span class="n">cmax</span> <span class="o">-</span> <span class="n">cmin</span><span class="p">)</span>

            <span class="c1"># If the fractures has no extension along one of the coordinate</span>
            <span class="c1"># (a single fracture aligned with one axis), the domain should</span>
            <span class="c1"># still have an extension.</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dx</span><span class="p">[</span><span class="n">hit</span><span class="p">]</span> <span class="o">=</span> <span class="n">overlap</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>

            <span class="n">box</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;xmin&quot;</span><span class="p">:</span> <span class="n">cmin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;xmax&quot;</span><span class="p">:</span> <span class="n">cmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;ymin&quot;</span><span class="p">:</span> <span class="n">cmin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="s2">&quot;ymax&quot;</span><span class="p">:</span> <span class="n">cmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="s2">&quot;zmin&quot;</span><span class="p">:</span> <span class="n">cmin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">dx</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="s2">&quot;zmax&quot;</span><span class="p">:</span> <span class="n">cmax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="p">}</span>
            <span class="n">polyhedron</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">make_bounding_planes_from_box</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">polyhedron</span>

        <span class="c1"># Constrain the fractures to lie within the bounding polyhedron</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">pts</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">]</span>

        <span class="n">constrained_polys</span><span class="p">,</span> <span class="n">inds</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">constrain_geometry</span><span class="o">.</span><span class="n">polygons_by_polyhedron</span><span class="p">(</span>
            <span class="n">polys</span><span class="p">,</span> <span class="n">polyhedron</span>
        <span class="p">)</span>
        <span class="c1"># Delete fractures that are not member of any constrained fracture</span>
        <span class="n">old_frac_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">))</span>
        <span class="n">delete_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">old_frac_ind</span><span class="p">,</span> <span class="n">inds</span><span class="p">)</span>
        <span class="c1"># Identify fractures that have been split</span>
        <span class="k">if</span> <span class="n">inds</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">split_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">split_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Split fractures should be deleted</span>
        <span class="n">delete_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">delete_frac</span><span class="p">,</span> <span class="n">split_frac</span><span class="p">))</span>
        <span class="n">ind_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">old_frac_ind</span><span class="p">,</span> <span class="n">delete_frac</span><span class="p">)</span>

        <span class="c1"># Update the fractures with the new data format</span>
        <span class="k">for</span> <span class="n">poly</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">constrained_polys</span><span class="p">,</span> <span class="n">inds</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">split_frac</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">pts</span> <span class="o">=</span> <span class="n">poly</span>

        <span class="c1"># Special handling of fractures that are split in two</span>
        <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">split_frac</span><span class="p">:</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">inds</span> <span class="o">==</span> <span class="n">fi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">sub_i</span> <span class="ow">in</span> <span class="n">hit</span><span class="p">:</span>
                <span class="c1"># The fractures may very well be non-convex at this point, so</span>
                <span class="c1"># the points should not be sorted.</span>
                <span class="c1"># Splitting of non-convex fractures into convex subparts is</span>
                <span class="c1"># handled below.</span>
                <span class="n">new_frac</span> <span class="o">=</span> <span class="n">PlaneFracture</span><span class="p">(</span><span class="n">constrained_polys</span><span class="p">[</span><span class="n">sub_i</span><span class="p">],</span> <span class="n">sort_points</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_frac</span><span class="p">)</span>
                <span class="n">ind_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ind_map</span><span class="p">,</span> <span class="n">fi</span><span class="p">))</span>

        <span class="c1"># Now, we may modify the fractures for two reasons:</span>
        <span class="c1"># 1) Only a tiny part of the fracture is contained within the region,</span>
        <span class="c1"># 2) The constrained polygon in non-convex, and must be split into smaller parts</span>
        <span class="c1">#    to be compatible with the intersection identification.</span>

        <span class="c1"># Some bookkeeping is needed to track which fractures to track.</span>
        <span class="n">current_ind_map</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">delete_from_ind_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># Loop over all fractures</span>
        <span class="k">for</span> <span class="n">fi</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">):</span>
            <span class="c1"># No need to check for fractures that will be deleted anyhow.</span>
            <span class="k">if</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">delete_frac</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Compute the area of the constrained fractures, relative to the original size.</span>
            <span class="c1"># Delete small fractures.</span>
            <span class="c1"># IMPLEMENTATION NOTE: Should we have an absolute threshold in addition to the</span>
            <span class="c1"># relative tolerance below?</span>

            <span class="c1"># Map the fracture to its natrual plane.</span>
            <span class="c1"># If the fracture is very small, we risk running into trouble here with</span>
            <span class="c1"># geometry checks that essentially detects almost coinciding points (although</span>
            <span class="c1"># the error message comes from a normal vector computation). Therefore, we</span>
            <span class="c1"># use very strict tolerances, and cross our fingers everything is fine.</span>
            <span class="n">rot</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">map_geometry</span><span class="o">.</span><span class="n">project_plane_matrix</span><span class="p">(</span>
                <span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">check_planar</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="n">center_coord</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">center</span>
            <span class="n">mapped_coord</span> <span class="o">=</span> <span class="n">rot</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">pts</span> <span class="o">-</span> <span class="n">center_coord</span><span class="p">)</span>
            <span class="n">mapped_orig</span> <span class="o">=</span> <span class="n">rot</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">orig_pts</span> <span class="o">-</span> <span class="n">center_coord</span><span class="p">)</span>

            <span class="c1"># Construct convex hulls, use these to construct the areas</span>
            <span class="c1"># The area for 2d ConvexHull (scipy style) is represented by the attribute volume.</span>
            <span class="n">hull_now</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">mapped_coord</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">hull_orig</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">mapped_orig</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">hull_now</span><span class="o">.</span><span class="n">volume</span> <span class="o">/</span> <span class="n">hull_orig</span><span class="o">.</span><span class="n">volume</span> <span class="o">&lt;</span> <span class="n">area_threshold</span><span class="p">:</span>
                <span class="c1"># If the part of the fracture inside the box is very small, add the</span>
                <span class="c1"># fracture to the list to be deleted, and remove it from the index mapping</span>
                <span class="c1"># between all and preserved fractures.</span>
                <span class="n">delete_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">delete_frac</span><span class="p">,</span> <span class="n">fi</span><span class="p">))</span>
                <span class="c1"># Take note that this item should be deleted from the index map</span>
                <span class="n">delete_from_ind_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">delete_from_ind_map</span><span class="p">,</span> <span class="n">current_ind_map</span><span class="p">))</span>
                <span class="n">current_ind_map</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># No need to consider this fracture more.</span>
                <span class="k">continue</span>

            <span class="c1"># Next, look for non-convex fracture.</span>
            <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># triangles are convex.</span>
                <span class="c1"># Increase the index pointing to ind_map</span>
                <span class="n">current_ind_map</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>

            <span class="c1"># Non-convex polygons are identified by comparing two triangulations,</span>
            <span class="c1"># one standard Delaunay triangulation with no constraints on adhering to</span>
            <span class="c1"># the polygon boundaries, and a second which is guaranteed not to cross</span>
            <span class="c1"># the polygon boundaries. If the two have equal area, the polygon is</span>
            <span class="c1"># convex, and we need not do anything more. If not, it should be</span>
            <span class="c1"># subdivided into smaller subpolygons.</span>

            <span class="c1"># Shorthand notation</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">mapped_coord</span>
            <span class="n">num_p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Use the ear clipping triangulation to create a &#39;safe&#39; triangulation</span>
            <span class="c1"># See Wikipedia for a description of the algorithm.</span>

            <span class="c1"># Indices used the access vertexes of the polygon. We will check if</span>
            <span class="c1"># a diagonal can be drawn between i0 and i2, so that the triangle</span>
            <span class="c1"># (i0, i1, i2) is inside the polygon and contains no other polygon</span>
            <span class="c1"># vertexes.</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">i2</span> <span class="o">=</span> <span class="mi">2</span>

            <span class="c1"># List of nodes removed (isolated by an introduced diagonal)</span>
            <span class="n">removed</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># List of triangles introduced</span>
            <span class="n">tris</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Helper function to get i2 move to the next available node</span>
            <span class="k">def</span> <span class="nf">_next_i2</span><span class="p">(</span><span class="n">i2</span><span class="p">):</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">i2</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">i2</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">i2</span> <span class="o">==</span> <span class="n">num_p</span><span class="p">:</span>
                        <span class="n">i2</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">i2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">removed</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">i2</span>

                    <span class="c1"># If we have made it a full circle, something is wrong.</span>
                    <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">i2</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span>

            <span class="c1"># Rolled version of the polygon, and of the indices.</span>
            <span class="c1"># Needed for segment intersection checks</span>
            <span class="n">p_rolled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Indices had to be rolled the other way, it turned out</span>
            <span class="n">ind_rolled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_p</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># vertexes of the prospective subtriangle</span>
                <span class="n">loc_poly</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:,</span> <span class="p">[</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">]]</span>

                <span class="c1"># A prospective diagonal (i0, i2) can be ruled out for two reasons:</span>
                <span class="c1"># 1) It crosses a segment of the polygon</span>
                <span class="c1"># 2) It is completely outside the polygon</span>
                <span class="c1"># 3) The prospective subtriangle fully contains another point</span>
                <span class="c1">#    (thus other segments). This can happen for a non-convex quad.</span>

                <span class="c1"># Check for all three. There must be better ways of doing this, with more</span>
                <span class="c1"># knowledge of computational geometry, but the code is what it is.</span>

                <span class="c1"># Distance from the prospective diagonal to all boundary segments</span>
                <span class="c1"># of the polygon.</span>
                <span class="n">dist</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">segment_segment_set</span><span class="p">(</span>
                    <span class="n">p</span><span class="p">[:,</span> <span class="n">i0</span><span class="p">],</span> <span class="n">p</span><span class="p">[:,</span> <span class="n">i2</span><span class="p">],</span> <span class="n">p</span><span class="p">,</span> <span class="n">p_rolled</span>
                <span class="p">)</span>

                <span class="c1"># Mask away all boundary segments which has i0 or i2 as one of its</span>
                <span class="c1"># endpoints.</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_p</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">i0</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">ind_rolled</span><span class="p">[</span><span class="n">i0</span><span class="p">],</span> <span class="n">ind_rolled</span><span class="p">[</span><span class="n">i2</span><span class="p">]])]</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="c1"># Find center of prospective triangle, check if inside the polygon.</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">loc_poly</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">center_in_poly</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">geometry_property_checks</span><span class="o">.</span><span class="n">point_in_polygon</span><span class="p">(</span>
                    <span class="n">p</span><span class="p">,</span> <span class="n">center</span>
                <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">other_points_in_loc_poly</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">geometry_property_checks</span><span class="o">.</span><span class="n">point_in_polygon</span><span class="p">(</span>
                    <span class="n">loc_poly</span><span class="p">,</span> <span class="n">p</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="n">center_in_poly</span>
                    <span class="ow">or</span> <span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="n">dist</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="n">other_points_in_loc_poly</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                <span class="p">):</span>
                    <span class="c1"># We cannot use this triangle - move on:</span>
                    <span class="c1"># i0 and i1 are moved one step up, i2 is moved to the next</span>
                    <span class="c1"># available vertex</span>
                    <span class="n">i0</span> <span class="o">=</span> <span class="n">i1</span>
                    <span class="n">i1</span> <span class="o">=</span> <span class="n">i2</span>
                    <span class="n">i2</span> <span class="o">=</span> <span class="n">_next_i2</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Introduce the diagonal (i0, i2).</span>
                    <span class="n">tris</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">])</span>
                    <span class="n">removed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span>
                    <span class="c1"># Move indices i1 and i2. i0 is fixed.</span>
                    <span class="n">i1</span> <span class="o">=</span> <span class="n">i2</span>
                    <span class="n">i2</span> <span class="o">=</span> <span class="n">_next_i2</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">removed</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_p</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># By now, we should have considered all possible candidates.</span>
                    <span class="k">break</span>

            <span class="c1"># Make a grid out of this triangulation for easy volume computation.</span>
            <span class="n">g_constrained</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">TriangleGrid</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tris</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">g_constrained</span><span class="o">.</span><span class="n">compute_geometry</span><span class="p">()</span>

            <span class="c1"># Make a grid with a standard Delaunay triangulation.</span>
            <span class="n">g_full</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">TriangleGrid</span><span class="p">(</span><span class="n">p</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">g_full</span><span class="o">.</span><span class="n">compute_geometry</span><span class="p">()</span>

            <span class="c1"># Compare volumes of the two grids. If they are almost equal, the</span>
            <span class="c1"># polygon should be convex.</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
                <span class="n">g_constrained</span><span class="o">.</span><span class="n">cell_volumes</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">g_full</span><span class="o">.</span><span class="n">cell_volumes</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span>
            <span class="p">):</span>
                <span class="c1"># Done with this fracture</span>
                <span class="c1"># Increase the index pointing to ind_map</span>
                <span class="n">current_ind_map</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>

            <span class="c1"># The polygon is not convex, and should be split into convex subparts.</span>
            <span class="c1"># We could use the good triangulation to that purpose, however, that is</span>
            <span class="c1"># likely to give badly shaped surfaces, and thus cells. Instead, use</span>
            <span class="c1"># the Hertel-Mehlhorn algorithm to construct larger convex polygons</span>
            <span class="c1"># by eliminating edges from the triangulation.</span>
            <span class="c1"># First, take note that the original fracture should be deleted.</span>
            <span class="n">delete_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">delete_frac</span><span class="p">,</span> <span class="n">fi</span><span class="p">))</span>
            <span class="n">delete_from_ind_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">delete_from_ind_map</span><span class="p">,</span> <span class="n">current_ind_map</span><span class="p">))</span>

            <span class="c1"># Subset of triangles that are inside</span>
            <span class="n">triangles</span> <span class="o">=</span> <span class="n">g_constrained</span><span class="o">.</span><span class="n">cell_nodes</span><span class="p">()</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

            <span class="c1"># Form all edges of the triangles</span>
            <span class="n">all_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">triangles</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span>
                    <span class="n">triangles</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:],</span>
                    <span class="n">triangles</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
                <span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">all_edges</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">edges</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">setmembership</span><span class="o">.</span><span class="n">unique_columns_tol</span><span class="p">(</span><span class="n">all_edges</span><span class="p">)</span>

            <span class="c1"># Edges on the boundary</span>
            <span class="n">essential_edge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Free edges are candidates for removal</span>
            <span class="n">free_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">essential_edge</span>
            <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="c1"># To keep track of angles in the polygon, we also need pairs of edges</span>
            <span class="c1"># with a common vertex.</span>
            <span class="c1"># Find the pairs looping over all vertexes, find all its</span>
            <span class="c1"># neighboring vertexes.</span>
            <span class="n">main_vertex_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">other_vertex_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">indptr_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_p</span><span class="p">):</span>
                <span class="n">row</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">triangles</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">triangles</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">num_other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">size</span>
                <span class="n">indptr_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indptr_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">num_other</span><span class="p">)</span>
                <span class="n">main_vertex_list</span> <span class="o">+=</span> <span class="n">num_other</span> <span class="o">*</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">other_vertex_list</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="n">edge_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">other_vertex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other_vertex_list</span><span class="p">)</span>
            <span class="n">indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indptr_list</span><span class="p">)</span>
            <span class="n">main_vertex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">main_vertex_list</span><span class="p">)</span>
            <span class="c1"># again loop over all the vertexes, sort the neighboring vertexes</span>
            <span class="k">for</span> <span class="n">vi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_p</span><span class="p">):</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">indptr</span><span class="p">[</span><span class="n">vi</span><span class="p">]</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">indptr</span><span class="p">[</span><span class="n">vi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">inds</span> <span class="o">=</span> <span class="n">other_vertex</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
                <span class="n">vecs</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:,</span> <span class="n">inds</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="p">[:,</span> <span class="n">vi</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

                <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">vecs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">sort_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
                <span class="n">other_vertex</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[</span><span class="n">sort_ind</span><span class="p">]</span>

            <span class="c1"># Shift the vertexes to find pairs of neighboring edges</span>
            <span class="n">other_vertex_shifted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">other_vertex</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">other_vertex_shifted</span><span class="p">[</span><span class="n">indptr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">other_vertex</span><span class="p">[</span><span class="n">indptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

            <span class="n">edge_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">main_vertex</span><span class="p">,</span> <span class="n">other_vertex</span><span class="p">,</span> <span class="n">other_vertex_shifted</span><span class="p">])</span>

            <span class="c1"># Find angles between all edge pairs.</span>
            <span class="n">vec_1</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="n">edge_pairs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">p</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="n">edge_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">vec_2</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="n">edge_pairs</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">-</span> <span class="n">p</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="n">edge_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">len_vec_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">vec_1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">len_vec_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">vec_2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="c1"># The use of arccos will give an angle in (0, pi), that is, the</span>
            <span class="c1"># inner angle between the edge pairs (we know the pair is part of</span>
            <span class="c1"># a triangle).</span>
            <span class="n">pair_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vec_1</span> <span class="o">*</span> <span class="n">vec_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">len_vec_1</span> <span class="o">*</span> <span class="n">len_vec_2</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Helper function to combine edges (prepare for merge of the neighboring</span>
            <span class="c1"># edge pairs in both ends of the edge). Also compute angle in the</span>
            <span class="c1"># candidate new pair.</span>
            <span class="k">def</span> <span class="nf">new_pairs_and_angles</span><span class="p">(</span><span class="n">ei</span><span class="p">):</span>
                <span class="n">old_pairs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">new_pairs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">new_angles</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">[:,</span> <span class="n">ei</span><span class="p">]:</span>
                    <span class="n">loc_pair_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">edge_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">e</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">loc_pairs</span> <span class="o">=</span> <span class="n">edge_pairs</span><span class="p">[:,</span> <span class="n">loc_pair_ind</span><span class="p">]</span>

                    <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">edges</span><span class="p">[:,</span> <span class="n">ei</span><span class="p">],</span> <span class="n">e</span><span class="p">)</span>
                    <span class="n">hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">loc_pairs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">other</span><span class="p">,</span> <span class="n">loc_pairs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>
                    <span class="n">new_pair</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">e</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">loc_pairs</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="n">hit</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">other</span><span class="p">)]</span>
                    <span class="p">)</span>
                    <span class="n">new_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pair</span><span class="p">)</span>
                    <span class="n">old_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loc_pair_ind</span><span class="p">[</span><span class="n">hit</span><span class="p">])</span>
                    <span class="n">new_angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pair_angles</span><span class="p">[</span><span class="n">loc_pair_ind</span><span class="p">[</span><span class="n">hit</span><span class="p">]]))</span>

                <span class="n">new_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">new_pairs</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
                <span class="k">return</span> <span class="n">old_pairs</span><span class="p">,</span> <span class="n">new_pairs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_angles</span><span class="p">)</span>

            <span class="n">removed_edges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Loop over all free edges, try to merge them. The loop order will</span>
            <span class="c1"># impact the quality, but attempts to do a sophisticated ordering</span>
            <span class="c1"># failed spectacularly, so we loop by edge ordering.</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">free_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="n">ind</span> <span class="o">=</span> <span class="n">free_edges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># Get information about the perspective new edge pairs</span>
                <span class="n">old_pair_ind</span><span class="p">,</span> <span class="n">new_pairs</span><span class="p">,</span> <span class="n">new_angles</span> <span class="o">=</span> <span class="n">new_pairs_and_angles</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                <span class="c1"># if the resulting pairs both are consistent with a convex</span>
                <span class="c1"># polygon, do the merge.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">new_angles</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
                    <span class="n">edge_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">edge_pairs</span><span class="p">,</span> <span class="n">old_pair_ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">pair_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">pair_angles</span><span class="p">,</span> <span class="n">old_pair_ind</span><span class="p">)</span>
                    <span class="n">edge_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">edge_pairs</span><span class="p">,</span> <span class="n">new_pairs</span><span class="p">))</span>
                    <span class="n">pair_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">pair_angles</span><span class="p">,</span> <span class="n">new_angles</span><span class="p">))</span>
                    <span class="c1"># Take note that this edge should be removed from the triangulation.</span>
                    <span class="n">removed_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

            <span class="c1"># Identify which triangles to merge by forming a graph of the edges to</span>
            <span class="c1"># remove, and then loop over connected subgraphs.</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

            <span class="c1"># First add individual triangles to the graph</span>
            <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">triangles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span>
            <span class="c1"># Next connections between the triangles corresponding to removed edges.</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">removed_edges</span><span class="p">:</span>
                <span class="n">tri_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                            <span class="n">triangles</span> <span class="o">==</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">e</span><span class="p">],</span> <span class="n">triangles</span> <span class="o">==</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="o">==</span> <span class="mi">2</span>
                <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">tri_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tri_ind</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
                <span class="c1"># Extract subgraph of this cluster</span>
                <span class="n">sg</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>
                <span class="n">tris</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
                <span class="c1"># The node indices are given in a cyclic ordering (CW or CCW),</span>
                <span class="c1"># thus a linear ordering should be fine also for a subpolygon.</span>
                <span class="n">verts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">triangles</span><span class="p">[</span><span class="n">tris</span><span class="p">])</span>
                <span class="c1"># To be sure, check the convexity of the polygon.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">PlaneFracture</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span> <span class="n">verts</span><span class="p">],</span> <span class="n">check_convexity</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                <span class="n">ind_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">ind_map</span><span class="p">,</span> <span class="n">fi</span><span class="p">))</span>

            <span class="c1"># Finally, increase pointer to ind_map array</span>
            <span class="n">current_ind_map</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Delete fractures that have all points outside the bounding box</span>
        <span class="c1"># There may be some uncovered cases here, with a fracture barely</span>
        <span class="c1"># touching the box from the outside, but we leave that for now.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">delete_frac</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">ind_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ind_map</span><span class="p">,</span> <span class="n">delete_from_ind_map</span><span class="p">)</span>

        <span class="c1"># Final sanity check: All fractures should have at least three</span>
        <span class="c1"># points at the end of the manipulations</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span>

        <span class="n">boundary_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;boundary&quot;</span><span class="p">,</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">keep_box</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pnt</span> <span class="ow">in</span> <span class="n">polyhedron</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">PlaneFracture</span><span class="p">(</span><span class="n">pnt</span><span class="p">))</span>
                <span class="n">boundary_tags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s2">&quot;boundary&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary_tags</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_fractures</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ind_map</span></div>

    <span class="k">def</span> <span class="nf">_classify_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon_edges</span><span class="p">,</span> <span class="n">constraints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classify the edges into fracture boundary, intersection, or auxiliary.</span>
<span class="sd">        Also identify points on intersections between intersections (fractures</span>
<span class="sd">        of co-dimension 3)</span>

<span class="sd">        Parameters:</span>
<span class="sd">            polygon_edges (list of lists): For each polygon the global edge</span>
<span class="sd">                indices that forms the polygon boundary.</span>
<span class="sd">            constraints (list or np.array): Which polygons are constraints, and should</span>
<span class="sd">                not cause the generation of 1d grids.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tag: Tag of the edges, using the values in GmshConstants. Note</span>
<span class="sd">                that auxiliary points will not be tagged (these are also</span>
<span class="sd">                ignored in gmsh_interface.GmshWriter).</span>
<span class="sd">            np.array, boolean: True for edges which are internal to at least one</span>
<span class="sd">                polygon.</span>
<span class="sd">            np.array, boolean: True for edges that are internal to at least one polygon,</span>
<span class="sd">                and on the boundary of another polygon.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;edges&quot;</span><span class="p">]</span>
        <span class="n">is_bound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;is_bound&quot;</span><span class="p">]</span>
        <span class="n">num_edges</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">poly_2_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;polygons&quot;</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;polygon_frac&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">poly_2_frac</span>

        <span class="c1"># Construct a map from edges to polygons</span>
        <span class="n">edge_2_poly</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_edges</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">pi</span><span class="p">,</span> <span class="n">poly</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polygon_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">poly</span><span class="p">):</span>
                <span class="n">edge_2_poly</span><span class="p">[</span><span class="n">ei</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly_2_frac</span><span class="p">[</span><span class="n">pi</span><span class="p">])</span>

        <span class="c1"># Count the number of referrals to the edge from different polygons</span>
        <span class="c1"># Only do this if the polygon is not a constraint</span>
        <span class="n">num_referrals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_edges</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="n">ep</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edge_2_poly</span><span class="p">):</span>
            <span class="n">ep_not_constraint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">constraints</span><span class="p">)</span>
            <span class="n">num_referrals</span><span class="p">[</span><span class="n">ei</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ep_not_constraint</span><span class="p">)</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># A 1-d grid will be inserted where there is more than one fracture</span>
        <span class="c1"># referring.</span>
        <span class="n">has_1d_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">num_referrals</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">num_is_bound</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">is_bound</span><span class="p">)</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_edges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="c1"># Find edges that are tagged as a boundary of all its fractures</span>
        <span class="n">all_bound</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">is_bound</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_is_bound</span><span class="p">)]</span>

        <span class="c1"># We also need to find edges that are on the boundary of some, but not all</span>
        <span class="c1"># the fractures</span>
        <span class="n">any_bound</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">is_bound</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_is_bound</span><span class="p">)]</span>
        <span class="n">some_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">any_bound</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">all_bound</span><span class="p">))</span>

        <span class="n">bound_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">all_bound</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Remove boundary  that are referred to by more than fracture - this takes</span>
        <span class="c1"># care of L-type intersections</span>
        <span class="n">bound_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">bound_ind</span><span class="p">,</span> <span class="n">has_1d_grid</span><span class="p">)</span>

        <span class="c1"># Index of lines that should have a 1-d grid. This are all of the first</span>
        <span class="c1"># num-constraints, minus those on the boundary.</span>
        <span class="c1"># Note that edges with index &gt; num_is_bound are known to be of the</span>
        <span class="c1"># auxiliary type. These will have tag zero; and treated in a special</span>
        <span class="c1"># manner by the interface to gmsh.</span>
        <span class="n">not_boundary_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_is_bound</span><span class="p">),</span> <span class="n">bound_ind</span><span class="p">)</span>
        <span class="n">tag</span><span class="p">[</span><span class="n">bound_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">FRACTURE_TIP</span><span class="o">.</span><span class="n">value</span>

        <span class="n">tag</span><span class="p">[</span><span class="n">not_boundary_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">FRACTURE_INTERSECTION_LINE</span><span class="o">.</span><span class="n">value</span>

        <span class="k">return</span> <span class="n">tag</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">all_bound</span><span class="p">),</span> <span class="n">some_bound</span>

    <span class="k">def</span> <span class="nf">_on_domain_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">edge_tags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds edges and points on boundary, to avoid that these</span>
<span class="sd">        are gridded.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.array: For all points in the decomposition, the value is 0 if the point is</span>
<span class="sd">                in the interior, constants.FRACTURE_TAG if the point is on a fracture</span>
<span class="sd">                that extends to the boundary, and constants.DOMAIN_BOUNDARY_TAG if the</span>
<span class="sd">                point is part of the boundary specification.</span>
<span class="sd">            np.array: For all edges in the decomposition, tags identifying the edge</span>
<span class="sd">                as on a fracture or boundary.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Obtain current tags on fractures</span>
        <span class="n">boundary_polygons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;boundary&quot;</span><span class="p">,</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">))</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># ... on the points...</span>
        <span class="n">point_tags</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">NEUTRAL</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;points&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
        <span class="p">)</span>
        <span class="c1"># and the mapping between fractures and edges.</span>
        <span class="n">edges_2_frac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;edges_2_frac&quot;</span><span class="p">]</span>

        <span class="c1"># Loop over edges, and the polygons to which the edge belongs</span>
        <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">e2f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges_2_frac</span><span class="p">):</span>

            <span class="c1"># Check if the polygons are on the boundary</span>
            <span class="n">edge_of_domain_boundary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">e2f</span><span class="p">,</span> <span class="n">boundary_polygons</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">edge_of_domain_boundary</span><span class="p">):</span>
                <span class="c1"># If all associated polygons are boundary, this is simple</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">edge_of_domain_boundary</span><span class="p">):</span>
                    <span class="c1"># The point is not associated with a fracture extending to the</span>
                    <span class="c1"># boundary</span>
                    <span class="n">edge_tags</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">DOMAIN_BOUNDARY_LINE</span><span class="o">.</span><span class="n">value</span>
                    <span class="c1"># The points of this edge are also associated with the boundary</span>
                    <span class="n">point_tags</span><span class="p">[</span>
                        <span class="n">edges</span><span class="p">[:,</span> <span class="n">e</span><span class="p">]</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">DOMAIN_BOUNDARY_POINT</span><span class="o">.</span><span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># The edge is associated with at least one fracture. Still, if it is</span>
                    <span class="c1"># also the edge of at least one boundary point, we will consider it</span>
                    <span class="c1"># a domain boundary edge</span>
                    <span class="n">on_one_domain_edge</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">edge_of_domain_boundary</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;line_in_frac&quot;</span><span class="p">][</span><span class="n">e2f</span><span class="p">[</span><span class="n">pi</span><span class="p">]]:</span>
                            <span class="n">on_one_domain_edge</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>

                    <span class="c1"># The line is on the boundary</span>
                    <span class="k">if</span> <span class="n">on_one_domain_edge</span><span class="p">:</span>
                        <span class="n">edge_tags</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">DOMAIN_BOUNDARY_LINE</span><span class="o">.</span><span class="n">value</span>
                        <span class="n">point_tags</span><span class="p">[</span>
                            <span class="n">edges</span><span class="p">[:,</span> <span class="n">e</span><span class="p">]</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">DOMAIN_BOUNDARY_POINT</span><span class="o">.</span><span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># The edge is an intersection between a fracture and a boundary</span>
                        <span class="c1"># polygon</span>
                        <span class="n">edge_tags</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">FRACTURE_BOUNDARY_LINE</span><span class="o">.</span><span class="n">value</span>
                        <span class="n">point_tags</span><span class="p">[</span>
                            <span class="n">edges</span><span class="p">[:,</span> <span class="n">e</span><span class="p">]</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">FRACTURE_BOUNDARY_POINT</span><span class="o">.</span><span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This is not an edge on the domain boundary, and the tag assigned in</span>
                <span class="c1"># in self._classify_edges() is still valid: It is either a fracture tip</span>
                <span class="c1"># or a fracture intersection line</span>
                <span class="c1"># The point tag is still neutral; it may be adjusted later depending on</span>
                <span class="c1"># how many intersection lines refer to the point</span>
                <span class="k">continue</span>

        <span class="k">return</span> <span class="n">point_tags</span><span class="p">,</span> <span class="n">edge_tags</span>

    <span class="k">def</span> <span class="nf">_poly_2_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Represent the polygons by the global edges, and determine if the lines</span>
<span class="sd">        must be reversed (locally) for the polygon to form a closed loop.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list of np.array: Each list item gives the indices of the edges need to</span>
<span class="sd">                form a polygon (fracture, boundary) in the decomposition.</span>
<span class="sd">            list of np.array: For each polygon, and each edge of the polygon, True if</span>
<span class="sd">                the edge must be reversed (relative to its description in</span>
<span class="sd">                self.decomposition[&#39;edges&#39;]).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;edges&quot;</span><span class="p">]</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;polygons&quot;</span><span class="p">]</span>

        <span class="n">poly_2_line</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">line_reverse</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">poly</span><span class="p">:</span>
            <span class="n">hit</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">setmembership</span><span class="o">.</span><span class="n">ismember_rows</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">edges</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">hit_reverse</span><span class="p">,</span> <span class="n">ind_reverse</span> <span class="o">=</span> <span class="n">setmembership</span><span class="o">.</span><span class="n">ismember_rows</span><span class="p">(</span>
                <span class="n">p</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">hit</span> <span class="o">+</span> <span class="n">hit_reverse</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">line_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">hit_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">hit</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">hit_reverse_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">hit_reverse</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">line_ind</span><span class="p">[</span><span class="n">hit_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span>
            <span class="n">line_ind</span><span class="p">[</span><span class="n">hit_reverse_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind_reverse</span>

            <span class="n">poly_2_line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line_ind</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">))</span>
            <span class="n">line_reverse</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hit_reverse</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">poly_2_line</span><span class="p">,</span> <span class="n">line_reverse</span>

    <span class="k">def</span> <span class="nf">_determine_mesh_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point_tags</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the preferred mesh size for geometrical points as specified by</span>
<span class="sd">        gmsh.</span>

<span class="sd">        Currently, the only option supported is to specify a single value for</span>
<span class="sd">        all fracture points, and one value for the boundary.</span>

<span class="sd">        See the gmsh manual for further details.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">num_pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;points&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_min</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_frac</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found no information on mesh sizes. Returning&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="s2">&quot;points&quot;</span><span class="p">]</span>
        <span class="n">num_pts</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Compute distance between the points forming the network</span>
        <span class="c1"># This will also account for points close to segments on other fractures, as</span>
        <span class="c1"># an auxiliary point will already have been inserted there</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">pointset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">max_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">point_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Minimal distance between points encountered is &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="c1"># The mesh size should not be smaller than the prescribed minimum distance</span>
        <span class="n">mesh_size_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">point_dist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_min</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_pts</span><span class="p">))</span>
        <span class="c1"># The mesh size should not be larger than the prescribed fracture mesh size.</span>
        <span class="c1"># If the boundary mesh size is also presribed, that will be enforced below.</span>
        <span class="n">mesh_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">mesh_size_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_frac</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_pts</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">on_boundary</span> <span class="o">=</span> <span class="n">point_tags</span> <span class="o">==</span> <span class="n">GmshInterfaceTags</span><span class="o">.</span><span class="n">DOMAIN_BOUNDARY_POINT</span><span class="o">.</span><span class="n">value</span>
            <span class="n">mesh_size_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
                <span class="n">mesh_size_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_bound</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_pts</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">mesh_size</span><span class="p">[</span><span class="n">on_boundary</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">mesh_size</span><span class="p">,</span> <span class="n">mesh_size_bound</span><span class="p">)[</span><span class="n">on_boundary</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">mesh_size</span>

    <span class="k">def</span> <span class="nf">_insert_auxiliary_points</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mesh_size_frac</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mesh_size_min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mesh_size_bound</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Insert auxiliary points on fracture edges. Used to guide gmsh mesh</span>
<span class="sd">        size parameters.</span>

<span class="sd">        The function should only be called once to avoid insertion of multiple</span>
<span class="sd">        layers of extra points, this will likely kill gmsh.</span>

<span class="sd">        The function is motivated by similar functionality for 2d domains, but</span>
<span class="sd">        is considerably less mature.</span>

<span class="sd">        The function should be used in conjunction with _determine_mesh_size().</span>
<span class="sd">        The ultimate goal is to set the mesh size</span>
<span class="sd">        for geometrical points in Gmsh. To that end, this function inserts</span>
<span class="sd">        additional points on the fracture boundaries. The mesh size is then</span>
<span class="sd">        determined as the distance between all points in the fracture</span>
<span class="sd">        description.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            mesh_size_frac: Ideal mesh size. Will be added to all points that</span>
<span class="sd">                are sufficiently far away from other points.</span>
<span class="sd">            mesh_size_min: Minimal mesh size; we will make no attempts to</span>
<span class="sd">                enforce even smaller mesh sizes upon Gmsh.</span>
<span class="sd">            mesh_size_bound (optional): Boundary mesh size. Will be added to the points</span>

<span class="sd">                defining the boundary, unless there are any fractures in the</span>
<span class="sd">                immediate vicinity influencing the size. In other words,</span>
<span class="sd">                mesh_size_bound is the boundary point equivalent of</span>
<span class="sd">                mesh_size_frac.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">auxiliary_points_added</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Auxiliary points already added. Returning.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">auxiliary_points_added</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_frac</span> <span class="o">=</span> <span class="n">mesh_size_frac</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_min</span> <span class="o">=</span> <span class="n">mesh_size_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_size_bound</span> <span class="o">=</span> <span class="n">mesh_size_bound</span>

        <span class="c1"># Auxiliary points may be added for two reasons: For fractures that do intersect</span>
        <span class="c1"># the points are added on the segments on the fracture boundaries, close to the</span>
        <span class="c1"># endpoints of the intersection segments. This is tailored to the way gmsh</span>
        <span class="c1"># creates grids, with meshing of 1d lines before 2d surfaces.</span>
        <span class="c1"># For non-intersecting fractures, auxiliary points may be added on the fracture</span>
        <span class="c1"># segments if they are sufficiently close.</span>

        <span class="c1"># FIXME: If a fracture is close to the interior of another fracture, this</span>
        <span class="c1"># will not be seen by the current algorithm. The solution should be to add</span>
        <span class="c1"># points to the fracture surface, but make sure that this is not decleared</span>
        <span class="c1"># physical. The operation should only be done for fracture pairs where no</span>
        <span class="c1"># auxiliary points were added because of close segments.</span>

        <span class="k">def</span> <span class="nf">dist_p</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="c1"># Helper function to get the distance from a set of points (a) to a single point</span>
            <span class="c1"># (b).</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

        <span class="c1"># Dictionary that for each fracture maps the index of all other fractures.</span>
        <span class="n">intersecting_fracs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Loop over all fractures</span>
        <span class="k">for</span> <span class="n">fi</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">):</span>

            <span class="c1"># Do not insert auxiliary points on domain boundaries</span>
            <span class="k">if</span> <span class="s2">&quot;boundary&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s2">&quot;boundary&quot;</span><span class="p">][</span><span class="n">fi</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="c1"># First compare segments with intersections to this fracture</span>
            <span class="n">nfp</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Keep track of which other fractures are intersecting - will be</span>
            <span class="c1"># needed later on</span>
            <span class="n">intersections_this_fracture</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Loop over all intersections of the fracture</span>
            <span class="n">isects</span><span class="p">,</span> <span class="n">is_first_isect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections_of_fracture</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">is_first</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">isects</span><span class="p">,</span> <span class="n">is_first_isect</span><span class="p">):</span>

                <span class="c1"># Register this intersection</span>
                <span class="k">if</span> <span class="n">is_first</span><span class="p">:</span>
                    <span class="n">intersections_this_fracture</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;second&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">intersections_this_fracture</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;first&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
                    <span class="p">)</span>

                <span class="c1"># Find the point on the fracture segments that is closest to the</span>
                <span class="c1"># intersection point.</span>
                <span class="c1"># Note the use of vstack, combined with a transpose.</span>
                <span class="n">isect_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">][:,</span> <span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">][:,</span> <span class="n">i</span><span class="p">])</span>
                <span class="p">)</span><span class="o">.</span><span class="n">T</span>

                <span class="n">dist</span><span class="p">,</span> <span class="n">cp</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">points_segments</span><span class="p">(</span>
                    <span class="n">isect_coord</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="c1"># Insert a (candidate) point only at the segment closest to the</span>
                <span class="c1"># intersection point. If the intersection line runs parallel</span>
                <span class="c1"># with a segment, this may be insufficient, but we will deal</span>
                <span class="c1"># with this if it turns out to be a problem.</span>
                <span class="n">closest_segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">min_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">closest_segment</span><span class="p">]</span>

                <span class="c1"># Sort the points on increasing point indices. This makes it easier to keep</span>
                <span class="c1"># track of where any new point should be added (variable inserted_points</span>
                <span class="c1"># below).</span>
                <span class="n">sort_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">closest_segment</span><span class="p">)</span>
                <span class="n">closest_segment</span> <span class="o">=</span> <span class="n">closest_segment</span><span class="p">[</span><span class="n">sort_ind</span><span class="p">]</span>
                <span class="n">min_dist</span> <span class="o">=</span> <span class="n">min_dist</span><span class="p">[</span><span class="n">sort_ind</span><span class="p">]</span>

                <span class="n">inserted_points</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">for</span> <span class="n">pi</span><span class="p">,</span> <span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">di</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">closest_segment</span><span class="p">,</span> <span class="n">min_dist</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">di</span> <span class="o">&lt;</span> <span class="n">mesh_size_frac</span> <span class="ow">and</span> <span class="n">di</span> <span class="o">&gt;</span> <span class="n">mesh_size_min</span><span class="p">:</span>
                        <span class="c1"># Distance between the closest point of the intersection segment</span>
                        <span class="c1"># and the points of this fracture.</span>
                        <span class="n">d_1</span> <span class="o">=</span> <span class="n">dist_p</span><span class="p">(</span><span class="n">cp</span><span class="p">[</span><span class="n">pi</span><span class="p">,</span> <span class="n">si</span><span class="p">],</span> <span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span> <span class="n">si</span><span class="p">])</span>
                        <span class="n">d_2</span> <span class="o">=</span> <span class="n">dist_p</span><span class="p">(</span><span class="n">cp</span><span class="p">[</span><span class="n">pi</span><span class="p">,</span> <span class="n">si</span><span class="p">],</span> <span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span> <span class="p">(</span><span class="n">si</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">nfp</span><span class="p">])</span>
                        <span class="c1"># If the intersection point is not very close to any of</span>
                        <span class="c1"># the points on the segment, we split the segment.</span>
                        <span class="c1"># NB: It is critical that this is done before a call to</span>
                        <span class="c1"># self.split_intersections(), or else the export to gmsh</span>
                        <span class="c1"># will go wrong.</span>
                        <span class="k">if</span> <span class="n">d_1</span> <span class="o">&gt;</span> <span class="n">mesh_size_min</span> <span class="ow">and</span> <span class="n">d_2</span> <span class="o">&gt;</span> <span class="n">mesh_size_min</span><span class="p">:</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="p">,</span>
                                <span class="p">(</span><span class="n">si</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">inserted_points</span><span class="p">)</span> <span class="o">%</span> <span class="n">nfp</span><span class="p">,</span>
                                <span class="n">cp</span><span class="p">[</span><span class="n">pi</span><span class="p">,</span> <span class="n">si</span><span class="p">],</span>
                                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                            <span class="p">)</span>

                            <span class="n">inserted_points</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">nfp</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="c1"># Check if some of the intersections of the fracture should</span>
                            <span class="c1"># be split when the new point is added.</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_split_intersections_of_fracture</span><span class="p">(</span><span class="n">cp</span><span class="p">[</span><span class="n">pi</span><span class="p">,</span> <span class="n">si</span><span class="p">])</span>

            <span class="c1"># Take note of the intersecting fractures</span>
            <span class="n">intersecting_fracs</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="o">=</span> <span class="n">intersections_this_fracture</span>

        <span class="c1"># Next, insert points along segments that are close to other fractures,</span>
        <span class="c1"># which are not touching. The insertion is not symmetric, so that when</span>
        <span class="c1"># a point is inserted on one fracture, it is not inserted on the close</span>
        <span class="c1"># fracture which triggered the insertion (the corresponding point on the</span>
        <span class="c1"># second fracture may be inserted on later).</span>

        <span class="c1"># Precompute rolling of fracture points - this saves a bit of time.</span>
        <span class="n">rolled_fracture_points</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">f</span><span class="o">.</span><span class="n">index</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">fi</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">):</span>

            <span class="c1"># Do not insert auxiliary points on domain boundaries</span>
            <span class="k">if</span> <span class="s2">&quot;boundary&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s2">&quot;boundary&quot;</span><span class="p">][</span><span class="n">fi</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="c1"># Get the segments of all other fractures which do no intersect with</span>
            <span class="c1"># the main one.</span>
            <span class="c1"># First the indices</span>
            <span class="n">other_fractures</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">of</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">of</span><span class="o">.</span><span class="n">index</span> <span class="ow">in</span> <span class="n">intersecting_fracs</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span> <span class="ow">or</span> <span class="n">of</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                    <span class="n">other_fractures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">of</span><span class="p">)</span>

            <span class="c1"># If no other fractures were found, we go on.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_fractures</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Next, arrays of start and end points. This allows us to use the</span>
            <span class="c1"># vectorized segment-segment distance computation.</span>
            <span class="n">start_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">of</span><span class="o">.</span><span class="n">pts</span> <span class="k">for</span> <span class="n">of</span> <span class="ow">in</span> <span class="n">other_fractures</span><span class="p">])</span>
            <span class="n">end_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">[</span><span class="n">rolled_fracture_points</span><span class="p">[</span><span class="n">of</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">of</span> <span class="ow">in</span> <span class="n">other_fractures</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Now, loop over all segments in the main fracture, look for close</span>
            <span class="c1"># segments on other fractures, and insert points along the main</span>
            <span class="c1"># segment if some are close enough. Points may be inserted if the</span>
            <span class="c1"># other fracture is closer than mesh_size_frac, however, the</span>
            <span class="c1"># auxiliary points should not be too dense along the main segment.</span>
            <span class="c1"># Specifically, points are only inserted if the distance form existing</span>
            <span class="c1"># points on the segment (endpoint or auxiliary) is larger than the</span>
            <span class="c1"># minimum distance. This implies that if several other fractures</span>
            <span class="c1"># have nearby closest points along the segment, only some of the</span>
            <span class="c1"># possible auxiliary points wil be inserted, however, the mesh</span>
            <span class="c1"># size in that part of the segment should still be fairly small.</span>

            <span class="c1"># Since the number of points in the fracture description changes by</span>
            <span class="c1"># insertion of auxiliary points, we use a counter and while loop</span>
            <span class="c1"># to loop over the segments.</span>
            <span class="n">start_index</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">while</span> <span class="n">start_index</span> <span class="o">&lt;</span> <span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># Start and end of this segment. These should be vertexes in the</span>
                <span class="c1"># original fracture (prior to insertion of auxiliary points)</span>
                <span class="n">seg_start</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span> <span class="n">start_index</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="c1"># Modulus to finish the final segment of the fracture.</span>
                <span class="n">seg_end</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="p">[:,</span> <span class="p">(</span><span class="n">start_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

                <span class="c1"># Find the distance from this segment to all other segments</span>
                <span class="c1"># (not intersecting).</span>
                <span class="n">dist</span><span class="p">,</span> <span class="n">cp_f</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">segment_segment_set</span><span class="p">(</span>
                    <span class="n">seg_start</span><span class="p">,</span> <span class="n">seg_end</span><span class="p">,</span> <span class="n">start_all</span><span class="p">,</span> <span class="n">end_all</span>
                <span class="p">)</span>

                <span class="c1"># Sort the points according to distances, so that we try to insert</span>
                <span class="c1"># the most needed auxiliary points first</span>
                <span class="n">sort_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">sort_ind</span><span class="p">]</span>
                <span class="n">cp_f</span> <span class="o">=</span> <span class="n">cp_f</span><span class="p">[:,</span> <span class="n">sort_ind</span><span class="p">]</span>

                <span class="c1"># Chances are, many of the other segments will be closest to an end</span>
                <span class="c1"># of this segment. These can be disregarded (below).</span>
                <span class="n">dist_segment_ends</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
                    <span class="n">dist_p</span><span class="p">(</span><span class="n">cp_f</span><span class="p">,</span> <span class="n">seg_start</span><span class="p">),</span> <span class="n">dist_p</span><span class="p">(</span><span class="n">cp_f</span><span class="p">,</span> <span class="n">seg_end</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">not_closest_on_ends</span> <span class="o">=</span> <span class="n">dist_segment_ends</span> <span class="o">&gt;</span> <span class="n">mesh_size_min</span>

                <span class="c1"># Also cut all points corresponding to segments that are further</span>
                <span class="c1"># away than the prescribed fracture mesh size</span>
                <span class="n">not_far_away</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">mesh_size_frac</span>

                <span class="n">is_candidate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">not_closest_on_ends</span><span class="p">,</span> <span class="n">not_far_away</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">is_candidate</span><span class="p">):</span>
                    <span class="c1"># If no candidate point was found for this edge, we can move on:</span>
                    <span class="c1"># Increase the start index to hit the next segment along the main</span>
                    <span class="c1"># fracture.</span>
                    <span class="n">start_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># First pick out all condidate auxiliary points, then reduce</span>
                    <span class="c1"># to a unique subset (close candidate points may occur e.g.</span>
                    <span class="c1"># for fractures close to complex domain boundaries.)</span>
                    <span class="n">candidates</span> <span class="o">=</span> <span class="n">cp_f</span><span class="p">[:,</span> <span class="n">is_candidate</span><span class="p">]</span>
                    <span class="p">(</span>
                        <span class="n">unique_candidates</span><span class="p">,</span>
                        <span class="n">_</span><span class="p">,</span>
                        <span class="n">o2n</span><span class="p">,</span>
                    <span class="p">)</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">setmembership</span><span class="o">.</span><span class="n">uniquify_point_set</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span>

                    <span class="c1"># Make arrays for points along the segment (originally the</span>
                    <span class="c1"># endpoints), and for the auxiliary points</span>
                    <span class="n">segment_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">seg_start</span><span class="p">,</span> <span class="n">seg_end</span><span class="p">))</span>
                    <span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

                    <span class="c1"># Loop over all candidate points (due to the sorting on</span>
                    <span class="c1"># distances, the candidates corresponds to increasing distance</span>
                    <span class="c1"># from the nearby fracture).</span>
                    <span class="k">for</span> <span class="n">point_counter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">unique_candidates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">pt</span> <span class="o">=</span> <span class="n">unique_candidates</span><span class="p">[:,</span> <span class="n">point_counter</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

                        <span class="c1"># Insert the candidate point if it is sufficiently far</span>
                        <span class="c1"># away from existing points along the line.</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dist_p</span><span class="p">(</span><span class="n">segment_points</span><span class="p">,</span> <span class="n">pt</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">mesh_size_min</span><span class="p">:</span>
                            <span class="c1"># No sorting of points along the line, take care</span>
                            <span class="c1"># of this below.</span>
                            <span class="n">segment_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">segment_points</span><span class="p">,</span> <span class="n">pt</span><span class="p">))</span>
                            <span class="c1"># Register new point.</span>
                            <span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">new_points</span><span class="p">,</span> <span class="n">pt</span><span class="p">))</span>

                    <span class="c1"># Compute distance between new points and segment start</span>
                    <span class="n">dist_from_start</span> <span class="o">=</span> <span class="n">dist_p</span><span class="p">(</span><span class="n">new_points</span><span class="p">,</span> <span class="n">seg_start</span><span class="p">)</span>

                    <span class="c1"># Sort the new points according to distance. This will make</span>
                    <span class="c1"># the new sub-segments a line along the main segment. Then insert.</span>
                    <span class="n">sorted_new</span> <span class="o">=</span> <span class="n">new_points</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist_from_start</span><span class="p">)]</span>

                    <span class="n">f</span><span class="o">.</span><span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="p">,</span> <span class="p">[</span><span class="n">start_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">sorted_new</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># Update precomputed dict of rolled fracture points</span>
                    <span class="n">rolled_fracture_points</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

                    <span class="c1"># If the new points sit on top of intersections, these must be split</span>
                    <span class="k">for</span> <span class="n">pi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sorted_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_split_intersections_of_fracture</span><span class="p">(</span>
                            <span class="n">sorted_new</span><span class="p">[:,</span> <span class="n">pi</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="p">)</span>

                    <span class="c1"># Move the start index to the next segment, compensating for</span>
                    <span class="c1"># inserted auxiliary points.</span>
                    <span class="n">start_index</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">sorted_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_split_intersections_of_fracture</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cp</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Check if a point lies on intersections of a given fracture, and if so,</span>
<span class="sd">        split the intersection into two.</span>

<span class="sd">        The intended usage is when auxiliary points are added to a fracture&#39;s vertexes</span>
<span class="sd">        after the intersections have been identified.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            cp (np.array, size 3): Coordinate of the added point. The intersection will</span>
<span class="sd">                be split if the point lies on the intersection.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Intersections must be split for all fractures, not only those where the</span>
        <span class="c1"># fracture is involved, or else Y-type intersections may not be treated</span>
        <span class="c1"># correctly.</span>

        <span class="k">if</span> <span class="n">cp</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">cp</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Compute distance from the point to all other points</span>
        <span class="n">isect_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span>
        <span class="n">isect_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]</span>
        <span class="n">d_isect</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">points_segments</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">isect_start</span><span class="p">,</span> <span class="n">isect_end</span><span class="p">)</span>

        <span class="c1"># We are only interested in segments that are  close to the point</span>
        <span class="n">close_to_segment</span> <span class="o">=</span> <span class="n">d_isect</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span>
        <span class="c1"># If there are no close segments, there is nothing more to do.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">close_to_segment</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># If the close point is the endpoint of the intersection segment, we</span>
        <span class="c1"># should not split it</span>
        <span class="n">dist_start</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">point_pointset</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">isect_start</span><span class="p">)</span>
        <span class="n">dist_end</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">point_pointset</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">isect_end</span><span class="p">)</span>
        <span class="n">close_to_endpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">dist_start</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="n">dist_end</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span>

        <span class="c1"># replace intersections that are cut in two pieces, both with non-zero length.</span>
        <span class="n">to_replace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">close_to_segment</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">close_to_endpoint</span><span class="p">))</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">to_replace</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Duplicate intersections, and split into two.</span>
        <span class="n">first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;first&quot;</span><span class="p">][</span><span class="n">to_replace</span><span class="p">]</span>
        <span class="n">second</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;second&quot;</span><span class="p">][</span><span class="n">to_replace</span><span class="p">]</span>

        <span class="n">bound_first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;bound_first&quot;</span><span class="p">][</span><span class="n">to_replace</span><span class="p">]</span>
        <span class="n">bound_second</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;bound_second&quot;</span><span class="p">][</span><span class="n">to_replace</span><span class="p">]</span>

        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">][:,</span> <span class="n">to_replace</span><span class="p">]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">][:,</span> <span class="n">to_replace</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">start</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">new_first</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">new_second</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">new_bound_first</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">bound_first</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">new_bound_second</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">bound_second</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">new_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
        <span class="n">new_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">to_replace</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add_intersection</span><span class="p">(</span>
            <span class="n">new_first</span><span class="p">,</span> <span class="n">new_second</span><span class="p">,</span> <span class="n">new_start</span><span class="p">,</span> <span class="n">new_end</span><span class="p">,</span> <span class="n">new_bound_first</span><span class="p">,</span> <span class="n">new_bound_second</span>
        <span class="p">)</span>
        <span class="c1"># Delete the old intersections.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">to_replace</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_intersection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">first</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PlaneFracture</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">second</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PlaneFracture</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">end</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">bound_first</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">bound_second</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Add one or several fracture pairs to the intersections.</span>
        <span class="c1"># If several fractures, these should be wrapped in a numpy array.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;first&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;first&quot;</span><span class="p">],</span> <span class="n">first</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;second&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;second&quot;</span><span class="p">],</span> <span class="n">second</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">],</span> <span class="n">start</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">],</span> <span class="n">end</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;bound_first&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;bound_first&quot;</span><span class="p">],</span> <span class="n">bound_first</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;bound_second&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="s2">&quot;bound_second&quot;</span><span class="p">],</span> <span class="n">bound_second</span><span class="p">)</span>
        <span class="p">)</span>

<div class="viewcode-block" id="FractureNetwork3d.to_file"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html#porepy.fracs.fracture_network_3d.FractureNetwork3d.to_file">[docs]</a>    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export the fracture network to file.</span>

<span class="sd">        The file format is given as an kwarg, by default vtu will be used. The writing is</span>
<span class="sd">        outsourced to meshio, thus the file format should be supported by that package.</span>

<span class="sd">        The fractures are treated as polygonal cells, with no special treatment</span>
<span class="sd">        of intersections.</span>

<span class="sd">        Fracture numbers are always exported (1-offset). In addition, it is</span>
<span class="sd">        possible to export additional data, as specified by the</span>
<span class="sd">        keyword-argument data.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            file_name (str): Name of the target file.</span>
<span class="sd">            data (dictionary, optional): Data associated with the fractures.</span>
<span class="sd">                The values in the dictionary should be numpy arrays. 1d and 3d</span>
<span class="sd">                data is supported. Fracture numbers are always exported.</span>

<span class="sd">        Optional arguments in kwargs:</span>
<span class="sd">            binary (boolean): Use binary export format. Default to</span>
<span class="sd">                True.</span>
<span class="sd">            fracture_offset (int): Use to define the offset for a</span>
<span class="sd">                fracture id. Default to 1.</span>
<span class="sd">            folder_name (string): Path to save the file. Default to &quot;./&quot;.</span>
<span class="sd">            extension (string): File extension. Default to &quot;.vtu&quot;.</span>

<span class="sd">        See also the functions self.to_fab() and self.to_csv().</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">binary</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;binary&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">fracture_offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;fracture_offset&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">extension</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;extension&quot;</span><span class="p">,</span> <span class="s2">&quot;.vtu&quot;</span><span class="p">)</span>
        <span class="n">folder_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;folder_name&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Got unexpected keyword argument &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">popitem</span><span class="p">()[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">file_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">extension</span><span class="p">):</span>
            <span class="n">file_name</span> <span class="o">+=</span> <span class="n">extension</span>

        <span class="c1"># fracture points</span>
        <span class="n">meshio_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1"># counter for the points</span>
        <span class="n">pts_pos</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Data structure for cells in meshio format.</span>
        <span class="n">meshio_cells</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># we operate fracture by fracture</span>
        <span class="k">for</span> <span class="n">fid</span><span class="p">,</span> <span class="n">frac</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">):</span>
            <span class="c1"># In old meshio, polygonal cells are distinguished based on the</span>
            <span class="c1"># number of vertexes.</span>
            <span class="c1"># save the points of the fracture</span>
            <span class="n">meshio_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">meshio_pts</span><span class="p">,</span> <span class="n">frac</span><span class="o">.</span><span class="n">pts</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
            <span class="n">num_pts</span> <span class="o">=</span> <span class="n">frac</span><span class="o">.</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Always represent the fracture as a polygon</span>
            <span class="n">cell_type</span> <span class="o">=</span> <span class="s2">&quot;polygon&quot;</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">pts_pos</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_pts</span><span class="p">)</span>
            <span class="n">pts_pos</span> <span class="o">+=</span> <span class="n">num_pts</span>

            <span class="c1"># In newer versions of meshio, make a list of 2-tuples with</span>
            <span class="c1"># (cell_type, list(node_numbers))</span>
            <span class="n">meshio_cells</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cell_type</span><span class="p">,</span> <span class="p">[</span><span class="n">nodes</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]))</span>

        <span class="c1"># The older version of meshio requires more post processing to work.</span>
        <span class="c1"># Cell data also requires different formats.</span>

        <span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;fracture_number&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="p">[</span><span class="n">fracture_offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">))</span>
                <span class="p">]</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="c1"># The data is simply the data</span>
        <span class="n">meshio_data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="n">meshio_grid_to_export</span> <span class="o">=</span> <span class="n">meshio</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span>
            <span class="n">meshio_pts</span><span class="p">,</span> <span class="n">meshio_cells</span><span class="p">,</span> <span class="n">cell_data</span><span class="o">=</span><span class="n">meshio_data</span>
        <span class="p">)</span>
        <span class="n">meshio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">folder_name</span> <span class="o">+</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">meshio_grid_to_export</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="n">binary</span><span class="p">)</span></div>

<div class="viewcode-block" id="FractureNetwork3d.to_csv"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html#porepy.fracs.fracture_network_3d.FractureNetwork3d.to_csv">[docs]</a>    <span class="k">def</span> <span class="nf">to_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the 3d network on a csv file with comma , as separator.</span>
<span class="sd">        Note: the file is overwritten if present.</span>
<span class="sd">        The format is</span>
<span class="sd">        - if domain is given the first line describes the domain as a rectangle</span>
<span class="sd">          X_MIN, Y_MIN, Z_MIN, X_MAX, Y_MAX, Z_MAX</span>
<span class="sd">        - the other lines describe the N fractures as a list of points</span>
<span class="sd">          P0_X, P0_Y, P0_Z, ...,PN_X, PN_Y, PN_Z</span>

<span class="sd">        Parameters:</span>
<span class="sd">            file_name: name of the file</span>
<span class="sd">            domain: (optional) the bounding box of the problem</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">csv_file</span><span class="p">:</span>
            <span class="n">csv_writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>

            <span class="c1"># if the domain (as bounding box) is defined save it</span>
            <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;xmin&quot;</span><span class="p">,</span> <span class="s2">&quot;ymin&quot;</span><span class="p">,</span> <span class="s2">&quot;zmin&quot;</span><span class="p">,</span> <span class="s2">&quot;xmax&quot;</span><span class="p">,</span> <span class="s2">&quot;ymax&quot;</span><span class="p">,</span> <span class="s2">&quot;zmax&quot;</span><span class="p">]</span>
                <span class="n">csv_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">domain</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">order</span><span class="p">])</span>

            <span class="c1"># write all the fractures</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">:</span>
                <span class="n">csv_writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">pts</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">))</span></div>

<div class="viewcode-block" id="FractureNetwork3d.to_fab"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html#porepy.fracs.fracture_network_3d.FractureNetwork3d.to_fab">[docs]</a>    <span class="k">def</span> <span class="nf">to_fab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the 3d network on a fab file, as specified by FracMan.</span>

<span class="sd">        The filter is based on the .fab-files needed at the time of writing, and</span>
<span class="sd">        may not cover all options available.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            file_name (str): File name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># function to write a numpy matrix as string</span>

        <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n\t\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="c1"># write the first part of the file, some information are fake</span>
            <span class="n">num_frac</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">)</span>
            <span class="n">num_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">frac</span><span class="o">.</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">frac</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">])</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;BEGIN FORMAT</span><span class="se">\n\t</span><span class="s2">Format = Ascii</span><span class="se">\n\t</span><span class="s2">XAxis = East</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Scale = 100.0</span><span class="se">\n\t</span><span class="s2">No_Fractures = &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_frac</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">No_TessFractures = 0</span><span class="se">\n\t</span><span class="s2">No_Nodes = &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">No_Properties = 0</span><span class="se">\n</span><span class="s2">END FORMAT</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="c1"># start to write the fractures</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;BEGIN FRACTURE</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">frac_pos</span><span class="p">,</span> <span class="n">frac</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">frac_pos</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">frac</span><span class="o">.</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; 1</span><span class="se">\n\t\t</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">frac</span><span class="o">.</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">frac</span><span class="o">.</span><span class="n">pts</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">to_file</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">0 -1 -1 -1</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;END FRACTURE&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="FractureNetwork3d.fracture_to_plane"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html#porepy.fracs.fracture_network_3d.FractureNetwork3d.fracture_to_plane">[docs]</a>    <span class="k">def</span> <span class="nf">fracture_to_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frac_num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Project fracture vertexes and intersection points to the natural</span>
<span class="sd">        plane of the fracture.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            frac_num (int): Index of fracture.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray (2xn_pt): 2d coordinates of the fracture vertexes.</span>
<span class="sd">            np.ndarray (2xn_isect): 2d coordinates of fracture intersection</span>
<span class="sd">                points.</span>
<span class="sd">            np.ndarray: Index of intersecting fractures.</span>
<span class="sd">            np.ndarray, 3x3: Rotation matrix into the natural plane.</span>
<span class="sd">            np.ndarray, 3x1. 3d coordinates of the fracture center.</span>

<span class="sd">            The 3d coordinates of the fracture can be recovered by</span>
<span class="sd">                p_3d = cp + rot.T.dot(np.vstack((p_2d,</span>
<span class="sd">                                                 np.zeros(p_2d.shape[1]))))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">isect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections_of_fracture</span><span class="p">(</span><span class="n">frac_num</span><span class="p">)</span>

        <span class="n">frac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fractures</span><span class="p">[</span><span class="n">frac_num</span><span class="p">]</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="n">frac</span><span class="o">.</span><span class="n">center</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">rot</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">map_geometry</span><span class="o">.</span><span class="n">project_plane_matrix</span><span class="p">(</span><span class="n">frac</span><span class="o">.</span><span class="n">pts</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">rot_translate</span><span class="p">(</span><span class="n">pts</span><span class="p">):</span>
            <span class="c1"># Convenience method to translate and rotate a point.</span>
            <span class="k">return</span> <span class="n">rot</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pts</span> <span class="o">-</span> <span class="n">cp</span><span class="p">)</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">rot_translate</span><span class="p">(</span><span class="n">frac</span><span class="o">.</span><span class="n">pts</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span> <span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">p_2d</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Intersection points, in 2d coordinates</span>
        <span class="n">ip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="n">other_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">isect</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">frac_num</span><span class="p">:</span>
                <span class="n">other_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other_frac</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other_frac</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

            <span class="n">tmp_p</span> <span class="o">=</span> <span class="n">rot_translate</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tmp_p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tmp_p</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span>
                <span class="n">ip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">tmp_p</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">p_2d</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">other_frac</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">cp</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022 UiB Center for Modeling of Coupled Subsurface Dynamics, GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007..</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>