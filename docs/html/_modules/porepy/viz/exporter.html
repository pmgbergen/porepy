<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>porepy.viz.exporter &mdash; PorePy 1.6.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="canonical" href="https://pmgbergen.github.io/porepy/_modules/porepy/viz/exporter.html" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >
            <a href="../../../index.html" class="icon icon-home"> PorePy
          </a>
              <div class="version">
                1.6.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docsrc/howto/howto-docstring.html">1. How-To docstring</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docsrc/porepy/modules.html">porepy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.html">porepy package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.html">porepy.fracs package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture.html">porepy.fracs.fracture module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_importer.html">porepy.fracs.fracture_importer module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_network_2d.html">porepy.fracs.fracture_network_2d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html">porepy.fracs.fracture_network_3d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.gmsh_interface.html">porepy.fracs.gmsh_interface module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.line_fracture.html">porepy.fracs.line_fracture module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.meshing.html">porepy.fracs.meshing module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.msh_2_grid.html">porepy.fracs.msh_2_grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.non_conforming.html">porepy.fracs.non_conforming module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.plane_fracture.html">porepy.fracs.plane_fracture module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.simplex.html">porepy.fracs.simplex module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.split_grid.html">porepy.fracs.split_grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.structured.html">porepy.fracs.structured module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.tools.html">porepy.fracs.tools module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.utils.html">porepy.fracs.utils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.wells_3d.html">porepy.fracs.wells_3d module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.html">porepy.geometry package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.bounding_box.html">porepy.geometry.bounding_box module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.constrain_geometry.html">porepy.geometry.constrain_geometry module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.distances.html">porepy.geometry.distances module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.geometry_property_checks.html">porepy.geometry.geometry_property_checks module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.half_space.html">porepy.geometry.half_space module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.intersections.html">porepy.geometry.intersections module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.map_geometry.html">porepy.geometry.map_geometry module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.point_in_polyhedron_test.html">porepy.geometry.point_in_polyhedron_test module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.html">porepy.grids package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.html">porepy.grids.standard_grids package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.boundary_grid.html">porepy.grids.boundary_grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.coarsening.html">porepy.grids.coarsening module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.grid.html">porepy.grids.grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.grid_extrusion.html">porepy.grids.grid_extrusion module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.match_grids.html">porepy.grids.match_grids module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.md_grid.html">porepy.grids.md_grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.mortar_grid.html">porepy.grids.mortar_grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.partition.html">porepy.grids.partition module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.point_grid.html">porepy.grids.point_grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.refinement.html">porepy.grids.refinement module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.simplex.html">porepy.grids.simplex module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.structured.html">porepy.grids.structured module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.html">porepy.models package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.html">porepy.models.verification_setups package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.abstract_equations.html">porepy.models.abstract_equations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.abstract_model.html">porepy.models.abstract_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.constitutive_laws.html">porepy.models.constitutive_laws module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.contact_mechanics_biot_model.html">porepy.models.contact_mechanics_biot_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.contact_mechanics_model.html">porepy.models.contact_mechanics_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.energy_balance.html">porepy.models.energy_balance module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.fluid_mass_balance.html">porepy.models.fluid_mass_balance module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.geometry.html">porepy.models.geometry module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.incompressible_flow_model.html">porepy.models.incompressible_flow_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.mass_and_energy_balance.html">porepy.models.mass_and_energy_balance module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.material_constants.html">porepy.models.material_constants module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.momentum_balance.html">porepy.models.momentum_balance module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.poromechanics.html">porepy.models.poromechanics module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.run_models.html">porepy.models.run_models module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.slightly_compressible_flow_model.html">porepy.models.slightly_compressible_flow_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.solution_strategy.html">porepy.models.solution_strategy module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.thermoporomechanics.html">porepy.models.thermoporomechanics module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.thm_model.html">porepy.models.thm_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.units.html">porepy.models.units module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.html">porepy.numerics package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.html">porepy.numerics.ad package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fem.html">porepy.numerics.fem package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.html">porepy.numerics.fracture_deformation package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.html">porepy.numerics.fv package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.html">porepy.numerics.interface_laws package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linalg.html">porepy.numerics.linalg package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.html">porepy.numerics.mixed_dim package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.nonlinear.html">porepy.numerics.nonlinear package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.solvers.html">porepy.numerics.solvers package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.html">porepy.numerics.vem package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.discretization.html">porepy.numerics.discretization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.displacement_correlation.html">porepy.numerics.displacement_correlation module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linear_solvers.html">porepy.numerics.linear_solvers module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.time_step_control.html">porepy.numerics.time_step_control module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.html">porepy.params package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.bc.html">porepy.params.bc module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.data.html">porepy.params.data module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.fluid.html">porepy.params.fluid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.parameter_dictionaries.html">porepy.params.parameter_dictionaries module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.rock.html">porepy.params.rock module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.tensor.html">porepy.params.tensor module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.html">porepy.utils package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.derived_discretizations.html">porepy.utils.derived_discretizations package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.accumarray.html">porepy.utils.accumarray module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.adtree.html">porepy.utils.adtree module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.array_operations.html">porepy.utils.array_operations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.common_constants.html">porepy.utils.common_constants module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.default_domains.html">porepy.utils.default_domains module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.error.html">porepy.utils.error module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.graph.html">porepy.utils.graph module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.grid_utils.html">porepy.utils.grid_utils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.interpolation_tables.html">porepy.utils.interpolation_tables module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.mcolon.html">porepy.utils.mcolon module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.permutations.html">porepy.utils.permutations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.porepy_types.html">porepy.utils.porepy_types module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.setmembership.html">porepy.utils.setmembership module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.sort_points.html">porepy.utils.sort_points module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.tags.html">porepy.utils.tags module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.tangential_normal_projection.html">porepy.utils.tangential_normal_projection module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.html">porepy.viz package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.data_saving_model_mixin.html">porepy.viz.data_saving_model_mixin module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.exporter.html">porepy.viz.exporter module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.fracture_visualization.html">porepy.viz.fracture_visualization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.plot_grid.html">porepy.viz.plot_grid module</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PorePy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">porepy.viz.exporter</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for porepy.viz.exporter</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module for exporting to vtu for (e.g. ParaView) visualization using the vtk module.</span>

<span class="sd">The Exporter class contains methods for exporting a single grid or mixed-dimensional</span>
<span class="sd">with associated data to the vtu format. For mixed-dimensional grids, one</span>
<span class="sd">vtu file is printed for each grid. For transient simulations with multiple</span>
<span class="sd">time steps, a single pvd file takes care of the ordering of all printed vtu</span>
<span class="sd">files.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">meshio</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">porepy</span> <span class="k">as</span> <span class="nn">pp</span>

<span class="c1"># Object type to store data to export.</span>
<span class="n">Field</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Field&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">])</span>

<span class="c1"># Object for managing meshio-relevant data, as well as a container</span>
<span class="c1"># for its storage, taking dimensions as inputs. Since 0d grids are</span>
<span class="c1"># stored as &#39;None&#39;, allow for such values.</span>
<span class="n">Meshio_Geom</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Meshio_Geom&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;pts&quot;</span><span class="p">,</span> <span class="s2">&quot;connectivity&quot;</span><span class="p">,</span> <span class="s2">&quot;cell_ids&quot;</span><span class="p">])</span>
<span class="n">MD_Meshio_Geom</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Meshio_Geom</span><span class="p">]]</span>

<span class="c1"># All allowed data structures to define data for exporting</span>
<span class="n">DataInput</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="c1"># Keys for states</span>
    <span class="nb">str</span><span class="p">,</span>
    <span class="c1"># Subdomain specific data types</span>
    <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">],</span> <span class="nb">str</span><span class="p">],</span>
    <span class="n">Tuple</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="c1"># Interface specific data types</span>
    <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">],</span> <span class="nb">str</span><span class="p">],</span>
    <span class="n">Tuple</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
<span class="p">]</span>

<span class="c1"># Data structure in which data is stored after preprocessing</span>
<span class="n">SubdomainData</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
<span class="n">InterfaceData</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>


<div class="viewcode-block" id="Exporter"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.viz.exporter.html#porepy.viz.exporter.Exporter">[docs]</a><span class="k">class</span> <span class="nc">Exporter</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for exporting data to vtu files.</span>

<span class="sd">    The Exporter allows for various way to express which state variables,</span>
<span class="sd">    on which grids, and which extra data should be exported. A thorough</span>
<span class="sd">    demonstration is available as a dedicated tutorial. Check out</span>
<span class="sd">    tutorials/exporter.ipynb.</span>

<span class="sd">    In general, pvd files gather data exported in separate files, including</span>
<span class="sd">    data on differently dimensioned grids, constant data, and finally time steps.</span>

<span class="sd">    In the case of different keywords, change the file name with</span>
<span class="sd">    &quot;change_name&quot;.</span>

<span class="sd">    NOTE: the following names are reserved for constant data exporting</span>
<span class="sd">    and should not be used otherwise (otherwise data is overwritten):</span>
<span class="sd">    grid_dim, is_mortar, mortar_side, cell_id, subdomain_id,</span>
<span class="sd">    interface_id.</span>

<span class="sd">    Examples:</span>
<span class="sd">        # Here, merely a brief demonstration of the use of Exporter is presented.</span>

<span class="sd">        # If you need to export the state with key &quot;pressure&quot; on a single grid:</span>
<span class="sd">        save = Exporter(g, &quot;solution&quot;, folder_name=&quot;results&quot;)</span>
<span class="sd">        save.write_vtu([&quot;pressure&quot;])</span>

<span class="sd">        # In a time loop, if you need to export states with keys &quot;pressure&quot; and</span>
<span class="sd">        # &quot;displacement&quot; stored in a mixed-dimensional grid, do:</span>

<span class="sd">        save = Exporter(mdg, &quot;solution&quot;, folder_name=&quot;results&quot;)</span>
<span class="sd">        while time:</span>
<span class="sd">            save.write_vtu([&quot;pressure&quot;, &quot;displacement&quot;], time_step=i)</span>
<span class="sd">        save.write_pvd(times)</span>

<span class="sd">        # where times is a list of actual times (not time steps), associated</span>
<span class="sd">        # to the previously exported time steps. If times is not provided</span>
<span class="sd">        # the time steps will be used instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">grid</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">MixedDimensionalGrid</span><span class="p">],</span>
        <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">folder_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initialization of Exporter.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            grid: Subdomain or mixed-dimensional grid containing all mesh information</span>
<span class="sd">                (and data in the latter case) to be exported.</span>
<span class="sd">            file_name: Basis for file names used for storing the output.</span>
<span class="sd">            folder_name: Name of the folder in which files are stored.</span>
<span class="sd">            kwargs: Optional keywords arguments:</span>
<span class="sd">                fixed_grid (boolean): to control whether the grid may be redefined later</span>
<span class="sd">                    (default True)</span>
<span class="sd">                binary (boolean): controlling whether data is stored in binary format</span>
<span class="sd">                    (default True)</span>
<span class="sd">                export_constants_separately (boolean): controlling whether</span>
<span class="sd">                    constant data is exported in separate files, which may be of interest</span>
<span class="sd">                    when exporting large data sets (in particular of constant data) for</span>
<span class="sd">                    many time steps (default True); note, however, that the mesh is</span>
<span class="sd">                    exported to each vtu file, which may also require significant amount</span>
<span class="sd">                    of storage.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If grid has other type than :class:`~pp.grids.grid.Grid` or</span>
<span class="sd">                :class:`~pp.grids.md_grid.MixedDimensionalGrid`.</span>
<span class="sd">            TypeError: If kwargs contains unexpected keyword arguments.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Exporter is operating on mixed-dimensional grids. Convert to mixed-dimensional</span>
        <span class="c1"># grids if subdomain grid is provided.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">MixedDimensionalGrid</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span><span class="o">.</span><span class="n">add_subdomains</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">MixedDimensionalGrid</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Exporter only supports subdomain and mixed-dimensional grids.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Store target location for storing vtu and pvd files.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file_name</span> <span class="o">=</span> <span class="n">file_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_folder_name</span> <span class="o">=</span> <span class="n">folder_name</span>

        <span class="c1"># Check for optional keywords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_grid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;fixed_grid&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_binary</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;binary&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_export_constants_separately</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
            <span class="s2">&quot;export_constants_separately&quot;</span><span class="p">,</span> <span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Exporter() got unexpected keyword argument &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">popitem</span><span class="p">()[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c1"># Generate infrastructure for storing fixed-dimensional grids in</span>
        <span class="c1"># meshio format. Include all but the 0-d grids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">sd</span><span class="o">.</span><span class="n">dim</span> <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">()</span> <span class="k">if</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshio_geom</span><span class="p">:</span> <span class="n">MD_Meshio_Geom</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Generate infrastructure for storing fixed-dimensional mortar grids</span>
        <span class="c1"># in meshio format.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_m_dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">intf</span><span class="o">.</span><span class="n">dim</span> <span class="k">for</span> <span class="n">intf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span><span class="o">.</span><span class="n">interfaces</span><span class="p">()])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_meshio_geom</span><span class="p">:</span> <span class="n">MD_Meshio_Geom</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Generate geometrical information in meshio format</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_meshio_geom</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_constant_mesh_data</span><span class="p">()</span>

        <span class="c1"># Counter for time step. Will be used to identify files of individual time step,</span>
        <span class="c1"># unless this is overridden by optional parameters in write</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_step_counter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Storage for file name extensions for time steps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exported_timesteps</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Reference to the last time step used for exporting constant data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_step_constant_data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Storage for file name extensions for time steps, regarding constant data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exported_timesteps_constants</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="c1"># Identifier for whether constant data is up-to-date.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exported_constant_data_up_to_date</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Flags tracking whether dynamic or constant, subdomain or interface data has</span>
        <span class="c1"># been assigned to the Exporter.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_subdomain_data</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_interface_data</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_constant_subdomain_data</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_constant_interface_data</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Parameter to be used in several occasions for adding time stamps.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_padding</span> <span class="o">=</span> <span class="mi">6</span>

<div class="viewcode-block" id="Exporter.add_constant_data"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.viz.exporter.html#porepy.viz.exporter.Exporter.add_constant_data">[docs]</a>    <span class="k">def</span> <span class="nf">add_constant_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">DataInput</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">DataInput</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collect user-defined constant-in-time data, associated with grids,</span>
<span class="sd">        and to be exported to separate files instead of the main files.</span>

<span class="sd">        In principle, constant data is not different from standard output</span>
<span class="sd">        data. It is merely printed to another file and just when any constant</span>
<span class="sd">        data is updated (via updates of the grid, or the use of this routine).</span>
<span class="sd">        Hence, the same input formats are allowed as for the usual field data,</span>
<span class="sd">        which is varying in time. As part of the routine, the data is converted</span>
<span class="sd">        to the same unified format.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            data (Union[DataInput, list[DataInput]], optional): subdomain and</span>
<span class="sd">                interface data, prescribed through strings, or tuples of</span>
<span class="sd">                subdomains/interfaces, keys and values. If not provided, only</span>
<span class="sd">                geometrical information is exported.</span>

<span class="sd">                NOTE: The user has to make sure that each unique key has</span>
<span class="sd">                associated data values for all or no grids of each specific</span>
<span class="sd">                dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Interpret change in constant data. Has the effect that</span>
        <span class="c1"># the constant data container will be exported at the</span>
        <span class="c1"># next application of write_vtu().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exported_constant_data_up_to_date</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Preprocessing of the user-defined constant data</span>
        <span class="c1"># Has two main goals:</span>
        <span class="c1"># 1. Sort wrt. whether data is associated to subdomains or interfaces.</span>
        <span class="c1"># 2. Unify data type.</span>
        <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_and_unify_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># Add the user-defined data to the containers for constant data.</span>
        <span class="k">for</span> <span class="n">key_s</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">subdomain_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constant_subdomain_data</span><span class="p">[</span><span class="n">key_s</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key_i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">interface_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="p">[</span><span class="n">key_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="Exporter.write_vtu"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.viz.exporter.html#porepy.viz.exporter.Exporter.write_vtu">[docs]</a>    <span class="k">def</span> <span class="nf">write_vtu</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">DataInput</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">DataInput</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">time_dependent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">time_step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">grid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">MixedDimensionalGrid</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interface function to export the grid and additional data with meshio.</span>

<span class="sd">        In 1d the cells are represented as lines, 2d the cells as polygon or</span>
<span class="sd">        triangle/quad, while in 3d as polyhedra/tetrahedra/hexahedra.</span>
<span class="sd">        In all the dimensions the geometry of the mesh needs to be computed.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            data (Union[DataInput, list[DataInput]], optional): subdomain and</span>
<span class="sd">                interface data, prescribed through strings, or tuples of</span>
<span class="sd">                subdomains/interfaces, keys and values. If not provided only</span>
<span class="sd">                geometrical infos are exported.</span>

<span class="sd">                NOTE: The user has to make sure that each unique key has</span>
<span class="sd">                associated data values for all or no grids of each specific</span>
<span class="sd">                dimension.</span>
<span class="sd">            time_dependent (boolean): If False (default), file names will</span>
<span class="sd">                not be appended with an index that marks the time step.</span>
<span class="sd">                Can be overwritten by giving a value to time_step; if not,</span>
<span class="sd">                the file names will subsequently be ending with 1, 2, etc.</span>
<span class="sd">            time_step (int, optional): will be used as appendix to define</span>
<span class="sd">                the file corresponding to this specific time step.</span>
<span class="sd">            grid (Union[pp.Grid, pp.MixedDimensionalGrid], optional): subdomain or</span>
<span class="sd">                mixed-dimensional grid if it is not fixed and should be updated.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError if a grid is provided as argument although the exporter</span>
<span class="sd">                has been instructed that the grid is fixed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Update the grid but only if allowed, i.e., the initial grid</span>
        <span class="c1"># has not been characterized as fixed.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_grid</span> <span class="ow">and</span> <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Inconsistency in exporter setting&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_grid</span> <span class="ow">and</span> <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Require a mixed-dimensional grid. Thus convert if single subdomain grid provided.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">):</span>
                <span class="c1"># Create a new mixed-dimensional solely with grid as single subdomain.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">MixedDimensionalGrid</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span><span class="o">.</span><span class="n">add_subdomains</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span> <span class="o">=</span> <span class="n">grid</span>

            <span class="c1"># Update geometrical info in meshio format for the updated grid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_meshio_geom</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_constant_mesh_data</span><span class="p">()</span>

        <span class="c1"># If the problem is time dependent, but no time step is set, we set one</span>
        <span class="c1"># using the updated, internal counter.</span>
        <span class="k">if</span> <span class="n">time_dependent</span> <span class="ow">and</span> <span class="n">time_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_step_counter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_time_step_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># If time step is prescribed, store it.</span>
        <span class="k">if</span> <span class="n">time_step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_exported_timesteps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time_step</span><span class="p">)</span>

        <span class="c1"># Preprocessing step with two main goals:</span>
        <span class="c1"># 1. Sort wrt. whether data is associated to subdomains or interfaces.</span>
        <span class="c1"># 2. Unify data type.</span>
        <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_and_unify_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># Export constant data to separate or standard files</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_export_constants_separately</span><span class="p">:</span>
            <span class="c1"># Export constant data to vtu when outdated</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exported_constant_data_up_to_date</span><span class="p">:</span>
                <span class="c1"># Export constant subdomain data to vtu</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constant_subdomain_data</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_has_constant_subdomain_data</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_export_data_vtu</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_constant_subdomain_data</span><span class="p">,</span> <span class="n">time_step</span><span class="p">,</span> <span class="n">constant_data</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>

                <span class="c1"># Export constant interface data to vtu</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_has_constant_interface_data</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_export_data_vtu</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="p">,</span>
                        <span class="n">time_step</span><span class="p">,</span>
                        <span class="n">constant_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">interface_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="c1"># Store the time step counter for later reference</span>
                <span class="c1"># (required for pvd files)</span>
                <span class="c1"># NOTE: The counter is only updated if the constant</span>
                <span class="c1"># data is outdated, so if the mesh has been updated</span>
                <span class="c1"># or new constant data has been added in the course</span>
                <span class="c1"># of the simulation.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_time_step_constant_data</span> <span class="o">=</span> <span class="n">time_step</span>

                <span class="c1"># Identify the constant data as fixed. Has the effect</span>
                <span class="c1"># that the constant data won&#39;t be exported if not the</span>
                <span class="c1"># mesh is updated or new constant data is added.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_exported_constant_data_up_to_date</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Store the timestep referring to the origin of the constant data</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_time_step_constant_data&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_step_constant_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_exported_timesteps_constants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_time_step_constant_data</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Append constant subdomain and interface data to the</span>
            <span class="c1"># standard containers for subdomain and interface data.</span>
            <span class="k">for</span> <span class="n">key_sd</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constant_subdomain_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">subdomain_data</span><span class="p">[</span><span class="n">key_sd</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key_intf</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">interface_data</span><span class="p">[</span><span class="n">key_intf</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Export subdomain and interface data to vtu format if existing</span>
        <span class="k">if</span> <span class="n">subdomain_data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_subdomain_data</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_export_data_vtu</span><span class="p">(</span><span class="n">subdomain_data</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">interface_data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_interface_data</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_export_data_vtu</span><span class="p">(</span><span class="n">interface_data</span><span class="p">,</span> <span class="n">time_step</span><span class="p">,</span> <span class="n">interface_data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Export mixed-dimensional grid to pvd format</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_file_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_file_name</span><span class="p">,</span> <span class="n">time_step</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="s2">&quot;.pvd&quot;</span><span class="p">)</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_folder_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_folder_name</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_export_mdg_pvd</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">time_step</span><span class="p">)</span></div>

<div class="viewcode-block" id="Exporter.write_pvd"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.viz.exporter.html#porepy.viz.exporter.Exporter.write_pvd">[docs]</a>    <span class="k">def</span> <span class="nf">write_pvd</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">times</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">file_extension</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interface function to export in PVD file the time loop information.</span>
<span class="sd">        The user should open only this file in ParaView.</span>

<span class="sd">        We assume that the VTU associated files have the same name, and that.</span>
<span class="sd">        the VTU associated files are in the working directory.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            times (np.ndarray, optional): array of actual times to be exported. These will</span>
<span class="sd">                be the times associated with individual time steps in, say, ParaView.</span>
<span class="sd">                By default, the times will be associated with the order in which the time</span>
<span class="sd">                steps were exported. This can be overridden by the file_extension argument.</span>
<span class="sd">                If no times are provided, the exported time steps are used.</span>
<span class="sd">            file_extension (np.array-like, optional): End of file names used in the export</span>
<span class="sd">                of individual time steps, see self.write_vtu(). If provided, it should have</span>
<span class="sd">                the same length as time. If not provided, the file names will be picked</span>
<span class="sd">                from those used when writing individual time steps.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_exported_timesteps</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">file_extension</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">file_extension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exported_timesteps</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_extension</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">file_extension</span> <span class="o">=</span> <span class="n">file_extension</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="c1"># Make sure that the inputs are consistent</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_extension</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_extension</span><span class="p">)</span> <span class="o">==</span> <span class="n">times</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Extract the time steps related to constant data and</span>
        <span class="c1"># complying with file_extension. Implicitly test whether</span>
        <span class="c1"># file_extension is a subset of _exported_timesteps.</span>
        <span class="c1"># Only if constant data has been exported.</span>
        <span class="n">include_constant_data</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_export_constants_separately</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_exported_timesteps_constants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">include_constant_data</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_exported_timesteps</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">file_extension</span><span class="p">]</span>
            <span class="n">file_extension_constants</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_exported_timesteps_constants</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span>
            <span class="p">]</span>

        <span class="c1"># Perform the same procedure as in _export_mdg_pvd</span>
        <span class="c1"># but looping over all designated time steps.</span>

        <span class="n">o_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_append_folder_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_folder_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file_name</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.pvd&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span>
        <span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;LittleEndian&quot;</span> <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s2">&quot;little&quot;</span> <span class="k">else</span> <span class="s2">&quot;BigEndian&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="s1">&#39; compressor=&quot;vtkZLibDataCompressor&quot;&#39;</span>
        <span class="n">header</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;&lt;?xml version=&quot;1.0&quot;?&gt;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="o">+</span> <span class="s1">&#39;&lt;VTKFile type=&quot;Collection&quot; version=&quot;0.1&quot; &#39;</span>
            <span class="o">+</span> <span class="s1">&#39;byte_order=&quot;</span><span class="si">%s</span><span class="s1">&quot;</span><span class="si">%s</span><span class="s1">&gt;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;&lt;Collection&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">o_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
        <span class="n">fm</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&lt;DataSet group=&quot;&quot; part=&quot;&quot; timestep=&quot;</span><span class="si">%f</span><span class="s1">&quot; file=&quot;</span><span class="si">%s</span><span class="s1">&quot;/&gt;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="c1"># Gather all data, and assign the actual time.</span>
        <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">fn</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">file_extension</span><span class="p">):</span>
            <span class="c1"># Go through all possible data types, analogously to</span>
            <span class="c1"># _export_mdg_pvd.</span>

            <span class="c1"># Subdomain data</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_subdomain_data</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshio_geom</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">o_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                        <span class="n">fm</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_file_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_file_name</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
                    <span class="p">)</span>

            <span class="c1"># Interface data.</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m_dims</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_interface_data</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_meshio_geom</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">o_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                        <span class="n">fm</span>
                        <span class="o">%</span> <span class="p">(</span>
                            <span class="n">time</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_make_file_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_file_name</span> <span class="o">+</span> <span class="s2">&quot;_mortar&quot;</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

        <span class="c1"># Optionally, do the same for constant data.</span>
        <span class="k">if</span> <span class="n">include_constant_data</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">fn_constants</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">file_extension_constants</span><span class="p">):</span>
                <span class="c1"># Constant subdomain data.</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_has_constant_subdomain_data</span>
                        <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshio_geom</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="p">):</span>
                        <span class="n">o_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                            <span class="n">fm</span>
                            <span class="o">%</span> <span class="p">(</span>
                                <span class="n">time</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_make_file_name</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_file_name</span> <span class="o">+</span> <span class="s2">&quot;_constant&quot;</span><span class="p">,</span> <span class="n">fn_constants</span><span class="p">,</span> <span class="n">dim</span>
                                <span class="p">),</span>
                            <span class="p">)</span>
                        <span class="p">)</span>

                <span class="c1"># Constant interface data.</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m_dims</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_has_constant_interface_data</span>
                        <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_meshio_geom</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="p">):</span>
                        <span class="n">o_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                            <span class="n">fm</span>
                            <span class="o">%</span> <span class="p">(</span>
                                <span class="n">time</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_make_file_name</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_file_name</span> <span class="o">+</span> <span class="s2">&quot;_constant_mortar&quot;</span><span class="p">,</span>
                                    <span class="n">fn_constants</span><span class="p">,</span>
                                    <span class="n">dim</span><span class="p">,</span>
                                <span class="p">),</span>
                            <span class="p">)</span>
                        <span class="p">)</span>

        <span class="n">o_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;/Collection&gt;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;&lt;/VTKFile&gt;&quot;</span><span class="p">)</span>
        <span class="n">o_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

    <span class="c1"># Some auxiliary routines used in write_vtu()</span>

    <span class="k">def</span> <span class="nf">_sort_and_unify_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="c1"># ignore type which is essentially Union[DataInput, list[DataInput]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">SubdomainData</span><span class="p">,</span> <span class="n">InterfaceData</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Preprocess data.</span>

<span class="sd">        The routine has two goals:</span>
<span class="sd">        1. Splitting data into subdomain and interface data.</span>
<span class="sd">        2. Unify the data format. Store data in dictionaries, with keys given by</span>
<span class="sd">            subdomains/interfaces and names, and values given by the data arrays.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            data (Union[DataInput, list[DataInput]], optional): data</span>
<span class="sd">                provided by the user in the form of strings and/or tuples</span>
<span class="sd">                of subdomains/interfaces.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[SubdomainData, InterfaceData]: Subdomain and interface data decomposed</span>
<span class="sd">                and brought into unified format.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError if the data type provided is not supported</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The strategy is to traverse the input data and check each data point</span>
        <span class="c1"># for its type and apply a corresponding conversion to a unique format.</span>
        <span class="c1"># For each supported input data format, a dedicated routine is implemented</span>
        <span class="c1"># to 1. identify whether the type is present; and 2. update the data</span>
        <span class="c1"># dictionaries (to be returned in this routine) in the correct format:</span>
        <span class="c1"># The dictionaries use (subdomain,key) and (interface,key) as key and the data</span>
        <span class="c1"># array as value.</span>

        <span class="c1"># Now a list of these subroutines follows before the definition of the</span>
        <span class="c1"># actual routine.</span>

        <span class="c1"># Aux. method: Transform scalar- to vector-ranged values.</span>
        <span class="k">def</span> <span class="nf">_toVectorFormat</span><span class="p">(</span>
            <span class="n">value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check whether the value array has the right dimension corresponding</span>
<span class="sd">            to the grid size. If possible, translate the value to a vectorial</span>
<span class="sd">            object, but do nothing if the data naturally can be interpreted as</span>
<span class="sd">            scalar data.</span>

<span class="sd">            Parameters:</span>
<span class="sd">                value (np.ndarray): input array to be converted.</span>
<span class="sd">                grid (pp.Grid or pp.MortarGrid): subdomain or interface to which value</span>
<span class="sd">                    is associated to.</span>

<span class="sd">            Raises:</span>
<span class="sd">                ValueError if the value array is not compatible with the grid.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># Make some checks</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">size</span> <span class="o">%</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_cells</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># This line will raise an error if node or face data is exported.</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The data array is not compatible with the grid.&quot;</span><span class="p">)</span>

            <span class="c1"># Convert to vectorial data if more data provided than grid cells available,</span>
            <span class="c1"># and the value array is not already in vectorial format</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_cells</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_cells</span>
            <span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_cells</span><span class="p">),</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">value</span>

        <span class="c1"># TODO rename pt to data_pt?</span>
        <span class="c1"># TODO typing</span>
        <span class="k">def</span> <span class="nf">add_data_from_str</span><span class="p">(</span>
            <span class="n">data_pt</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">interface_data</span><span class="p">:</span> <span class="nb">dict</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check whether data is provided by a key of a field - could be both subdomain</span>
<span class="sd">            and interface data. If so, collect all data corresponding to subdomains and</span>
<span class="sd">            interfaces identified by the key.</span>

<span class="sd">            Raises:</span>
<span class="sd">                ValueError if no data available in the mixed-dimensional grid for given key</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># Only continue in case data is of type str</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_pt</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>

                <span class="c1"># Identify the key provided through the data.</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">data_pt</span>

                <span class="c1"># Initialize tag storing whether data corresponding to the key has been found.</span>
                <span class="n">has_key</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">def</span> <span class="nf">_add_data</span><span class="p">(</span>
                    <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                    <span class="n">grid</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">],</span>
                    <span class="n">grid_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                    <span class="n">export_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pp</span><span class="o">.</span><span class="n">STATE</span> <span class="ow">in</span> <span class="n">grid_data</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">grid_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">]:</span>
                        <span class="c1"># Fetch data and convert to vectorial format if suggested by the size</span>
                        <span class="n">value</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">_toVectorFormat</span><span class="p">(</span>
                            <span class="n">grid_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="n">key</span><span class="p">],</span> <span class="n">grid</span>
                        <span class="p">)</span>

                        <span class="c1"># Add data point in correct format to the collection</span>
                        <span class="n">export_data</span><span class="p">[(</span><span class="n">grid</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>

                        <span class="c1"># Mark as success</span>
                        <span class="k">return</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>

                <span class="c1"># Check data associated to subdomain field data</span>
                <span class="k">for</span> <span class="n">sd</span><span class="p">,</span> <span class="n">sd_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">_add_data</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="p">):</span>
                        <span class="n">has_key</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># Check data associated to interface field data</span>
                <span class="k">for</span> <span class="n">intf</span><span class="p">,</span> <span class="n">intf_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span><span class="o">.</span><span class="n">interfaces</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">_add_data</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">intf</span><span class="p">,</span> <span class="n">intf_data</span><span class="p">,</span> <span class="n">interface_data</span><span class="p">):</span>
                        <span class="n">has_key</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># Make sure the key exists</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">has_key</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;No data with provided key </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> present in the grid.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Return updated dictionaries and indicate successful conversion.</span>
                <span class="k">return</span> <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span><span class="p">,</span> <span class="kc">True</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Return original data dictionaries and indicate no modification.</span>
                <span class="k">return</span> <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span><span class="p">,</span> <span class="kc">False</span>

        <span class="k">def</span> <span class="nf">add_data_from_tuple_subdomains_str</span><span class="p">(</span>
            <span class="n">data_pt</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">],</span> <span class="nb">str</span><span class="p">],</span>
            <span class="n">subdomain_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
            <span class="n">interface_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check whether data is provided as tuple (subdomains, key),</span>
<span class="sd">            where subdomains is a list of subdomains, and key is a string.</span>
<span class="sd">            This routine explicitly checks only for subdomain data.</span>

<span class="sd">            Raises:</span>
<span class="sd">                ValueError if there exists no state in the subdomain data with given key</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># Implementation of isinstance(data_pt, tuple[list[pp.Grid], str]).</span>
            <span class="n">isinstance_tuple_subdomains_str</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">data_pt</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span>
                <span class="nb">list</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">,</span>
            <span class="p">]</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">)</span> <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">data_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

            <span class="c1"># If of correct type, convert to unique format and update subdomain data.</span>
            <span class="k">if</span> <span class="n">isinstance_tuple_subdomains_str</span><span class="p">:</span>

                <span class="c1"># By construction, the 1. and 2. components are a list of grids and a key.</span>
                <span class="n">subdomains</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">data_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># Loop over grids and fetch the states corresponding to the key</span>
                <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">subdomains</span><span class="p">:</span>

                    <span class="c1"># Fetch the data dictionary containing the data value</span>
                    <span class="n">sd_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span><span class="o">.</span><span class="n">subdomain_data</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span>

                    <span class="c1"># Make sure the data exists.</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span> <span class="ow">in</span> <span class="n">sd_data</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">]):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;&quot;&quot;No state with prescribed key </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"></span>
<span class="s2">                            available on selected subdomains.&quot;&quot;&quot;</span>
                        <span class="p">)</span>

                    <span class="c1"># Fetch data and convert to vectorial format if suitable</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">_toVectorFormat</span><span class="p">(</span><span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="n">key</span><span class="p">],</span> <span class="n">sd</span><span class="p">)</span>

                    <span class="c1"># Add data point in correct format to collection</span>
                    <span class="n">subdomain_data</span><span class="p">[(</span><span class="n">sd</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>

                <span class="c1"># Return updated dictionaries and indicate successful conversion.</span>
                <span class="k">return</span> <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span><span class="p">,</span> <span class="kc">True</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Return original data dictionaries and indicate no modification.</span>
                <span class="k">return</span> <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span><span class="p">,</span> <span class="kc">False</span>

        <span class="c1"># Aux. method: Detect and convert data of form ([interfaces], &quot;key&quot;).</span>
        <span class="k">def</span> <span class="nf">add_data_from_tuple_interfaces_str</span><span class="p">(</span>
            <span class="n">data_pt</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check whether data is provided as tuple (interfaces, key),</span>
<span class="sd">            where interfaces is a list of interfaces, and key is a string.</span>
<span class="sd">            This routine explicitly checks only for interface data.</span>

<span class="sd">            This routine is a translation of add_data_from_tuple_subdomains_str to interfaces</span>

<span class="sd">            Raises:</span>
<span class="sd">                ValueError if there exists no state in the interface data with given key</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># Implementation of isinstance(t, tuple[list[pp.MortarGrid], str]).</span>
            <span class="n">isinstance_tuple_interfaces_str</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">data_pt</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span>
                <span class="nb">list</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">,</span>
            <span class="p">]</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">)</span> <span class="k">for</span> <span class="n">intf</span> <span class="ow">in</span> <span class="n">data_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

            <span class="c1"># If of correct type, convert to unique format and update subdomain data.</span>
            <span class="k">if</span> <span class="n">isinstance_tuple_interfaces_str</span><span class="p">:</span>

                <span class="c1"># By construction, the 1. and 2. components are a list of interfaces and a key.</span>
                <span class="n">interfaces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">data_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># Loop over interfaces and fetch the states corresponding to the key</span>
                <span class="k">for</span> <span class="n">intf</span> <span class="ow">in</span> <span class="n">interfaces</span><span class="p">:</span>

                    <span class="c1"># Fetch the data dictionary containing the data value</span>
                    <span class="n">intf_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span><span class="o">.</span><span class="n">interface_data</span><span class="p">(</span><span class="n">intf</span><span class="p">)</span>

                    <span class="c1"># Make sure the data exists.</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span> <span class="ow">in</span> <span class="n">intf_data</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">intf_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">]):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;&quot;&quot;No state with prescribed key </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"></span>
<span class="s2">                            available on selected interfaces.&quot;&quot;&quot;</span>
                        <span class="p">)</span>

                    <span class="c1"># Fetch data and convert to vectorial format if suitable</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">_toVectorFormat</span><span class="p">(</span><span class="n">intf_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="n">key</span><span class="p">],</span> <span class="n">intf</span><span class="p">)</span>

                    <span class="c1"># Add data point in correct format to collection</span>
                    <span class="n">interface_data</span><span class="p">[(</span><span class="n">intf</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>

                <span class="c1"># Return updated dictionaries and indicate successful conversion.</span>
                <span class="k">return</span> <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span><span class="p">,</span> <span class="kc">True</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Return original data dictionaries and indicate no modification.</span>
                <span class="k">return</span> <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span><span class="p">,</span> <span class="kc">False</span>

        <span class="k">def</span> <span class="nf">add_data_from_tuple_subdomain_str_array</span><span class="p">(</span>
            <span class="n">data_pt</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check whether data is provided as tuple (sd, key, data),</span>
<span class="sd">            where sd is a single subdomain, key is a string, and data is a user-defined data</span>
<span class="sd">            array. This routine explicitly checks only for subdomain data.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># Implementation of isinstance(t, tuple[pp.Grid, str, np.ndarray]).</span>
            <span class="c1"># NOTE: The type of a grid identifies the specific grid type (simplicial</span>
            <span class="c1"># etc.) Thus, isinstance is used here to detect whether a grid is provided.</span>
            <span class="n">isinstance_tuple_subdomain_str_array</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">data_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span>
            <span class="p">)</span> <span class="ow">and</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">data_pt</span><span class="p">))[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>

            <span class="c1"># Convert data to unique format and update the subdomain data dictionary.</span>
            <span class="k">if</span> <span class="n">isinstance_tuple_subdomain_str_array</span><span class="p">:</span>

                <span class="c1"># Interpret (sd, key, value) = (data_pt[0], data_pt[1], data_pt[2]);</span>
                <span class="n">sd</span> <span class="o">=</span> <span class="n">data_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">data_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">_toVectorFormat</span><span class="p">(</span><span class="n">data_pt</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sd</span><span class="p">)</span>

                <span class="c1"># Add data point in correct format to collection</span>
                <span class="n">subdomain_data</span><span class="p">[(</span><span class="n">sd</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>

                <span class="c1"># Return updated dictionaries and indicate successful conversion.</span>
                <span class="k">return</span> <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span><span class="p">,</span> <span class="kc">True</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Return original data dictionaries and indicate no modification.</span>
                <span class="k">return</span> <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span><span class="p">,</span> <span class="kc">False</span>

        <span class="k">def</span> <span class="nf">add_data_from_tuple_interface_str_array</span><span class="p">(</span>
            <span class="n">data_pt</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">interface_data</span><span class="p">:</span> <span class="nb">dict</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check whether data is provided as tuple (g, key, data),</span>
<span class="sd">            where e is a single interface, key is a string, and data is a user-defined</span>
<span class="sd">            data array. This routine explicitly checks only for interface data.</span>

<span class="sd">            Translation of add_data_from_tuple_subdomain_str_array to interfaces.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># Implementation of isinstance(t, tuple[pp.MortarGrid, str, np.ndarray]).</span>
            <span class="n">isinstance_tuple_interface_str_array</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">data_pt</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="p">]</span>

            <span class="c1"># Convert data to unique format and update the interface data dictionary.</span>
            <span class="k">if</span> <span class="n">isinstance_tuple_interface_str_array</span><span class="p">:</span>
                <span class="c1"># Interpret (intf, key, value) = (data_pt[0], data_pt[1], data_pt[2]);</span>
                <span class="n">intf</span> <span class="o">=</span> <span class="n">data_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">data_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">_toVectorFormat</span><span class="p">(</span><span class="n">data_pt</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">intf</span><span class="p">)</span>

                <span class="c1"># Add data point in correct format to collection</span>
                <span class="n">interface_data</span><span class="p">[(</span><span class="n">intf</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>

                <span class="c1"># Return updated dictionaries and indicate successful conversion.</span>
                <span class="k">return</span> <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span><span class="p">,</span> <span class="kc">True</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Return original data dictionaries and indicate no modification.</span>
                <span class="k">return</span> <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span><span class="p">,</span> <span class="kc">False</span>

        <span class="c1"># TODO can we unify to add_data_from_tuple_grid_str_array ?</span>

        <span class="k">def</span> <span class="nf">add_data_from_tuple_str_array</span><span class="p">(</span>
            <span class="n">data_pt</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check whether data is provided by a tuple (key, data),</span>
<span class="sd">            where key is a string, and data is a user-defined data array.</span>
<span class="sd">            This only works when the mixed-dimensional grid contains a single subdomain.</span>

<span class="sd">            Raises:</span>
<span class="sd">                ValueError if the mixed-dimensional grid contains more than one subdomain</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># Implementation if isinstance(data_pt, tuple[str, np.ndarray].</span>
            <span class="n">isinstance_tuple_str_array</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">data_pt</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>

            <span class="c1"># Convert data to unique format and update the interface data dictionary.</span>
            <span class="k">if</span> <span class="n">isinstance_tuple_str_array</span><span class="p">:</span>

                <span class="c1"># Fetch the correct grid. This option is only supported for mixed-dimensional</span>
                <span class="c1"># grids containing a single subdomain.</span>
                <span class="n">subdomains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">subdomains</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;&quot;&quot;The data type used for </span><span class="si">{</span><span class="n">data_pt</span><span class="si">}</span><span class="s2"> is only</span>
<span class="s2">                        supported if the mixed-dimensional grid only contains a single</span>
<span class="s2">                        subdomain.&quot;&quot;&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Fetch remaining ingredients required to define subdomain data element</span>
                <span class="n">sd</span> <span class="o">=</span> <span class="n">subdomains</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">data_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">_toVectorFormat</span><span class="p">(</span><span class="n">data_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sd</span><span class="p">)</span>

                <span class="c1"># Add data point in correct format to collection</span>
                <span class="n">subdomain_data</span><span class="p">[(</span><span class="n">sd</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>

                <span class="c1"># Return updated dictionaries and indicate successful conversion.</span>
                <span class="k">return</span> <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span><span class="p">,</span> <span class="kc">True</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Return original data dictionaries and indicate no modification.</span>
                <span class="k">return</span> <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span><span class="p">,</span> <span class="kc">False</span>

        <span class="c1">################################################</span>
        <span class="c1"># The actual routine _sort_and_unify_data()</span>
        <span class="c1">################################################</span>

        <span class="c1"># Convert data to list, while keeping the data structures provided,</span>
        <span class="c1"># or provide an empty list if no data provided</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>

        <span class="c1"># Initialize container for data associated to subdomains and interfaces</span>
        <span class="n">subdomain_data</span><span class="p">:</span> <span class="n">SubdomainData</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">interface_data</span><span class="p">:</span> <span class="n">InterfaceData</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Define methods to be used for checking the data type and performing</span>
        <span class="c1"># the conversion. This list implicitly also defines which input data is</span>
        <span class="c1"># allowed.</span>
        <span class="n">methods</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">add_data_from_str</span><span class="p">,</span>
            <span class="n">add_data_from_tuple_subdomains_str</span><span class="p">,</span>
            <span class="n">add_data_from_tuple_interfaces_str</span><span class="p">,</span>
            <span class="n">add_data_from_tuple_subdomain_str_array</span><span class="p">,</span>
            <span class="n">add_data_from_tuple_interface_str_array</span><span class="p">,</span>
            <span class="n">add_data_from_tuple_str_array</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="c1"># Loop over all data points and collect them in a unified format.</span>
        <span class="c1"># For this, two separate dictionaries (for subdomain and interface data)</span>
        <span class="c1"># are used. The final format uses (subdomain/interface,key) as key of</span>
        <span class="c1"># the dictionaries, and the value is given by the corresponding data.</span>
        <span class="k">for</span> <span class="n">data_pt</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>

            <span class="c1"># Initialize tag storing whether the conversion process for data_pt is successful.</span>
            <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">methods</span><span class="p">:</span>

                <span class="c1"># Check whether data point of right type and convert to</span>
                <span class="c1"># the unique data type.</span>
                <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span><span class="p">,</span> <span class="n">success</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span>
                    <span class="n">data_pt</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span>
                <span class="p">)</span>

                <span class="c1"># Stop, once a supported data format has been detected.</span>
                <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="c1"># Check if provided data has non-supported data format.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Input data </span><span class="si">{</span><span class="n">data_pt</span><span class="si">}</span><span class="s2"> has wrong format and cannot be exported.&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">subdomain_data</span><span class="p">,</span> <span class="n">interface_data</span>

    <span class="k">def</span> <span class="nf">_update_constant_mesh_data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct/update subdomain and interface data related with geometry and topology.</span>

<span class="sd">        The data is identified as constant data. The final containers, stored as</span>
<span class="sd">        attributes _constant_subdomain_data and _constant_interface_data, have</span>
<span class="sd">        the same format as the output of _sort_and_unify_data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Assume a change in constant data (it is not checked whether</span>
        <span class="c1"># the data really has been modified). Has the effect that</span>
        <span class="c1"># the constant data container will be exported at the</span>
        <span class="c1"># next application of write_vtu().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exported_constant_data_up_to_date</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Define constant subdomain data related to the mesh</span>

        <span class="c1"># Initialize container for constant subdomain data</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_constant_subdomain_data&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constant_subdomain_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Add mesh related, constant subdomain data by direct assignment</span>
        <span class="k">for</span> <span class="n">sd</span><span class="p">,</span> <span class="n">sd_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constant_subdomain_data</span><span class="p">[(</span><span class="n">sd</span><span class="p">,</span> <span class="s2">&quot;cell_id&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                <span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constant_subdomain_data</span><span class="p">[(</span><span class="n">sd</span><span class="p">,</span> <span class="s2">&quot;grid_dim&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span> <span class="o">*</span> <span class="n">ones</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constant_subdomain_data</span><span class="p">[(</span><span class="n">sd</span><span class="p">,</span> <span class="s2">&quot;subdomain_id&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">id</span> <span class="o">*</span> <span class="n">ones</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constant_subdomain_data</span><span class="p">[(</span><span class="n">sd</span><span class="p">,</span> <span class="s2">&quot;is_mortar&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">ones</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constant_subdomain_data</span><span class="p">[(</span><span class="n">sd</span><span class="p">,</span> <span class="s2">&quot;mortar_side&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">grids</span><span class="o">.</span><span class="n">mortar_grid</span><span class="o">.</span><span class="n">MortarSides</span><span class="o">.</span><span class="n">NONE_SIDE</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">ones</span>
            <span class="p">)</span>

        <span class="c1"># Define constant interface data related to the mesh</span>

        <span class="c1"># Initialize container for constant interface data</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_constant_interface_data&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Add mesh related, constant interface data by direct assignment.</span>
        <span class="k">for</span> <span class="n">intf</span><span class="p">,</span> <span class="n">intf_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span><span class="o">.</span><span class="n">interfaces</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

            <span class="c1"># Construct empty arrays for all extra interface data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="p">[(</span><span class="n">intf</span><span class="p">,</span> <span class="s2">&quot;grid_dim&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="p">[(</span><span class="n">intf</span><span class="p">,</span> <span class="s2">&quot;cell_id&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="p">[(</span><span class="n">intf</span><span class="p">,</span> <span class="s2">&quot;interface_id&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="p">[(</span><span class="n">intf</span><span class="p">,</span> <span class="s2">&quot;is_mortar&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="p">[(</span><span class="n">intf</span><span class="p">,</span> <span class="s2">&quot;mortar_side&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
            <span class="p">)</span>

            <span class="c1"># Initialize offset</span>
            <span class="n">side_grid_num_cells</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Assign extra interface data by collecting values on both sides.</span>
            <span class="k">for</span> <span class="n">side</span><span class="p">,</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">intf</span><span class="o">.</span><span class="n">side_grids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">num_cells</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

                <span class="c1"># Grid dimension of the mortar grid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="p">[(</span><span class="n">intf</span><span class="p">,</span> <span class="s2">&quot;grid_dim&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="p">[(</span><span class="n">intf</span><span class="p">,</span> <span class="s2">&quot;grid_dim&quot;</span><span class="p">)],</span> <span class="n">grid</span><span class="o">.</span><span class="n">dim</span> <span class="o">*</span> <span class="n">ones</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># Cell ids of the mortar grid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="p">[(</span><span class="n">intf</span><span class="p">,</span> <span class="s2">&quot;cell_id&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="p">[(</span><span class="n">intf</span><span class="p">,</span> <span class="s2">&quot;cell_id&quot;</span><span class="p">)],</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">num_cells</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="n">side_grid_num_cells</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># Grid edge number of each interface</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="p">[(</span><span class="n">intf</span><span class="p">,</span> <span class="s2">&quot;interface_id&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="p">[(</span><span class="n">intf</span><span class="p">,</span> <span class="s2">&quot;interface_id&quot;</span><span class="p">)],</span>
                        <span class="n">intf</span><span class="o">.</span><span class="n">id</span> <span class="o">*</span> <span class="n">ones</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># Whether the interface is mortar</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="p">[(</span><span class="n">intf</span><span class="p">,</span> <span class="s2">&quot;is_mortar&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="p">[(</span><span class="n">intf</span><span class="p">,</span> <span class="s2">&quot;is_mortar&quot;</span><span class="p">)],</span> <span class="n">ones</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># Side of the mortar</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="p">[(</span><span class="n">intf</span><span class="p">,</span> <span class="s2">&quot;mortar_side&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_constant_interface_data</span><span class="p">[(</span><span class="n">intf</span><span class="p">,</span> <span class="s2">&quot;mortar_side&quot;</span><span class="p">)],</span>
                        <span class="n">side</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">ones</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># Update offset</span>
                <span class="n">side_grid_num_cells</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_cells</span>

    <span class="k">def</span> <span class="nf">_export_data_vtu</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SubdomainData</span><span class="p">,</span> <span class="n">InterfaceData</span><span class="p">],</span>
        <span class="n">time_step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collect data associated to a single grid dimension</span>
<span class="sd">        and passing further to the final writing routine.</span>

<span class="sd">        For each fixed dimension, all subdomains of that dimension and the data</span>
<span class="sd">        related to those subdomains will be exported simultaneously.</span>
<span class="sd">        Analogously for interfaces.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            data (Union[SubdomainData, InterfaceData]): Subdomain or interface data.</span>
<span class="sd">            time_step (int): time_step to be used to append the file name.</span>
<span class="sd">            kwargs: Optional keyword arguments:</span>
<span class="sd">                &#39;interface_data&#39; (boolean) indicates whether data is associated to</span>
<span class="sd">                    an interface, default is False;</span>
<span class="sd">                &#39;constant_data&#39; (boolean) indicates whether data is treated as</span>
<span class="sd">                    constant in time, default is False.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: if keyword arguments contain unsupported keyword</span>
<span class="sd">            ValueError: if data provided for some but not all subdomains or interfaces</span>
<span class="sd">                of particular dimension.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check for optional keywords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interface_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;interface_data&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constant_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;constant_data&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;_export_data_vtu got unexpected keyword argument &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">popitem</span><span class="p">()[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c1"># Fetch the dimensions to be traversed. For subdomains, fetch the dimensions</span>
        <span class="c1"># of the available grids, and for interfaces fetch the dimensions of the available</span>
        <span class="c1"># mortar grids.</span>
        <span class="n">is_subdomain_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface_data</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span> <span class="k">if</span> <span class="n">is_subdomain_data</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m_dims</span>

        <span class="c1"># Define file name base</span>
        <span class="n">file_name_base</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file_name</span>
        <span class="c1"># Extend in case of constant data</span>
        <span class="n">file_name_base</span> <span class="o">+=</span> <span class="s2">&quot;_constant&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant_data</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="c1"># Extend in case of interface data</span>
        <span class="n">file_name_base</span> <span class="o">+=</span> <span class="s2">&quot;_mortar&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">interface_data</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="c1"># Append folder name to file name base</span>
        <span class="n">file_name_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_folder_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_folder_name</span><span class="p">,</span> <span class="n">file_name_base</span><span class="p">)</span>

        <span class="c1"># Collect unique keys, and for unique sorting, sort by alphabet</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">key</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]))</span>
        <span class="n">keys</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="c1"># Collect the data and extra data in a single stack for each dimension</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="c1"># Define the full file name</span>
            <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_file_name</span><span class="p">(</span><span class="n">file_name_base</span><span class="p">,</span> <span class="n">time_step</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>

            <span class="c1"># Get all geometrical entities of dimension dim:</span>
            <span class="k">if</span> <span class="n">is_subdomain_data</span><span class="p">:</span>
                <span class="n">entities</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">entities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span><span class="o">.</span><span class="n">interfaces</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span>

            <span class="c1"># Construct the list of fields represented on this dimension.</span>
            <span class="n">fields</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Field</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="c1"># Collect the values associated to all entities</span>
                <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">entities</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                        <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[(</span><span class="n">e</span><span class="p">,</span> <span class="n">key</span><span class="p">)])</span>

                <span class="c1"># Require data for all or none entities of that dimension.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">entities</span><span class="p">)]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;&quot;&quot;Insufficient amount of data provided for</span>
<span class="s2">                        key </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> on dimension </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">.&quot;&quot;&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># If data has been found, append data to list after stacking</span>
                <span class="c1"># values for different entities</span>
                <span class="k">if</span> <span class="n">values</span><span class="p">:</span>
                    <span class="n">field</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
                    <span class="n">fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>

            <span class="c1"># Print data for the particular dimension. Since geometric info</span>
            <span class="c1"># is required distinguish between subdomain and interface data.</span>
            <span class="n">meshio_geom</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meshio_geom</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">if</span> <span class="n">is_subdomain_data</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_meshio_geom</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">meshio_geom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">meshio_geom</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_export_mdg_pvd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">time_step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Routine to export to pvd format and collect all data scattered over</span>
<span class="sd">        several files for distinct grid dimensions.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            file_name (str): storage path for pvd file.</span>
<span class="sd">            time_step (int): used as appendix for the file name.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Open the file</span>
        <span class="n">o_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>

        <span class="c1"># Write VTK header to file</span>
        <span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;LittleEndian&quot;</span> <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s2">&quot;little&quot;</span> <span class="k">else</span> <span class="s2">&quot;BigEndian&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="s1">&#39; compressor=&quot;vtkZLibDataCompressor&quot;&#39;</span>
        <span class="n">header</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;&lt;?xml version=&quot;1.0&quot;?&gt;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="o">+</span> <span class="s1">&#39;&lt;VTKFile type=&quot;Collection&quot; version=&quot;0.1&quot; &#39;</span>
            <span class="o">+</span> <span class="s1">&#39;byte_order=&quot;</span><span class="si">%s</span><span class="s1">&quot;</span><span class="si">%s</span><span class="s1">&gt;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;&lt;Collection&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">o_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
        <span class="n">fm</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&lt;DataSet group=&quot;&quot; part=&quot;&quot; file=&quot;</span><span class="si">%s</span><span class="s1">&quot;/&gt;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="c1"># Subdomain data.</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_subdomain_data</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshio_geom</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">o_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">fm</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_file_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_file_name</span><span class="p">,</span> <span class="n">time_step</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>

        <span class="c1"># Interface data.</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m_dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_interface_data</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_meshio_geom</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">o_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="n">fm</span>
                    <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_file_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_file_name</span> <span class="o">+</span> <span class="s2">&quot;_mortar&quot;</span><span class="p">,</span> <span class="n">time_step</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="c1"># If constant data is exported to separate vtu files, also include</span>
        <span class="c1"># these here. The procedure is similar to the above, but the file names</span>
        <span class="c1"># incl. the relevant time step have to be adjusted.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_export_constants_separately</span><span class="p">:</span>

            <span class="c1"># Constant subdomain data.</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_has_constant_subdomain_data</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshio_geom</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="p">):</span>
                    <span class="n">o_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                        <span class="n">fm</span>
                        <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_file_name</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_file_name</span> <span class="o">+</span> <span class="s2">&quot;_constant&quot;</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_time_step_constant_data</span><span class="p">,</span>
                            <span class="n">dim</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

            <span class="c1"># Constant interface data.</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m_dims</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_has_constant_interface_data</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_meshio_geom</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="p">):</span>
                    <span class="n">o_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                        <span class="n">fm</span>
                        <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_file_name</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_file_name</span> <span class="o">+</span> <span class="s2">&quot;_constant_mortar&quot;</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_time_step_constant_data</span><span class="p">,</span>
                            <span class="n">dim</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

        <span class="n">o_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;/Collection&gt;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;&lt;/VTKFile&gt;&quot;</span><span class="p">)</span>
        <span class="n">o_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_update_meshio_geom</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manager for storing the grid information in meshio format.</span>

<span class="sd">        The internal variables meshio_geom and m_meshio_geom, storing all</span>
<span class="sd">        essential (mortar) grid information as points, connectivity and cell</span>
<span class="sd">        ids, are created and stored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Subdomains</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">:</span>
            <span class="c1"># Get subdomains with dimension dim</span>
            <span class="n">subdomains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span>
            <span class="c1"># Export and store</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshio_geom</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_export_grid</span><span class="p">(</span><span class="n">subdomains</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>

        <span class="c1"># Interfaces</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m_dims</span><span class="p">:</span>
            <span class="c1"># Extract the mortar grids for dimension dim, unrolled by sides</span>
            <span class="n">interface_side_grids</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">grid</span>
                <span class="k">for</span> <span class="n">intf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdg</span><span class="o">.</span><span class="n">interfaces</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">intf</span><span class="o">.</span><span class="n">side_grids</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">]</span>
            <span class="c1"># Export and store</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">m_meshio_geom</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_export_grid</span><span class="p">(</span><span class="n">interface_side_grids</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_export_grid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">grids</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">],</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Meshio_Geom</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper function to export grids of dimension dim. Calls the</span>
<span class="sd">        appropriate dimension specific export function.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            grids (Iterable[pp.Grid]): Subdomains of same dimension.</span>
<span class="sd">            dim (int): Dimension of the subdomains.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Meshio_Geom: Points, cells (storing the connectivity), and cell ids</span>
<span class="sd">            in correct meshio format.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError if dim not 0, 1, 2 or 3.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_export_grid_1d</span><span class="p">(</span><span class="n">grids</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_export_grid_2d</span><span class="p">(</span><span class="n">grids</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_export_grid_3d</span><span class="p">(</span><span class="n">grids</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown dimension </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_export_grid_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grids</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Meshio_Geom</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export the geometrical data (point coordinates) and connectivity</span>
<span class="sd">        information from the 1d PorePy grids to meshio.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            grids (Iterable[pp.Grid]): 1d grids.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Meshio_Geom: Points, 1d cells (storing the connectivity),</span>
<span class="sd">            and cell ids in correct meshio format.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># In 1d each cell is a line</span>
        <span class="n">cell_type</span> <span class="o">=</span> <span class="s2">&quot;line&quot;</span>

        <span class="c1"># Dictionary storing cell-&gt;nodes connectivity information</span>
        <span class="n">cell_to_nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">cell_type</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)}</span>

        <span class="c1"># Dictionary collecting all cell ids for each cell type.</span>
        <span class="c1"># Since each cell is a line, the list of cell ids is trivial</span>
        <span class="n">total_num_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">grid</span><span class="o">.</span><span class="n">num_cells</span> <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">]))</span>
        <span class="n">cell_id</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="n">cell_type</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total_num_cells</span><span class="p">)]}</span>

        <span class="c1"># Data structure for storing node coordinates of all 1d grids.</span>
        <span class="n">num_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">grid</span><span class="o">.</span><span class="n">num_nodes</span> <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">meshio_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_pts</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># Initialize offset. All data associated to 1d grids is stored in</span>
        <span class="c1"># the same vtu file, essentially using concatenation. To identify</span>
        <span class="c1"># each grid, keep track of number of nodes for each grid.</span>
        <span class="n">nodes_offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Loop over all 1d grids</span>
        <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">:</span>
            <span class="c1"># Store node coordinates</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">nodes_offset</span><span class="p">,</span> <span class="n">nodes_offset</span> <span class="o">+</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>
            <span class="n">meshio_pts</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">T</span>

            <span class="c1"># Lines are 1-simplices, and have a trivial connectivity.</span>
            <span class="n">cn_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simplex_cell_to_nodes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

            <span class="c1"># Add to previous connectivity information</span>
            <span class="n">cell_to_nodes</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">(</span><span class="n">cell_to_nodes</span><span class="p">[</span><span class="n">cell_type</span><span class="p">],</span> <span class="n">cn_indices</span> <span class="o">+</span> <span class="n">nodes_offset</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Update offsets</span>
            <span class="n">nodes_offset</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_nodes</span>

        <span class="c1"># Construct the meshio data structure</span>
        <span class="n">meshio_cells</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">meshio_cell_id</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># For each cell_type store the connectivity pattern cell_to_nodes for</span>
        <span class="c1"># the corresponding cells with ids from cell_id.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">cell_type</span><span class="p">,</span> <span class="n">cell_block</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cell_to_nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">meshio_cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meshio</span><span class="o">.</span><span class="n">CellBlock</span><span class="p">(</span><span class="n">cell_type</span><span class="p">,</span> <span class="n">cell_block</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)))</span>
            <span class="n">meshio_cell_id</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell_id</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]))</span>

        <span class="c1"># Return final meshio data: points, cell (connectivity), cell ids</span>
        <span class="k">return</span> <span class="n">Meshio_Geom</span><span class="p">(</span><span class="n">meshio_pts</span><span class="p">,</span> <span class="n">meshio_cells</span><span class="p">,</span> <span class="n">meshio_cell_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_simplex_cell_to_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">cells</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Determine cell to node connectivity for a general n-simplex mesh.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            n (int): dimension of the simplices in the grid.</span>
<span class="sd">            grid (pp.Grid): grid containing cells and nodes.</span>
<span class="sd">            cells (np.ndarray, optional): all n-simplex cells.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: cell to node connectivity array, in which for each row</span>
<span class="sd">            (associated to cells) all associated nodes are marked.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine cell-node ptr</span>
        <span class="n">cn_indptr</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">cell_nodes</span><span class="p">()</span><span class="o">.</span><span class="n">indptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cells</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">grid</span><span class="o">.</span><span class="n">cell_nodes</span><span class="p">()</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">cells</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Each n-simplex has n+1 nodes</span>
        <span class="n">num_nodes</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Collect the indptr to all nodes of the cell.</span>
        <span class="n">expanded_cn_indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">cn_indptr</span> <span class="o">+</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">)]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>

        <span class="c1"># Detect all corresponding nodes by applying the expanded mask to the indices</span>
        <span class="n">expanded_cn_indices</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">cell_nodes</span><span class="p">()</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">expanded_cn_indptr</span><span class="p">]</span>

        <span class="c1"># Convert to right format.</span>
        <span class="n">cn_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">expanded_cn_indices</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cn_indices</span>

    <span class="k">def</span> <span class="nf">_export_grid_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grids</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Meshio_Geom</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Export the geometrical data (point coordinates) and connectivity</span>
<span class="sd">        information from the 2d PorePy grids to meshio.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            grids: 2d grids.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Meshio_Geom: Points, 2d cells (storing the connectivity), and</span>
<span class="sd">            cell ids in correct meshio format.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Use standard names for simple object types: in this routine only triangle</span>
        <span class="c1"># and quad cells are treated in a special manner.</span>
        <span class="n">polygon_map</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;polygon3&quot;</span><span class="p">:</span> <span class="s2">&quot;triangle&quot;</span><span class="p">,</span> <span class="s2">&quot;polygon4&quot;</span><span class="p">:</span> <span class="s2">&quot;quad&quot;</span><span class="p">}</span>

        <span class="c1"># Dictionary storing cell-&gt;nodes connectivity information for all</span>
        <span class="c1"># cell types. For this, the nodes have to be sorted such that</span>
        <span class="c1"># they form a circular chain, describing the boundary of the cell.</span>
        <span class="n">cell_to_nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Dictionary collecting all cell ids for each cell type.</span>
        <span class="n">cell_id</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Data structure for storing node coordinates of all 2d grids.</span>
        <span class="n">num_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">grid</span><span class="o">.</span><span class="n">num_nodes</span> <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">])</span>
        <span class="n">meshio_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_pts</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># Initialize offsets. All data associated to 2d grids is stored in</span>
        <span class="c1"># the same vtu file, essentially using concatenation. To identify</span>
        <span class="c1"># each grid, keep track of number of nodes and cells for each grid.</span>
        <span class="n">nodes_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cell_offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Loop over all 2d grids</span>
        <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">:</span>

            <span class="c1"># Store node coordinates</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">nodes_offset</span><span class="p">,</span> <span class="n">nodes_offset</span> <span class="o">+</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>
            <span class="n">meshio_pts</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">T</span>

            <span class="c1"># Determine cell types based on number of nodes.</span>
            <span class="n">num_nodes_per_cell</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">cell_nodes</span><span class="p">()</span><span class="o">.</span><span class="n">getnnz</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Loop over all available cell types and group cells of one type.</span>
            <span class="n">g_cell_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">num_nodes_per_cell</span><span class="p">):</span>

                <span class="c1"># Define cell type; check if it coincides with a predefined cell type</span>
                <span class="n">cell_type</span> <span class="o">=</span> <span class="n">polygon_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;polygon</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;polygon</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Find all cells with n nodes, and store for later use</span>
                <span class="n">cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">num_nodes_per_cell</span> <span class="o">==</span> <span class="n">n</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">g_cell_map</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span>

                <span class="c1"># Store cell ids in global container; init if entry not yet established</span>
                <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cell_id</span><span class="p">:</span>
                    <span class="n">cell_id</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># Add offset taking into account previous grids</span>
                <span class="n">cell_id</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">cells</span> <span class="o">+</span> <span class="n">cell_offset</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="c1"># Determine cell-node connectivity for each cell type and all cells.</span>
            <span class="c1"># Treat triangle, quad and polygonal cells differently</span>
            <span class="c1"># aiming for optimized performance.</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">num_nodes_per_cell</span><span class="p">):</span>

                <span class="c1"># Define the cell type</span>
                <span class="n">cell_type</span> <span class="o">=</span> <span class="n">polygon_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;polygon</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;polygon</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Check if cell_type already defined in cell_to_nodes, otherwise construct</span>
                <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cell_to_nodes</span><span class="p">:</span>
                    <span class="n">cell_to_nodes</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

                <span class="c1"># Special case: Triangle cells, i.e., n=3.</span>
                <span class="k">if</span> <span class="n">cell_type</span> <span class="o">==</span> <span class="s2">&quot;triangle&quot;</span><span class="p">:</span>

                    <span class="c1"># Triangles are simplices and have a trivial connectivity.</span>

                    <span class="c1"># Fetch triangle cells</span>
                    <span class="n">cells</span> <span class="o">=</span> <span class="n">g_cell_map</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span>
                    <span class="c1"># Determine the trivial connectivity - triangles are 2-simplices.</span>
                    <span class="n">cn_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simplex_cell_to_nodes</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">cells</span><span class="p">)</span>

                <span class="c1"># Quad and polygon cells.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># For quads/polygons, grid.cell_nodes cannot be blindly used as for</span>
                    <span class="c1"># triangles, since the ordering of the nodes may define a cell of</span>
                    <span class="c1"># the type (here specific for quads)</span>
                    <span class="c1"># x--x and not x--x</span>
                    <span class="c1">#  \/          |  |</span>
                    <span class="c1">#  /\          |  |</span>
                    <span class="c1"># x--x         x--x .</span>
                    <span class="c1"># Therefore, use both grid.cell_faces and grid.face_nodes to make use of</span>
                    <span class="c1"># face information and sort those to retrieve the correct connectivity.</span>

                    <span class="c1"># Strategy: Collect all cell nodes including their connectivity in a</span>
                    <span class="c1"># matrix of double num cell size. The goal will be to gather starting</span>
                    <span class="c1"># and end points for all faces of each cell, sort those faces, such that</span>
                    <span class="c1"># they form a circular graph, and then choose the resulting starting</span>
                    <span class="c1"># points of all faces to define the connectivity.</span>

                    <span class="c1"># Fetch corresponding cells</span>
                    <span class="n">cells</span> <span class="o">=</span> <span class="n">g_cell_map</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span>
                    <span class="c1"># Determine all faces of all cells. Use an analogous approach as used to</span>
                    <span class="c1"># determine all cell nodes for triangle cells. And use that a polygon with</span>
                    <span class="c1"># n nodes has also n faces.</span>
                    <span class="n">cf_indptr</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">cell_faces</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">cells</span><span class="p">]</span>
                    <span class="n">expanded_cf_indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">cf_indptr</span> <span class="o">+</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
                    <span class="n">cf_indices</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">cell_faces</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">expanded_cf_indptr</span><span class="p">]</span>

                    <span class="c1"># Determine the associated (two) nodes of all faces for each cell.</span>
                    <span class="n">fn_indptr</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">face_nodes</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">cf_indices</span><span class="p">]</span>
                    <span class="c1"># Extract nodes for first and second node of each face; reshape such</span>
                    <span class="c1"># that all first nodes of all faces for each cell are stored in one row,</span>
                    <span class="c1"># i.e., end up with an array of size num_cells (for this cell type) x n.</span>
                    <span class="n">cfn_indices</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">grid</span><span class="o">.</span><span class="n">face_nodes</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">fn_indptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="c1"># Group first and second nodes, with alternating order of rows.</span>
                    <span class="c1"># By this, each cell is represented by two rows. The first and second</span>
                    <span class="c1"># rows contain first and second nodes of faces. And each column stands</span>
                    <span class="c1"># for one face.</span>
                    <span class="n">cfn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">cfn_indices</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

                    <span class="c1"># Sort faces for each cell such that they form a chain. Use a function</span>
                    <span class="c1"># compiled with Numba. This step is the bottleneck of this routine.</span>
                    <span class="n">cfn</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">sort_points</span><span class="o">.</span><span class="n">sort_multiple_point_pairs</span><span class="p">(</span><span class="n">cfn</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                        <span class="nb">int</span>
                    <span class="p">)</span>

                    <span class="c1"># For each cell pick the sorted nodes such that they form a chain</span>
                    <span class="c1"># and thereby define the connectivity, i.e., skip every second row.</span>
                    <span class="n">cn_indices</span> <span class="o">=</span> <span class="n">cfn</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>

                <span class="c1"># Add offset to account for previous grids, and store</span>
                <span class="n">cell_to_nodes</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">cell_to_nodes</span><span class="p">[</span><span class="n">cell_type</span><span class="p">],</span> <span class="n">cn_indices</span> <span class="o">+</span> <span class="n">nodes_offset</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># Update offsets</span>
            <span class="n">nodes_offset</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_nodes</span>
            <span class="n">cell_offset</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_cells</span>

        <span class="c1"># Construct the meshio data structure</span>
        <span class="n">meshio_cells</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">meshio_cell_id</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># For each cell_type store the connectivity pattern cell_to_nodes for</span>
        <span class="c1"># the corresponding cells with ids from cell_id.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">cell_type</span><span class="p">,</span> <span class="n">cell_block</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cell_to_nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Meshio requires the keyword &quot;polygon&quot; for general polygons.</span>
            <span class="c1"># Thus, remove the number of nodes associated to polygons.</span>
            <span class="n">cell_type_meshio_format</span> <span class="o">=</span> <span class="s2">&quot;polygon&quot;</span> <span class="k">if</span> <span class="s2">&quot;polygon&quot;</span> <span class="ow">in</span> <span class="n">cell_type</span> <span class="k">else</span> <span class="n">cell_type</span>
            <span class="n">meshio_cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">meshio</span><span class="o">.</span><span class="n">CellBlock</span><span class="p">(</span><span class="n">cell_type_meshio_format</span><span class="p">,</span> <span class="n">cell_block</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">meshio_cell_id</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell_id</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]))</span>

        <span class="c1"># Return final meshio data: points, cell (connectivity), cell ids</span>
        <span class="k">return</span> <span class="n">Meshio_Geom</span><span class="p">(</span><span class="n">meshio_pts</span><span class="p">,</span> <span class="n">meshio_cells</span><span class="p">,</span> <span class="n">meshio_cell_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_export_grid_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grids</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Meshio_Geom</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Export the geometrical data (point coordinates) and connectivity</span>
<span class="sd">        information from 3d PorePy grids to meshio.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            grids: 3d grids.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Meshio_Geom: Points, 3d cells (storing the connectivity), and</span>
<span class="sd">            cell ids in correct meshio format.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Three different cell types will be distinguished: Tetrahedra, hexahedra,</span>
        <span class="c1"># and general polyhedra. meshio does not allow for a mix of cell types</span>
        <span class="c1"># in 3d within a single grid (and we export all 3d grids at once). Thus,</span>
        <span class="c1"># if the 3d grids contains cells of varying types, all cells will be cast</span>
        <span class="c1"># as polyhedra.</span>

        <span class="c1"># Determine the cell types present among all grids.</span>
        <span class="n">cell_types</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">:</span>

            <span class="c1"># The number of faces per cell wil be later used to determining</span>
            <span class="c1"># the cell types</span>
            <span class="n">num_faces_per_cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">cell_faces</span><span class="o">.</span><span class="n">getnnz</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">num_faces_per_cell</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">num_faces_per_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">cell_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;tetra&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">6</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">CartGrid</span><span class="p">):</span>
                    <span class="n">cell_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;hexahedron&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cell_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;polyhedron&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cell_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;polyhedron&quot;</span><span class="p">)</span>

        <span class="c1"># Use dedicated export for each grid type</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="s2">&quot;tetra&quot;</span> <span class="ow">in</span> <span class="n">cell_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_export_simplex_3d</span><span class="p">(</span><span class="n">grids</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="s2">&quot;hexahedron&quot;</span> <span class="ow">in</span> <span class="n">cell_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_export_hexahedron_3d</span><span class="p">(</span><span class="n">grids</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_export_polyhedron_3d</span><span class="p">(</span><span class="n">grids</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_export_simplex_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grids</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Meshio_Geom</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Export the geometrical data (point coordinates) and connectivity</span>
<span class="sd">        information from 3d PorePy simplex grids to meshio.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            grids (Iterable[pp.Grid]): 3d simplex grids.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Meshio_Geom: Points, 3d cells (storing the connectivity), and</span>
<span class="sd">            cell ids in correct meshio format.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For the special meshio geometric type &quot;tetra&quot;, cell-&gt;nodes will</span>
        <span class="c1"># be used to store connectivity information. Each simplex has 4 nodes.</span>
        <span class="n">cell_to_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Dictionary collecting all cell ids for each cell type.</span>
        <span class="n">cell_id</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Data structure for storing node coordinates of all 3d grids.</span>
        <span class="n">num_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">grid</span><span class="o">.</span><span class="n">num_nodes</span> <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">])</span>
        <span class="n">meshio_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_pts</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># Initialize offsets. All data associated to 3d grids is stored in</span>
        <span class="c1"># the same vtu file, essentially using concatenation. To identify</span>
        <span class="c1"># each grid, keep track of number of nodes and cells for each grid.</span>
        <span class="n">nodes_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cell_offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Treat each 3d grid separately.</span>
        <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">:</span>
            <span class="c1"># Store node coordinates</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">nodes_offset</span><span class="p">,</span> <span class="n">nodes_offset</span> <span class="o">+</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>
            <span class="n">meshio_pts</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">T</span>

            <span class="c1"># Identify all cells as tetrahedra.</span>
            <span class="n">cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">num_cells</span><span class="p">)</span>

            <span class="c1"># Add offset taking into account previous grids</span>
            <span class="n">cell_id</span> <span class="o">+=</span> <span class="p">(</span><span class="n">cells</span> <span class="o">+</span> <span class="n">cell_offset</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="c1"># Determine local connectivity for all cells. Simplices are invariant</span>
            <span class="c1"># under permutations. Thus, no specific ordering of nodes is required.</span>
            <span class="c1"># Tetrahedra are essentially 3-simplices.</span>
            <span class="n">cn_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simplex_cell_to_nodes</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">cells</span><span class="p">)</span>

            <span class="c1"># Store cell-node connectivity, and add offset taking into account</span>
            <span class="c1"># previous grids</span>
            <span class="n">cell_to_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">cell_to_nodes</span><span class="p">,</span> <span class="n">cn_indices</span> <span class="o">+</span> <span class="n">nodes_offset</span><span class="p">))</span>

            <span class="c1"># Update offset</span>
            <span class="n">nodes_offset</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_nodes</span>
            <span class="n">cell_offset</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_cells</span>

        <span class="c1"># Initialize the meshio data structure for the connectivity and cell ids.</span>
        <span class="c1"># There is only one cell type, and meshio expects iterable data structs.</span>
        <span class="n">meshio_cells</span> <span class="o">=</span> <span class="p">[</span><span class="n">meshio</span><span class="o">.</span><span class="n">CellBlock</span><span class="p">(</span><span class="s2">&quot;tetra&quot;</span><span class="p">,</span> <span class="n">cell_to_nodes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))]</span>
        <span class="n">meshio_cell_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell_id</span><span class="p">)]</span>

        <span class="c1"># Return final meshio data: points, cell (connectivity), cell ids</span>
        <span class="k">return</span> <span class="n">Meshio_Geom</span><span class="p">(</span><span class="n">meshio_pts</span><span class="p">,</span> <span class="n">meshio_cells</span><span class="p">,</span> <span class="n">meshio_cell_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_export_hexahedron_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grids</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Meshio_Geom</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Export the geometrical data (point coordinates) and connectivity</span>
<span class="sd">        information from 3d PorePy hexahedron grids to meshio.</span>

<span class="sd">        NOTE: Optimally, a StructuredGrid would be exported in this case.</span>
<span class="sd">        However, meshio does solely handle unstructured grids and cannot</span>
<span class="sd">        for instance write to *.vtr format.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            grids (Iterable[pp.Grid]): 3d hexahedron grids.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Meshio_Geom: Points, 3d cells (storing the connectivity), and</span>
<span class="sd">            cell ids in correct meshio format.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For the special meshio geometric type &quot;hexahedron&quot;, cell-&gt;nodes will</span>
        <span class="c1"># be used to store connectivity information. Each hexahedron has 8 nodes.</span>
        <span class="n">cell_to_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Dictionary collecting all cell ids for each cell type.</span>
        <span class="n">cell_id</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Data structure for storing node coordinates of all 3d grids.</span>
        <span class="n">num_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">grid</span><span class="o">.</span><span class="n">num_nodes</span> <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">])</span>
        <span class="n">meshio_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_pts</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># Initialize offsets. Required taking into account multiple 3d grids.</span>
        <span class="n">nodes_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cell_offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Treat each 3d grid separately.</span>
        <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">:</span>
            <span class="c1"># Store node coordinates</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">nodes_offset</span><span class="p">,</span> <span class="n">nodes_offset</span> <span class="o">+</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>
            <span class="n">meshio_pts</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">T</span>

            <span class="c1"># Identify all cells as tetrahedra.</span>
            <span class="n">cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">num_cells</span><span class="p">)</span>

            <span class="c1"># Add offset taking into account previous grids</span>
            <span class="n">cell_id</span> <span class="o">+=</span> <span class="p">(</span><span class="n">cells</span> <span class="o">+</span> <span class="n">cell_offset</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="c1"># Determine local connectivity for all cells. Simplices are invariant</span>
            <span class="c1"># under permutations. Thus, no specific ordering of nodes is required.</span>

            <span class="c1"># After all, the procedure is fairly similar to the treatment of</span>
            <span class="c1"># tetra cells. Most of the following code is analogous to</span>
            <span class="c1"># _simplex_cell_to_nodes(). However, for hexahedron cells the order</span>
            <span class="c1"># of the nodes is important and has to be adjusted. Based on the</span>
            <span class="c1"># specific definition of TensorGrids however, the node numbering</span>
            <span class="c1"># can be hardcoded, which results in better performance compared</span>
            <span class="c1"># to a modular procedure.</span>

            <span class="c1"># Determine cell-node ptr</span>
            <span class="n">cn_indptr</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">grid</span><span class="o">.</span><span class="n">cell_nodes</span><span class="p">()</span><span class="o">.</span><span class="n">indptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">cells</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="n">grid</span><span class="o">.</span><span class="n">cell_nodes</span><span class="p">()</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">cells</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Collect the indptr to all nodes of the cell;</span>
            <span class="c1"># each n-simplex cell contains n nodes</span>
            <span class="n">expanded_cn_indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">cn_indptr</span> <span class="o">+</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Detect all corresponding nodes by applying the expanded mask to indices</span>
            <span class="n">expanded_cn_indices</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">cell_nodes</span><span class="p">()</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="n">expanded_cn_indptr</span><span class="p">]</span>

            <span class="c1"># Convert to right format.</span>
            <span class="n">cn_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">expanded_cn_indices</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>

            <span class="c1"># Reorder nodes to comply with the node numbering convention of meshio</span>
            <span class="c1"># regarding hexahedron cells.</span>
            <span class="n">cn_indices</span> <span class="o">=</span> <span class="n">cn_indices</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span>

            <span class="c1"># Test whether the hard-coded numbering really defines a hexahedron.</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_test_hex_meshio_format</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">cn_indices</span><span class="p">)</span>

            <span class="c1"># Store cell-node connectivity, and add offset taking into account</span>
            <span class="c1"># previous grids</span>
            <span class="n">cell_to_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">cell_to_nodes</span><span class="p">,</span> <span class="n">cn_indices</span> <span class="o">+</span> <span class="n">nodes_offset</span><span class="p">))</span>

            <span class="c1"># Update offset</span>
            <span class="n">nodes_offset</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_nodes</span>
            <span class="n">cell_offset</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_cells</span>

        <span class="c1"># Initialize the meshio data structure for the connectivity and cell ids.</span>
        <span class="c1"># There is only one cell type, and meshio expects iterable data structs.</span>
        <span class="n">meshio_cells</span> <span class="o">=</span> <span class="p">[</span><span class="n">meshio</span><span class="o">.</span><span class="n">CellBlock</span><span class="p">(</span><span class="s2">&quot;hexahedron&quot;</span><span class="p">,</span> <span class="n">cell_to_nodes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))]</span>
        <span class="n">meshio_cell_id</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell_id</span><span class="p">)]</span>

        <span class="c1"># Return final meshio data: points, cell (connectivity), cell ids</span>
        <span class="k">return</span> <span class="n">Meshio_Geom</span><span class="p">(</span><span class="n">meshio_pts</span><span class="p">,</span> <span class="n">meshio_cells</span><span class="p">,</span> <span class="n">meshio_cell_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_test_hex_meshio_format</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">cn_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Test whether the node numbering for each cell complies</span>
<span class="sd">        with the hardcoded numbering used by meshio, cf. documentation</span>
<span class="sd">        of meshio.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ImportError if numba is not installed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">numba</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;Numba not available on the system&quot;</span><span class="p">)</span>

        <span class="c1"># Just in time compilation</span>
        <span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="s2">&quot;b1(f8[:,:], i4[:,:])&quot;</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">_function_to_compile</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">cn_indices</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Test whether the node numbering for each cell complies</span>
<span class="sd">            with the hardcoded numbering used by meshio, cf. documentation</span>
<span class="sd">            of meshio.</span>

<span class="sd">            For this, fetch three potential sides of the hex and</span>
<span class="sd">            test whether they lie circular chain within a plane.</span>
<span class="sd">            Here, the test is successful, if the node sets [0,1,2,3],</span>
<span class="sd">            [4,5,6,7], and [0,1,5,4] define planes.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># Assume initially correct format</span>
            <span class="n">correct_format</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Test each cell separately</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numba</span><span class="o">.</span><span class="n">prange</span><span class="p">(</span><span class="n">cn_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

                <span class="c1"># Assume initially that the cell is a hex</span>
                <span class="n">is_hex</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># Visit three node sets and check whether</span>
                <span class="c1"># they define feasible sides of a hex.</span>
                <span class="c1"># FIXME use shorter code of the following style - note: the order in the</span>
                <span class="c1"># array is not the same troubling numba</span>
                <span class="c1"># global_ind_0 = cn_indices[i, 0:4]</span>
                <span class="c1"># global_ind_1 = cn_indices[i, 4:8]</span>
                <span class="n">global_ind_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">cn_indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                        <span class="n">cn_indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="n">cn_indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                        <span class="n">cn_indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="n">global_ind_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">cn_indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
                        <span class="n">cn_indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
                        <span class="n">cn_indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
                        <span class="n">cn_indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="n">global_ind_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">cn_indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                        <span class="n">cn_indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="n">cn_indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
                        <span class="n">cn_indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
                    <span class="p">]</span>
                <span class="p">)</span>

                <span class="c1"># Check each side separately</span>
                <span class="k">for</span> <span class="n">global_ind</span> <span class="ow">in</span> <span class="p">[</span><span class="n">global_ind_0</span><span class="p">,</span> <span class="n">global_ind_1</span><span class="p">,</span> <span class="n">global_ind_2</span><span class="p">]:</span>

                    <span class="c1"># Fetch coordinates associated to the four nodes</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[:,</span> <span class="n">global_ind</span><span class="p">]</span>

                    <span class="c1"># Check orientation by determining normalized cross products</span>
                    <span class="c1"># of all two consecutive connections.</span>
                    <span class="n">normalized_cross</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                        <span class="n">cross</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span>
                            <span class="n">coords</span><span class="p">[:,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span>
                            <span class="n">coords</span><span class="p">[:,</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[:,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="p">)</span>
                        <span class="n">normalized_cross</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cross</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cross</span><span class="p">)</span>

                    <span class="c1"># Consider the points lying in a plane when each connection</span>
                    <span class="c1"># produces the same normalized cross product.</span>
                    <span class="n">is_plane</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">normalized_cross</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

                    <span class="c1"># Combine with the remaining sides</span>
                    <span class="n">is_hex</span> <span class="o">=</span> <span class="n">is_hex</span> <span class="ow">and</span> <span class="n">is_plane</span>

                <span class="c1"># Combine the results for all cells</span>
                <span class="n">correct_format</span> <span class="o">=</span> <span class="n">correct_format</span> <span class="ow">and</span> <span class="n">is_hex</span>

            <span class="k">return</span> <span class="n">correct_format</span>

        <span class="k">return</span> <span class="n">_function_to_compile</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">cn_indices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_export_polyhedron_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grids</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Meshio_Geom</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Export the geometrical data (point coordinates) and connectivity</span>
<span class="sd">        information from 3d PorePy polyhedron grids to meshio.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            grids: 3d polyhedron grids.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Meshio_Geom: Points, 3d cells (storing the connectivity), and</span>
<span class="sd">            cell ids in correct meshio format.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For the general geometric type &quot;polyhedron&quot;, cell-&gt;faces-&gt;nodes will</span>
        <span class="c1"># be used to store connectivity information, which can become significantly</span>
        <span class="c1"># larger than cell-&gt;nodes information used for special type grids.</span>
        <span class="n">cell_to_faces</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Dictionary collecting all cell ids for each cell type.</span>
        <span class="n">cell_id</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Data structure for storing node coordinates of all 3d grids.</span>
        <span class="n">num_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">grid</span><span class="o">.</span><span class="n">num_nodes</span> <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">])</span>
        <span class="n">meshio_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_pts</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># Initialize offsets. Required taking into account multiple 3d grids.</span>
        <span class="n">nodes_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cell_offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Treat each 3d grid separately.</span>
        <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">:</span>

            <span class="c1"># Store node coordinates</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">nodes_offset</span><span class="p">,</span> <span class="n">nodes_offset</span> <span class="o">+</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>
            <span class="n">meshio_pts</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">T</span>

            <span class="c1"># Categorize all polyhedron cells by their number of nodes.</span>
            <span class="c1"># Each category will be treated separately allowing for using</span>
            <span class="c1"># fitting datastructures.</span>
            <span class="n">num_nodes_per_cell</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">cell_nodes</span><span class="p">()</span><span class="o">.</span><span class="n">getnnz</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">g_cell_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">num_nodes_per_cell</span><span class="p">):</span>

                <span class="n">cell_type</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;polyhedron</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span>

                <span class="c1"># Find all cells with n faces, and store for later use</span>
                <span class="n">cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">num_nodes_per_cell</span> <span class="o">==</span> <span class="n">n</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">g_cell_map</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">cells</span>

                <span class="c1"># Store cell ids in global container; init if entry not yet established</span>
                <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cell_id</span><span class="p">:</span>
                    <span class="n">cell_id</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># Add offset taking into account previous grids</span>
                <span class="n">cell_id</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">cells</span> <span class="o">+</span> <span class="n">cell_offset</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="c1"># Determine local connectivity for all cells. Due to different</span>
            <span class="c1"># treatment of special and general cell types and to conform</span>
            <span class="c1"># with array sizes (for polyhedra), treat each cell type</span>
            <span class="c1"># separately.</span>
            <span class="k">for</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="n">g_cell_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="c1"># The general strategy is to define the connectivity as cell-face-nodes</span>
                <span class="c1"># information, where the faces are defined by nodes. Hence, this</span>
                <span class="c1"># information is significantly larger than the info provided for</span>
                <span class="c1"># tetra cells. Here, we make use of the fact that grid.face_nodes</span>
                <span class="c1"># provides nodes ordered wrt. the right-hand rule.</span>

                <span class="c1"># Fetch cells with n faces</span>
                <span class="n">cells</span> <span class="o">=</span> <span class="n">g_cell_map</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span>

                <span class="c1"># Store shortcuts to cell-face and face-node information</span>
                <span class="n">cf_indptr</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">cell_faces</span><span class="o">.</span><span class="n">indptr</span>
                <span class="n">cf_indices</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">cell_faces</span><span class="o">.</span><span class="n">indices</span>
                <span class="n">fn_indptr</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">face_nodes</span><span class="o">.</span><span class="n">indptr</span>
                <span class="n">fn_indices</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">face_nodes</span><span class="o">.</span><span class="n">indices</span>

                <span class="c1"># Determine the cell-face connectivity with faces described by their</span>
                <span class="c1"># nodes ordered such that they form a chain and are identified by the</span>
                <span class="c1"># face boundary. The final data format is a list[list[np.ndarray]].</span>
                <span class="c1"># The outer list loops over all cells. Each cell entry contains a</span>
                <span class="c1"># list over faces, and each face entry is given by the face nodes.</span>
                <span class="k">if</span> <span class="n">cell_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cell_to_faces</span><span class="p">:</span>
                    <span class="n">cell_to_faces</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">cell_to_faces</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span>
                    <span class="p">[</span>
                        <span class="n">fn_indices</span><span class="p">[</span><span class="n">fn_indptr</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="p">:</span> <span class="n">fn_indptr</span><span class="p">[</span><span class="n">f</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>  <span class="c1"># nodes</span>
                        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">cf_indices</span><span class="p">[</span><span class="n">cf_indptr</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="p">:</span> <span class="n">cf_indptr</span><span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>  <span class="c1"># faces</span>
                    <span class="p">]</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cells</span>  <span class="c1"># cells</span>
                <span class="p">]</span>

            <span class="c1"># Update offset</span>
            <span class="n">nodes_offset</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_nodes</span>
            <span class="n">cell_offset</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_cells</span>

        <span class="c1"># Initialize the meshio data structure for the connectivity and cell ids.</span>
        <span class="n">meshio_cells</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">meshio_cell_id</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># Store the cells in meshio format</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">cell_type</span><span class="p">,</span> <span class="n">cell_block</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cell_to_faces</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Adapt the block number taking into account of previous cell types.</span>
            <span class="n">meshio_cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">meshio</span><span class="o">.</span><span class="n">CellBlock</span><span class="p">(</span><span class="n">cell_type</span><span class="p">,</span> <span class="n">cell_block</span><span class="p">))</span>
            <span class="n">meshio_cell_id</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell_id</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]))</span>

        <span class="c1"># Return final meshio data: points, cell (connectivity), cell ids</span>
        <span class="k">return</span> <span class="n">Meshio_Geom</span><span class="p">(</span><span class="n">meshio_pts</span><span class="p">,</span> <span class="n">meshio_cells</span><span class="p">,</span> <span class="n">meshio_cell_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_write</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">fields</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Field</span><span class="p">],</span> <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">meshio_geom</span><span class="p">:</span> <span class="n">Meshio_Geom</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Interface to meshio for exporting cell data.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            fields: fields which shall be exported</span>
<span class="sd">            file_name: name of final file of export.</span>
<span class="sd">            meshio_geom: Namedtuple of points, connectivity information, and cell ids in</span>
<span class="sd">                meshio format (for a single dimension).</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError if some data has wrong dimension.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize empty cell data dictionary</span>
        <span class="n">cell_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Split the data for each group of geometrically uniform cells</span>
        <span class="c1"># Utilize meshio_geom for this.</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>

            <span class="c1"># Although technically possible, as implemented, field.values should never be None.</span>
            <span class="k">assert</span> <span class="n">field</span><span class="o">.</span><span class="n">values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="c1"># For each field create a sub-vector for each geometrically uniform group of cells</span>
            <span class="n">cell_data</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

            <span class="c1"># Fill up the data</span>
            <span class="k">for</span> <span class="n">ids</span> <span class="ow">in</span> <span class="n">meshio_geom</span><span class="o">.</span><span class="n">cell_ids</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">cell_data</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">ids</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">field</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">cell_data</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="n">ids</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data values have wrong dimension&quot;</span><span class="p">)</span>

        <span class="c1"># Create the meshio object</span>
        <span class="n">meshio_grid_to_export</span> <span class="o">=</span> <span class="n">meshio</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span>
            <span class="n">meshio_geom</span><span class="o">.</span><span class="n">pts</span><span class="p">,</span> <span class="n">meshio_geom</span><span class="o">.</span><span class="n">connectivity</span><span class="p">,</span> <span class="n">cell_data</span><span class="o">=</span><span class="n">cell_data</span>
        <span class="p">)</span>

        <span class="c1"># Write mesh information and data to VTK format.</span>
        <span class="n">meshio</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">meshio_grid_to_export</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_binary</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_append_folder_name</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Auxiliary method setting up potentially non-existent folder structure and</span>
<span class="sd">        setting up a path for exporting.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            folder_name: name of the folder.</span>
<span class="sd">            name: prefix of the name of the files to be written.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Complete path to the files to be written.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If no folder_name is prescribed, the files will be stored in the</span>
        <span class="c1"># working directory.</span>
        <span class="k">if</span> <span class="n">folder_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span>

        <span class="c1"># Set up folder structure if not existent.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">folder_name</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">folder_name</span><span class="p">)</span>

        <span class="c1"># Return full path.</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_file_name</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">time_step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">extension</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;.vtu&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Auxiliary method to setting up file name.</span>

<span class="sd">        The final name is built as combination of a prescribed prefix,</span>
<span class="sd">        and possibly the dimension of underlying grid and time (step)</span>
<span class="sd">        the related data is associated to.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            file_name: Prefix of the name of file to be exported.</span>
<span class="sd">            time_step: Time or time step (index).</span>
<span class="sd">            dim: Dimension of the exported grid.</span>
<span class="sd">            extension: Extension of the file, typically file ending defining the format.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Complete name of file.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Define non-empty time step extension including zero padding.</span>
        <span class="n">time_extension</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">time_step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">time_step</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_padding</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Define non-empty dim extension</span>
        <span class="n">dim_extension</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

        <span class="c1"># Combine prefix and extensions to define the complete name</span>
        <span class="k">return</span> <span class="n">file_name</span> <span class="o">+</span> <span class="n">dim_extension</span> <span class="o">+</span> <span class="n">time_extension</span> <span class="o">+</span> <span class="n">extension</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022 UiB Center for Modeling of Coupled Subsurface Dynamics, GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007..</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>