<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>porepy.models.contact_mechanics_model &mdash; PorePy 1.6.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="canonical" href="https://pmgbergen.github.io/porepy/_modules/porepy/models/contact_mechanics_model.html" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >
            <a href="../../../index.html" class="icon icon-home"> PorePy
          </a>
              <div class="version">
                1.6.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docsrc/porepy/porepy.html">porepy package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.html">porepy.fracs package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture.html">porepy.fracs.fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_importer.html">porepy.fracs.fracture_importer module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_network_2d.html">porepy.fracs.fracture_network_2d module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html">porepy.fracs.fracture_network_3d module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.gmsh_interface.html">porepy.fracs.gmsh_interface module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.line_fracture.html">porepy.fracs.line_fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.meshing.html">porepy.fracs.meshing module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.msh_2_grid.html">porepy.fracs.msh_2_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.non_conforming.html">porepy.fracs.non_conforming module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.plane_fracture.html">porepy.fracs.plane_fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.simplex.html">porepy.fracs.simplex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.split_grid.html">porepy.fracs.split_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.structured.html">porepy.fracs.structured module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.tools.html">porepy.fracs.tools module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.utils.html">porepy.fracs.utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.wells_3d.html">porepy.fracs.wells_3d module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.html">porepy.geometry package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.bounding_box.html">porepy.geometry.bounding_box module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.constrain_geometry.html">porepy.geometry.constrain_geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.distances.html">porepy.geometry.distances module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.geometry_property_checks.html">porepy.geometry.geometry_property_checks module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.half_space.html">porepy.geometry.half_space module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.intersections.html">porepy.geometry.intersections module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.map_geometry.html">porepy.geometry.map_geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.point_in_polyhedron_test.html">porepy.geometry.point_in_polyhedron_test module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.html">porepy.grids package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.html">porepy.grids.standard_grids package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.md_grids_2d.html">porepy.grids.standard_grids.md_grids_2d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.md_grids_3d.html">porepy.grids.standard_grids.md_grids_3d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.utils.html">porepy.grids.standard_grids.utils module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.boundary_grid.html">porepy.grids.boundary_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.coarsening.html">porepy.grids.coarsening module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.grid.html">porepy.grids.grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.grid_extrusion.html">porepy.grids.grid_extrusion module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.match_grids.html">porepy.grids.match_grids module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.md_grid.html">porepy.grids.md_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.mortar_grid.html">porepy.grids.mortar_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.partition.html">porepy.grids.partition module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.point_grid.html">porepy.grids.point_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.refinement.html">porepy.grids.refinement module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.simplex.html">porepy.grids.simplex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.structured.html">porepy.grids.structured module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.html">porepy.models package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.html">porepy.models.verification_setups package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.manu_flow_comp_frac.html">porepy.models.verification_setups.manu_flow_comp_frac module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.manu_flow_incomp_frac.html">porepy.models.verification_setups.manu_flow_incomp_frac module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.manu_poromech_nofrac.html">porepy.models.verification_setups.manu_poromech_nofrac module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.verifications_utils.html">porepy.models.verification_setups.verifications_utils module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.abstract_equations.html">porepy.models.abstract_equations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.abstract_model.html">porepy.models.abstract_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.constitutive_laws.html">porepy.models.constitutive_laws module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.contact_mechanics_biot_model.html">porepy.models.contact_mechanics_biot_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.contact_mechanics_model.html">porepy.models.contact_mechanics_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.energy_balance.html">porepy.models.energy_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.fluid_mass_balance.html">porepy.models.fluid_mass_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.geometry.html">porepy.models.geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.incompressible_flow_model.html">porepy.models.incompressible_flow_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.mass_and_energy_balance.html">porepy.models.mass_and_energy_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.material_constants.html">porepy.models.material_constants module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.momentum_balance.html">porepy.models.momentum_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.poromechanics.html">porepy.models.poromechanics module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.run_models.html">porepy.models.run_models module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.slightly_compressible_flow_model.html">porepy.models.slightly_compressible_flow_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.solution_strategy.html">porepy.models.solution_strategy module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.thermoporomechanics.html">porepy.models.thermoporomechanics module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.thm_model.html">porepy.models.thm_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.units.html">porepy.models.units module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.html">porepy.numerics package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.html">porepy.numerics.ad package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.discretizations.html">porepy.numerics.ad.discretizations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.equation_manager.html">porepy.numerics.ad.equation_manager module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.equation_system.html">porepy.numerics.ad.equation_system module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.forward_mode.html">porepy.numerics.ad.forward_mode module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.functions.html">porepy.numerics.ad.functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.grid_operators.html">porepy.numerics.ad.grid_operators module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.operator_functions.html">porepy.numerics.ad.operator_functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.operators.html">porepy.numerics.ad.operators module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.time_derivatives.html">porepy.numerics.ad.time_derivatives module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fem.html">porepy.numerics.fem package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fem.rt0.html">porepy.numerics.fem.rt0 module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.html">porepy.numerics.fracture_deformation package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.conforming_propagation.html">porepy.numerics.fracture_deformation.conforming_propagation module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.contact_conditions.html">porepy.numerics.fracture_deformation.contact_conditions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.propagate_fracture.html">porepy.numerics.fracture_deformation.propagate_fracture module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.propagation_model.html">porepy.numerics.fracture_deformation.propagation_model module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.html">porepy.numerics.fv package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.biot.html">porepy.numerics.fv.biot module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.fv_elliptic.html">porepy.numerics.fv.fv_elliptic module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.fvutils.html">porepy.numerics.fv.fvutils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.mass_matrix.html">porepy.numerics.fv.mass_matrix module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.mpfa.html">porepy.numerics.fv.mpfa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.mpsa.html">porepy.numerics.fv.mpsa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.source.html">porepy.numerics.fv.source module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.tpfa.html">porepy.numerics.fv.tpfa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.upwind.html">porepy.numerics.fv.upwind module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.html">porepy.numerics.interface_laws package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.abstract_interface_law.html">porepy.numerics.interface_laws.abstract_interface_law module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.cell_dof_face_dof_map.html">porepy.numerics.interface_laws.cell_dof_face_dof_map module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.contact_mechanics_interface_laws.html">porepy.numerics.interface_laws.contact_mechanics_interface_laws module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.elliptic_discretization.html">porepy.numerics.interface_laws.elliptic_discretization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.elliptic_interface_laws.html">porepy.numerics.interface_laws.elliptic_interface_laws module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.hyperbolic_interface_laws.html">porepy.numerics.interface_laws.hyperbolic_interface_laws module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linalg.html">porepy.numerics.linalg package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linalg.matrix_operations.html">porepy.numerics.linalg.matrix_operations module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.html">porepy.numerics.mixed_dim package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler.html">porepy.numerics.mixed_dim.assembler module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler_filters.html">porepy.numerics.mixed_dim.assembler_filters module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.dof_manager.html">porepy.numerics.mixed_dim.dof_manager module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.nonlinear.html">porepy.numerics.nonlinear package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.nonlinear.nonlinear_solvers.html">porepy.numerics.nonlinear.nonlinear_solvers module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.solvers.html">porepy.numerics.solvers package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.solvers.andersonacceleration.html">porepy.numerics.solvers.andersonacceleration module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.html">porepy.numerics.vem package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.dual_elliptic.html">porepy.numerics.vem.dual_elliptic module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.hybrid.html">porepy.numerics.vem.hybrid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.mass_matrix.html">porepy.numerics.vem.mass_matrix module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.mvem.html">porepy.numerics.vem.mvem module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.vem_source.html">porepy.numerics.vem.vem_source module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.discretization.html">porepy.numerics.discretization module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.displacement_correlation.html">porepy.numerics.displacement_correlation module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linear_solvers.html">porepy.numerics.linear_solvers module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.time_step_control.html">porepy.numerics.time_step_control module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.html">porepy.params package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.bc.html">porepy.params.bc module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.data.html">porepy.params.data module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.fluid.html">porepy.params.fluid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.parameter_dictionaries.html">porepy.params.parameter_dictionaries module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.rock.html">porepy.params.rock module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.tensor.html">porepy.params.tensor module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.html">porepy.utils package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.derived_discretizations.html">porepy.utils.derived_discretizations package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.derived_discretizations.implicit_euler.html">porepy.utils.derived_discretizations.implicit_euler module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.accumarray.html">porepy.utils.accumarray module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.adtree.html">porepy.utils.adtree module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.array_operations.html">porepy.utils.array_operations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.common_constants.html">porepy.utils.common_constants module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.default_domains.html">porepy.utils.default_domains module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.error.html">porepy.utils.error module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.graph.html">porepy.utils.graph module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.grid_utils.html">porepy.utils.grid_utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.interpolation_tables.html">porepy.utils.interpolation_tables module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.mcolon.html">porepy.utils.mcolon module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.permutations.html">porepy.utils.permutations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.porepy_types.html">porepy.utils.porepy_types module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.setmembership.html">porepy.utils.setmembership module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.sort_points.html">porepy.utils.sort_points module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.tags.html">porepy.utils.tags module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.tangential_normal_projection.html">porepy.utils.tangential_normal_projection module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.html">porepy.viz package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.data_saving_model_mixin.html">porepy.viz.data_saving_model_mixin module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.exporter.html">porepy.viz.exporter module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.fracture_visualization.html">porepy.viz.fracture_visualization module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.plot_grid.html">porepy.viz.plot_grid module</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docsrc/howto/howto-docstring.html">1. How to docstring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docsrc/howto/howto-build-docs.html">2. How to build documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PorePy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">porepy.models.contact_mechanics_model</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for porepy.models.contact_mechanics_model</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This is a setup class for solving linear elasticity with contact mechanics governing</span>
<span class="sd">the relative motion of fracture surfaces.</span>

<span class="sd">The setup handles parameters, variables and discretizations. Default (unitary-like)</span>
<span class="sd">parameters are set.</span>

<span class="sd">For a description of the mathematical model, see e.g. the tutorials and the PhD thesis</span>
<span class="sd">of Hüeber (2008): https://elib.uni-stuttgart.de/handle/11682/4854</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sps</span>

<span class="kn">import</span> <span class="nn">porepy</span> <span class="k">as</span> <span class="nn">pp</span>
<span class="kn">from</span> <span class="nn">porepy.models.abstract_model</span> <span class="kn">import</span> <span class="n">AbstractModel</span>

<span class="c1"># Module-wide logger</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="ContactMechanicsAdObjects"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.contact_mechanics_model.html#porepy.models.contact_mechanics_model.ContactMechanicsAdObjects">[docs]</a><span class="k">class</span> <span class="nc">ContactMechanicsAdObjects</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Storage class for ad related objects.</span>

<span class="sd">    Stored objects include variables, compound ad operators and projections.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">displacement</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Variable</span>
    <span class="n">interface_displacement</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Variable</span>
    <span class="n">contact_force</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Variable</span>

    <span class="n">contact_traction</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span>

    <span class="n">local_fracture_coord_transformation</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span>
    <span class="n">local_fracture_coord_transformation_normal</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span>
    <span class="n">subdomain_projections_vector</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">SubdomainProjections</span>
    <span class="n">tangential_component_frac</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span>
    <span class="n">normal_component_frac</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span>
    <span class="n">normal_to_tangential_frac</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span>
    <span class="n">internal_boundary_vector_to_outwards</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span>
    <span class="n">mortar_projections_vector</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">MortarProjections</span></div>


<div class="viewcode-block" id="ContactMechanics"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.contact_mechanics_model.html#porepy.models.contact_mechanics_model.ContactMechanics">[docs]</a><span class="k">class</span> <span class="nc">ContactMechanics</span><span class="p">(</span><span class="n">AbstractModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This is a shell class for contact mechanics problems.</span>

<span class="sd">    Setting up such problems requires a lot of boilerplate definitions of variables,</span>
<span class="sd">    parameters and discretizations. This class is intended to provide a standardized</span>
<span class="sd">    setup, with all discretizations in place and reasonable parameter and boundary</span>
<span class="sd">    values. The intended use is to inherit from this class, and do the necessary</span>
<span class="sd">    modifications and specifications for the problem to be fully defined. The minimal</span>
<span class="sd">    adjustment needed is to specify the method create_grid().</span>

<span class="sd">    Attributes:</span>
<span class="sd">        displacement_variable (str): Name assigned to the displacement variable in the</span>
<span class="sd">            highest-dimensional subdomain. Will be used throughout the simulations,</span>
<span class="sd">            including in ParaView export.</span>
<span class="sd">        mortar_displacement_variable (str): Name assigned to the displacement variable</span>
<span class="sd">            on the fracture walls. Will be used throughout the simulations, including in</span>
<span class="sd">            ParaView export.</span>
<span class="sd">        contact_traction_variable (str): Name assigned to the variable for contact</span>
<span class="sd">            forces in the fracture. Will be used throughout the simulations, including</span>
<span class="sd">            in ParaView export.</span>
<span class="sd">        mechanics_parameter_key (str): Keyword used to define parameters and</span>
<span class="sd">            discretizations for the mechanics problem.</span>
<span class="sd">        friction_coupling_term (str): Keyword used to define parameters and</span>
<span class="sd">            discretizations for the friction problem.</span>
<span class="sd">        params (dict): Dictionary of parameters used to control the solution procedure.</span>
<span class="sd">            Default parameters are set in AbstractModel</span>
<span class="sd">        mdg (pp.MixedDimensionalGrid): Mixed-dimensional grid. Should be set by a method</span>
<span class="sd">            create_grid which should be provided by the user.</span>
<span class="sd">        convergence_status (bool): Whether the non-linear iterations has converged.</span>
<span class="sd">        linear_solver (str): Specification of linear solver. Only known permissible</span>
<span class="sd">            value is &#39;direct&#39;</span>

<span class="sd">    All attributes are given natural values at initialization of the class.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1"># Variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">displacement_variable</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;u&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mortar_displacement_variable</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mortar_u&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contact_traction_variable</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;contact_traction&quot;</span>

        <span class="c1"># Keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mechanics&quot;</span>

        <span class="c1"># Terms of the equations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">friction_coupling_term</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;fracture_force_balance&quot;</span>

<div class="viewcode-block" id="ContactMechanics.before_newton_loop"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.contact_mechanics_model.html#porepy.models.contact_mechanics_model.ContactMechanics.before_newton_loop">[docs]</a>    <span class="k">def</span> <span class="nf">before_newton_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Will be run before entering a Newton loop.</span>
<span class="sd">        Discretize time-dependent quantities etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_status</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nonlinear_iteration</span> <span class="o">=</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="ContactMechanics.before_newton_iteration"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.contact_mechanics_model.html#porepy.models.contact_mechanics_model.ContactMechanics.before_newton_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">before_newton_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Re-discretize the nonlinear terms</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_ad</span><span class="p">:</span>
            <span class="n">filt</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">assembler_filters</span><span class="o">.</span><span class="n">ListFilter</span><span class="p">(</span>
                <span class="n">term_list</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">friction_coupling_term</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">discretize</span><span class="p">(</span><span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">)</span></div>

<div class="viewcode-block" id="ContactMechanics.after_newton_iteration"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.contact_mechanics_model.html#porepy.models.contact_mechanics_model.ContactMechanics.after_newton_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">after_newton_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution_vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract parts of the solution for current iterate.</span>

<span class="sd">        The iterate solutions in d[pp.STATE][pp.ITERATE] are updated for the</span>
<span class="sd">        mortar displacements and contact traction are updated.</span>
<span class="sd">        Method is a tailored copy from assembler.distribute_variable.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            solution_vector (np.array): solution vector for the current iterate.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nonlinear_iteration</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_ad</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">equation_system</span><span class="o">.</span><span class="n">set_variable_values</span><span class="p">(</span>
                <span class="n">solution_vector</span><span class="p">,</span> <span class="n">additive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">to_iterate</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dof_manager</span><span class="o">.</span><span class="n">distribute_variable</span><span class="p">(</span>
                <span class="n">values</span><span class="o">=</span><span class="n">solution_vector</span><span class="p">,</span> <span class="n">additive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">to_iterate</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="ContactMechanics.after_newton_convergence"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.contact_mechanics_model.html#porepy.models.contact_mechanics_model.ContactMechanics.after_newton_convergence">[docs]</a>    <span class="k">def</span> <span class="nf">after_newton_convergence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">errors</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">iteration_counter</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_ad</span><span class="p">:</span>
            <span class="c1"># Fetch iterate solution, which was updated in after_newton_iteration</span>
            <span class="n">solution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equation_system</span><span class="o">.</span><span class="n">get_variable_values</span><span class="p">(</span><span class="n">from_iterate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Distribute to pp.STATE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">equation_system</span><span class="o">.</span><span class="n">set_variable_values</span><span class="p">(</span>
                <span class="n">solution</span><span class="p">,</span> <span class="n">additive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">to_state</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">distribute_variable</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convergence_status</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_export</span><span class="p">()</span></div>

<div class="viewcode-block" id="ContactMechanics.check_convergence"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.contact_mechanics_model.html#porepy.models.contact_mechanics_model.ContactMechanics.check_convergence">[docs]</a>    <span class="k">def</span> <span class="nf">check_convergence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">solution</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">prev_solution</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">init_solution</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">nl_params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether the solution has converged by comparing values from the two</span>
<span class="sd">        most recent iterations.</span>

<span class="sd">        Tailored implementation if AD is not used. Else, the generic check in</span>
<span class="sd">        AbstractModel is used.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            solution (array): solution of current iteration.</span>
<span class="sd">            solution (array): solution of previous iteration.</span>
<span class="sd">            solution (array): initial solution (or from beginning of time step).</span>
<span class="sd">            nl_params (dictionary): assumed to have the key nl_convergence_tol whose</span>
<span class="sd">                value is a float.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_ad</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_nonlinear_problem</span><span class="p">():</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">check_convergence</span><span class="p">(</span>
                <span class="n">solution</span><span class="p">,</span> <span class="n">prev_solution</span><span class="p">,</span> <span class="n">init_solution</span><span class="p">,</span> <span class="n">nl_params</span>
            <span class="p">)</span>

        <span class="c1"># The default convergence check cannot be applied. Do a manual check instead.</span>
        <span class="n">sd_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nd_subdomain</span><span class="p">()</span>
        <span class="n">mech_dof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dof_manager</span><span class="o">.</span><span class="n">grid_and_variable_to_dofs</span><span class="p">(</span>
            <span class="n">sd_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">displacement_variable</span>
        <span class="p">)</span>

        <span class="c1"># Also find indices for the contact variables</span>
        <span class="n">contact_dof</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">u_j_dof</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">intf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interfaces</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">sd_secondary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_to_subdomain_pair</span><span class="p">(</span><span class="n">intf</span><span class="p">)</span>

            <span class="n">contact_dof</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">contact_dof</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dof_manager</span><span class="o">.</span><span class="n">grid_and_variable_to_dofs</span><span class="p">(</span>
                        <span class="n">sd_secondary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contact_traction_variable</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">u_j_dof</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">u_j_dof</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dof_manager</span><span class="o">.</span><span class="n">grid_and_variable_to_dofs</span><span class="p">(</span>
                        <span class="n">intf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mortar_displacement_variable</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Pick out the solution from current, previous iterates, as well as the</span>
        <span class="c1"># initial guess.</span>
        <span class="n">u_mech_now</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="n">mech_dof</span><span class="p">]</span>
        <span class="n">u_mech_prev</span> <span class="o">=</span> <span class="n">prev_solution</span><span class="p">[</span><span class="n">mech_dof</span><span class="p">]</span>
        <span class="n">u_mech_init</span> <span class="o">=</span> <span class="n">init_solution</span><span class="p">[</span><span class="n">mech_dof</span><span class="p">]</span>

        <span class="n">u_j_now</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="n">u_j_dof</span><span class="p">]</span>
        <span class="n">u_j_prev</span> <span class="o">=</span> <span class="n">prev_solution</span><span class="p">[</span><span class="n">u_j_dof</span><span class="p">]</span>
        <span class="n">u_j_init</span> <span class="o">=</span> <span class="n">init_solution</span><span class="p">[</span><span class="n">u_j_dof</span><span class="p">]</span>

        <span class="n">contact_now</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="n">contact_dof</span><span class="p">]</span>
        <span class="n">contact_prev</span> <span class="o">=</span> <span class="n">prev_solution</span><span class="p">[</span><span class="n">contact_dof</span><span class="p">]</span>
        <span class="n">contact_init</span> <span class="o">=</span> <span class="n">init_solution</span><span class="p">[</span><span class="n">contact_dof</span><span class="p">]</span>

        <span class="c1"># Calculate errors</span>
        <span class="n">difference_in_iterates_mech</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">u_mech_now</span> <span class="o">-</span> <span class="n">u_mech_prev</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">difference_from_init_mech</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">u_mech_now</span> <span class="o">-</span> <span class="n">u_mech_init</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">u_j_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">u_j_now</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">difference_in_iterates_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">u_j_now</span> <span class="o">-</span> <span class="n">u_j_prev</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">difference_from_init_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">u_j_now</span> <span class="o">-</span> <span class="n">u_j_init</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">contact_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">contact_now</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">difference_in_iterates_contact</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">contact_now</span> <span class="o">-</span> <span class="n">contact_prev</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">difference_from_init_contact</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">contact_now</span> <span class="o">-</span> <span class="n">contact_init</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">tol_convergence</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">nl_params</span><span class="p">[</span><span class="s2">&quot;nl_convergence_tol&quot;</span><span class="p">]</span>
        <span class="c1"># Not sure how to use the divergence criterion</span>
        <span class="c1"># tol_divergence = nl_params[&quot;nl_divergence_tol&quot;]</span>

        <span class="n">converged_mech</span><span class="p">,</span> <span class="n">converged_j</span><span class="p">,</span> <span class="n">converged_contact</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span>
        <span class="n">diverged</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># Check absolute convergence criterion</span>
        <span class="k">if</span> <span class="n">difference_in_iterates_mech</span> <span class="o">&lt;</span> <span class="n">tol_convergence</span><span class="p">:</span>
            <span class="n">converged_mech</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">error_mech</span> <span class="o">=</span> <span class="n">difference_in_iterates_mech</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Check relative convergence criterion</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">difference_in_iterates_mech</span>
                <span class="o">&lt;</span> <span class="n">tol_convergence</span> <span class="o">*</span> <span class="n">difference_from_init_mech</span>
            <span class="p">):</span>
                <span class="n">converged_mech</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">error_mech</span> <span class="o">=</span> <span class="n">difference_in_iterates_mech</span> <span class="o">/</span> <span class="n">difference_from_init_mech</span>

        <span class="c1"># The if is intended to avoid division through zero</span>
        <span class="k">if</span> <span class="n">contact_norm</span> <span class="o">&lt;</span> <span class="mf">1e-10</span> <span class="ow">and</span> <span class="n">difference_in_iterates_contact</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span>
            <span class="n">converged_contact</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">error_contact</span> <span class="o">=</span> <span class="n">difference_in_iterates_contact</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_contact</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">difference_in_iterates_contact</span> <span class="o">/</span> <span class="n">difference_from_init_contact</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="n">difference_in_iterates_contact</span>
                <span class="o">&lt;</span> <span class="n">tol_convergence</span> <span class="o">*</span> <span class="n">difference_from_init_contact</span>
            <span class="p">):</span>
                <span class="n">converged_contact</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># The if is intended to avoid division through zero</span>
        <span class="k">if</span> <span class="n">u_j_norm</span> <span class="o">&lt;</span> <span class="mf">1e-10</span> <span class="ow">and</span> <span class="n">difference_in_iterates_j</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span>
            <span class="n">converged_j</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">error_j</span> <span class="o">=</span> <span class="n">difference_in_iterates_j</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error_j</span> <span class="o">=</span> <span class="n">difference_in_iterates_j</span> <span class="o">/</span> <span class="n">difference_from_init_j</span>
            <span class="k">if</span> <span class="n">difference_in_iterates_j</span> <span class="o">&lt;</span> <span class="n">tol_convergence</span> <span class="o">*</span> <span class="n">difference_from_init_j</span><span class="p">:</span>
                <span class="n">converged_j</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">converged</span> <span class="o">=</span> <span class="n">converged_mech</span> <span class="ow">and</span> <span class="n">converged_j</span> <span class="ow">and</span> <span class="n">converged_contact</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Error in contact force is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">error_contact</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Error in matrix displacement is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">error_mech</span><span class="p">))</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">error_mech</span> <span class="o">+</span> <span class="n">error_j</span> <span class="o">+</span> <span class="n">error_contact</span>

        <span class="k">return</span> <span class="n">error</span><span class="p">,</span> <span class="n">converged</span><span class="p">,</span> <span class="n">diverged</span></div>

<div class="viewcode-block" id="ContactMechanics.reconstruct_local_displacement_jump"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.contact_mechanics_model.html#porepy.models.contact_mechanics_model.ContactMechanics.reconstruct_local_displacement_jump">[docs]</a>    <span class="k">def</span> <span class="nf">reconstruct_local_displacement_jump</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">intf</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">,</span>
        <span class="n">projection</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">TangentialNormalProjection</span><span class="p">,</span>
        <span class="n">from_iterate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruct the displacement jump in local coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">            intf represented by a mortar grid, expected to have the projection</span>
<span class="sd">            obtained by calling pp.contact_conditions.set_projections(self.mdg)</span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.array): ambient_dim x sd_l.num_cells. First 1-2 dimensions are in the</span>
<span class="sd">            tangential direction of the fracture, last dimension is normal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">interface_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_data</span><span class="p">(</span><span class="n">intf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">from_iterate</span><span class="p">:</span>
            <span class="n">mortar_u</span> <span class="o">=</span> <span class="n">interface_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="n">pp</span><span class="o">.</span><span class="n">ITERATE</span><span class="p">][</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mortar_displacement_variable</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mortar_u</span> <span class="o">=</span> <span class="n">interface_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">mortar_displacement_variable</span><span class="p">]</span>
        <span class="n">displacement_jump_global_coord</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">intf</span><span class="o">.</span><span class="n">mortar_to_secondary_avg</span><span class="p">(</span><span class="n">nd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">intf</span><span class="o">.</span><span class="n">sign_of_mortar_sides</span><span class="p">(</span><span class="n">nd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">mortar_u</span>
        <span class="p">)</span>
        <span class="c1"># Rotated displacement jumps. these are in the local coordinates, on</span>
        <span class="n">project_to_local</span> <span class="o">=</span> <span class="n">projection</span><span class="o">.</span><span class="n">project_tangential_normal</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">intf</span><span class="o">.</span><span class="n">num_cells</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">u_mortar_local</span> <span class="o">=</span> <span class="n">project_to_local</span> <span class="o">*</span> <span class="n">displacement_jump_global_coord</span>
        <span class="k">return</span> <span class="n">u_mortar_local</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="ContactMechanics.reconstruct_stress"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.contact_mechanics_model.html#porepy.models.contact_mechanics_model.ContactMechanics.reconstruct_stress">[docs]</a>    <span class="k">def</span> <span class="nf">reconstruct_stress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">previous_iterate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the stress in the highest-dimensional grid based on the displacement</span>
<span class="sd">        states in that grid, adjacent interfaces and global boundary conditions.</span>

<span class="sd">        The stress is stored in the data dictionary of the highest-dimensional grid,</span>
<span class="sd">        in [pp.STATE][&#39;stress&#39;].</span>

<span class="sd">        Parameters:</span>
<span class="sd">            previous_iterate (boolean, optional): If True, use values from previous</span>
<span class="sd">                iteration to compute the stress. Defaults to False.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Highest-dimensional grid and its data</span>
        <span class="n">sd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nd_subdomain</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomain_data</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span>

        <span class="c1"># Pick the relevant displacement field</span>
        <span class="k">if</span> <span class="n">previous_iterate</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="n">pp</span><span class="o">.</span><span class="n">ITERATE</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">displacement_variable</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">displacement_variable</span><span class="p">]</span>

        <span class="n">matrix_dictionary</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION_MATRICES</span><span class="p">][</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span>
        <span class="p">]</span>

        <span class="c1"># Make a discretization object to get hold of the right keys to access the</span>
        <span class="c1"># matrix_dictionary</span>
        <span class="n">mpsa</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">Mpsa</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">)</span>
        <span class="c1"># Stress contribution from internal cell center displacements</span>
        <span class="n">stress</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">matrix_dictionary</span><span class="p">[</span><span class="n">mpsa</span><span class="o">.</span><span class="n">stress_matrix_key</span><span class="p">]</span> <span class="o">*</span> <span class="n">u</span>

        <span class="c1"># Contributions from global boundary conditions</span>
        <span class="n">bound_stress_discr</span><span class="p">:</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span> <span class="o">=</span> <span class="n">matrix_dictionary</span><span class="p">[</span>
            <span class="n">mpsa</span><span class="o">.</span><span class="n">bound_stress_matrix_key</span>
        <span class="p">]</span>
        <span class="n">global_bc_val</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PARAMETERS</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">][</span>
            <span class="s2">&quot;bc_values&quot;</span>
        <span class="p">]</span>
        <span class="n">stress</span> <span class="o">+=</span> <span class="n">bound_stress_discr</span> <span class="o">*</span> <span class="n">global_bc_val</span>

        <span class="c1"># Contributions from the mortar displacement variables</span>
        <span class="k">for</span> <span class="n">intf</span><span class="p">,</span> <span class="n">intf_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interfaces</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="c1"># Only contributions from interfaces to the highest dimensional grid</span>
            <span class="k">if</span> <span class="n">intf</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">previous_iterate</span><span class="p">:</span>
                    <span class="n">u_intf</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">intf_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="n">pp</span><span class="o">.</span><span class="n">ITERATE</span><span class="p">][</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mortar_displacement_variable</span>
                    <span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">u_intf</span> <span class="o">=</span> <span class="n">intf_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">mortar_displacement_variable</span><span class="p">]</span>

                <span class="n">stress</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="n">bound_stress_discr</span> <span class="o">*</span> <span class="n">intf</span><span class="o">.</span><span class="n">mortar_to_primary_avg</span><span class="p">(</span><span class="n">nd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">)</span> <span class="o">*</span> <span class="n">u_intf</span>
                <span class="p">)</span>

        <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="s2">&quot;stress&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stress</span></div>

<div class="viewcode-block" id="ContactMechanics.prepare_simulation"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.contact_mechanics_model.html#porepy.models.contact_mechanics_model.ContactMechanics.prepare_simulation">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Is run prior to a time-stepping scheme. Use this to create a</span>
<span class="sd">        (mixed-dimensional) grid, initialize variables, parameters, equations,</span>
<span class="sd">        discretizations, export for visualization, linear solvers etc.</span>

<span class="sd">        The ordering of operations may be significant. For instance,</span>
<span class="sd">        defining initial condition before parameters allows the latter to</span>
<span class="sd">        depend on the former.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Geometry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_grid</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">dim_max</span><span class="p">()</span>
        <span class="c1"># If no fractures are present, the following call is harmless</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">contact_conditions</span><span class="o">.</span><span class="n">set_projections</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="p">)</span>

        <span class="c1"># Variables and parameters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;equation_system&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">equation_system</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">EquationSystem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_variables</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_ad</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_ad_variables</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;dof_manager&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_ad</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dof_manager</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">DofManager</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_condition</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_parameters</span><span class="p">()</span>

        <span class="c1"># Define equations through discretizations or ad expressions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assign_discretizations</span><span class="p">()</span>
        <span class="c1"># Once we have defined all discretizations, it&#39;s time to instantiate an</span>
        <span class="c1"># equation manager (needs to know which terms it should treat)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_ad</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_ad</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Assembler</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">Assembler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dof_manager</span><span class="p">)</span>

        <span class="c1"># Initial discretization.</span>
        <span class="c1"># FIXME: I think this is redundant and should be left to the before_newton_...</span>
        <span class="c1">#  methods. IS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_discretize</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_linear_solver</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">exporter</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">Exporter</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="p">,</span>
            <span class="n">file_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;file_name&quot;</span><span class="p">],</span>
            <span class="n">folder_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;folder_name&quot;</span><span class="p">],</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_initial_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set initial guess for the variables.</span>

<span class="sd">        The displacement is set to zero in the Nd-domain, and at the fracture interfaces</span>
<span class="sd">        The displacement jump is thereby also zero.</span>

<span class="sd">        The contact pressure is set to zero in the tangential direction,</span>
<span class="sd">        and -1 (that is, in contact) in the normal direction.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Zero for displacement and initial bc values for Biot</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_initial_condition</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">sd</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Contact as initial guess. Ensure traction is consistent with</span>
                <span class="c1"># zero jump, which follows from the default zeros set for all</span>
                <span class="c1"># variables, specifically interface displacement, by super method.</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">,</span> <span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">))</span>
                <span class="n">vals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">contact_traction_variable</span><span class="p">:</span> <span class="n">vals</span><span class="p">})</span>

                <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="n">pp</span><span class="o">.</span><span class="n">ITERATE</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">contact_traction_variable</span><span class="p">:</span> <span class="n">vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()}</span>
                <span class="p">)</span>

<div class="viewcode-block" id="ContactMechanics.after_simulation"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.contact_mechanics_model.html#porepy.models.contact_mechanics_model.ContactMechanics.after_simulation">[docs]</a>    <span class="k">def</span> <span class="nf">after_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Called after a time-dependent problem&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="c1"># Methods for populating the model etc.</span>

    <span class="k">def</span> <span class="nf">_set_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the parameters for the simulation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">sd</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">:</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">initialize_data</span><span class="p">(</span>
                    <span class="n">sd</span><span class="p">,</span>
                    <span class="n">data</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">,</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;bc&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bc_type</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span>
                        <span class="s2">&quot;bc_values&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bc_values</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span>
                        <span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_body_force</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span>
                        <span class="s2">&quot;fourth_order_tensor&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stiffness_tensor</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span>
                    <span class="p">},</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">c_num_n</span><span class="p">,</span> <span class="n">c_num_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_numerical_constants</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">initialize_data</span><span class="p">(</span>
                    <span class="n">sd</span><span class="p">,</span>
                    <span class="n">data</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">,</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;friction_coefficient&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_friction_coefficient</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span>
                        <span class="s2">&quot;initial_gap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_gap</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span>
                        <span class="s2">&quot;dilation_angle&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dilation_angle</span><span class="p">(</span><span class="n">sd</span><span class="p">),</span>
                        <span class="s2">&quot;c_num&quot;</span><span class="p">:</span> <span class="n">c_num_n</span><span class="p">,</span>  <span class="c1"># Non-ad uses single constant</span>
                        <span class="s2">&quot;c_num_normal&quot;</span><span class="p">:</span> <span class="n">c_num_n</span><span class="p">,</span>  <span class="c1"># Ad allows for two</span>
                        <span class="s2">&quot;c_num_tangential&quot;</span><span class="p">:</span> <span class="n">c_num_t</span><span class="p">,</span>
                    <span class="p">},</span>
                <span class="p">)</span>
        <span class="k">for</span> <span class="n">intf</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interfaces</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">initialize_data</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_nd_subdomain</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the grid of the highest dimension. Assumes self.mdg is set.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_bc_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">BoundaryConditionVectorial</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Define type of boundary conditions: Dirichlet on all global boundaries,</span>
<span class="sd">        Dirichlet also on fracture faces.</span>


<span class="sd">        Args:</span>
<span class="sd">            sd: Subdomain grid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bc: Boundary condition representation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_bf</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">get_boundary_faces</span><span class="p">()</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">BoundaryConditionVectorial</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">all_bf</span><span class="p">,</span> <span class="s2">&quot;dir&quot;</span><span class="p">)</span>
        <span class="c1"># Default internal BC is Neumann. We change to Dirichlet for the contact</span>
        <span class="c1"># problem. I.e., the mortar variable represents the displacement on the</span>
        <span class="c1"># fracture faces.</span>
        <span class="n">frac_face</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s2">&quot;fracture_faces&quot;</span><span class="p">]</span>
        <span class="n">bc</span><span class="o">.</span><span class="n">is_neu</span><span class="p">[:,</span> <span class="n">frac_face</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">bc</span><span class="o">.</span><span class="n">is_dir</span><span class="p">[:,</span> <span class="n">frac_face</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">bc</span>

    <span class="k">def</span> <span class="nf">_bc_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Set homogeneous conditions on all boundary faces.&quot;&quot;&quot;</span>
        <span class="c1"># Values for all Nd components, face-wise</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">,</span> <span class="n">sd</span><span class="o">.</span><span class="n">num_faces</span><span class="p">))</span>
        <span class="c1"># Reshape according to PorePy convention</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">_body_force</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Body force parameter.</span>

<span class="sd">        If the source term represents gravity in the y (2d) or z (3d) direction,</span>
<span class="sd">        use:</span>
<span class="sd">            vals = np.zeros((self,nd, sd.num_cells))</span>
<span class="sd">            vals[-1] = density * pp.GRAVITY_ACCELERATION * sd.cell_volumes</span>
<span class="sd">            return vals.ravel(&quot;F&quot;)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sd : pp.Grid</span>
<span class="sd">            Subdomain, usually the matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Integrated source values, shape self.nd * g.num_cells.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">*</span> <span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vals</span>

    <span class="k">def</span> <span class="nf">_dilation_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Dilation angle parameter.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sd : pp.Grid</span>
<span class="sd">            Fracture subdomain grid.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vals : np.ndarray</span>
<span class="sd">            Cell-wise dilation angle.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vals</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vals</span>

    <span class="k">def</span> <span class="nf">_initial_gap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Initial gap value.</span>

<span class="sd">        Distance between the surfaces of a fracture when in mechanical contact in</span>
<span class="sd">        the unperturbed state.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sd : pp.Grid</span>
<span class="sd">            Fracture subdomain grid.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vals : np.ndarray</span>
<span class="sd">            Cell-wise gap value.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vals</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vals</span>

    <span class="k">def</span> <span class="nf">_friction_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Friction coefficient parameter.</span>

<span class="sd">        The friction coefficient is uniform and equal to 1.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sd : pp.Grid</span>
<span class="sd">            Fracture subdomain grid.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            Cell-wise friction coefficient.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_numerical_constants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Numerical constants for contact mechanics.</span>

<span class="sd">        Unitary and homogeneous default values.</span>

<span class="sd">        The constants enter sums of traction and displacement jump of the type</span>
<span class="sd">            T_i + c * u_i   for i in {n, tau}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sd : pp.Grid</span>
<span class="sd">            Subdomain grid for which the constants are returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        c_num_n : np.ndarray (sd.num_cells)</span>
<span class="sd">            Numerical constant for normal complimentary function.</span>
<span class="sd">        c_num_t: np.ndarray (sd.num_cells * sd.dim)</span>
<span class="sd">            Numerical constant for tangential complimentary function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c_num_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">)</span>
        <span class="c1"># Expand to tangential Nd-1 vector</span>
        <span class="n">tangential_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">)</span>
        <span class="n">c_num_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">tangential_vals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">c_num_n</span><span class="p">,</span> <span class="n">c_num_t</span>

    <span class="k">def</span> <span class="nf">_stiffness_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">FourthOrderTensor</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Fourth order stress tensor.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sd : pp.Grid</span>
<span class="sd">            Matrix grid.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pp.FourthOrderTensor</span>
<span class="sd">            Cell-wise representation of the stress tensor.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Rock parameters</span>
        <span class="n">lam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">FourthOrderTensor</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">lam</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_assign_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign variables to the subdomains and interfaces of the mixed-dimensional grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_ad</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">equation_system</span><span class="o">.</span><span class="n">create_variables</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">displacement_variable</span><span class="p">,</span>
                <span class="p">{</span><span class="s2">&quot;cells&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">},</span>
                <span class="n">subdomains</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">equation_system</span><span class="o">.</span><span class="n">create_variables</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">contact_traction_variable</span><span class="p">,</span>
                <span class="p">{</span><span class="s2">&quot;cells&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">},</span>
                <span class="n">subdomains</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">equation_system</span><span class="o">.</span><span class="n">create_variables</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mortar_displacement_variable</span><span class="p">,</span>
                <span class="p">{</span><span class="s2">&quot;cells&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">},</span>
                <span class="n">interfaces</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interfaces</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sd</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PRIMARY_VARIABLES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">displacement_variable</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;cells&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">}</span>
                    <span class="p">}</span>
                <span class="k">elif</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PRIMARY_VARIABLES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">contact_traction_variable</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;cells&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">}</span>
                    <span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PRIMARY_VARIABLES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">intf</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interfaces</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">intf</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PRIMARY_VARIABLES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mortar_displacement_variable</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;cells&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">}</span>
                    <span class="p">}</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PRIMARY_VARIABLES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">_create_ad_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Assign variables to self._ad</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If the md_grid contains multiple nd subdomains.</span>

<span class="sd">        Assigns the following attributes to self._ad:</span>
<span class="sd">            displacement: Primary variable in the nd subdomain.</span>
<span class="sd">            interface_displacement: Primary variables on interfaces of</span>
<span class="sd">                dimension nd - 1</span>
<span class="sd">            contact_force: Primary variable on all fracture subdomains</span>
<span class="sd">            contact_traction: Secondary variable on all fracture subdomains.</span>
<span class="sd">                This traction is scaled with the inverse of the elastic moduli</span>
<span class="sd">                of the matrix.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Ad variables</span>
        <span class="n">mdg</span><span class="p">,</span> <span class="n">nd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span>
        <span class="n">sd_primary</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nd_subdomain</span><span class="p">()</span>
        <span class="n">fracture_subdomains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">]</span> <span class="o">=</span> <span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_frac_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span> <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">fracture_subdomains</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">nd</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Some parts of the code have been partially prepared for</span>
            <span class="c1"># this case, other parts require adjustment.</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This will require further work&quot;</span><span class="p">)</span>

        <span class="n">matrix_fracture_interfaces</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">mdg</span><span class="o">.</span><span class="n">subdomain_pair_to_interface</span><span class="p">((</span><span class="n">sd_primary</span><span class="p">,</span> <span class="n">sd</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">fracture_subdomains</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_ad_objects</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_ad_projections</span><span class="p">()</span>

        <span class="c1"># Primary variables on Ad form</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ad</span><span class="o">.</span><span class="n">displacement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equation_system</span><span class="o">.</span><span class="n">md_variable</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">displacement_variable</span><span class="p">,</span> <span class="p">[</span><span class="n">sd_primary</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ad</span><span class="o">.</span><span class="n">interface_displacement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equation_system</span><span class="o">.</span><span class="n">md_variable</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mortar_displacement_variable</span><span class="p">,</span> <span class="n">matrix_fracture_interfaces</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ad</span><span class="o">.</span><span class="n">contact_force</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">equation_system</span><span class="o">.</span><span class="n">md_variable</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">contact_traction_variable</span><span class="p">,</span> <span class="n">fracture_subdomains</span>
        <span class="p">)</span>
        <span class="n">discr</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">ContactTractionAd</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">,</span>
            <span class="n">matrix_fracture_interfaces</span><span class="p">,</span>
            <span class="n">fracture_subdomains</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ad</span><span class="o">.</span><span class="n">contact_traction</span> <span class="o">=</span> <span class="n">discr</span><span class="o">.</span><span class="n">traction_scaling</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ad</span><span class="o">.</span><span class="n">contact_force</span>

    <span class="k">def</span> <span class="nf">_set_ad_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sets the storage class self._ad</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ad</span> <span class="o">=</span> <span class="n">ContactMechanicsAdObjects</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_assign_discretizations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Assign discretizations to subdomains and interfaces.&quot;&quot;&quot;</span>

        <span class="c1"># For the Nd domain we solve linear elasticity with mpsa.</span>
        <span class="n">nd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span>
        <span class="n">mdg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;dof_manager&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_ad</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dof_manager</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">DofManager</span><span class="p">(</span><span class="n">mdg</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_ad</span><span class="p">:</span>
            <span class="n">mpsa</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">Mpsa</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">)</span>
            <span class="c1"># We need a void discretization for the contact traction variable defined on</span>
            <span class="c1"># the fractures.</span>
            <span class="n">empty_discr</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">VoidDiscretization</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">,</span> <span class="n">ndof_cell</span><span class="o">=</span><span class="n">nd</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">sd</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="n">nd</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">displacement_variable</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;mpsa&quot;</span><span class="p">:</span> <span class="n">mpsa</span><span class="p">}</span>
                    <span class="p">}</span>
                <span class="k">elif</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">contact_traction_variable</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;empty&quot;</span><span class="p">:</span> <span class="n">empty_discr</span><span class="p">}</span>
                    <span class="p">}</span>

            <span class="c1"># Define the contact condition on the mortar grid</span>
            <span class="n">coloumb</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ColoumbContact</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="n">mpsa</span><span class="p">)</span>
            <span class="n">contact</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">PrimalContactCoupling</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">,</span> <span class="n">mpsa</span><span class="p">,</span> <span class="n">coloumb</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">intf</span><span class="p">,</span> <span class="n">intf_data</span> <span class="ow">in</span> <span class="n">mdg</span><span class="o">.</span><span class="n">interfaces</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">sd_primary</span><span class="p">,</span> <span class="n">sd_secondary</span> <span class="o">=</span> <span class="n">mdg</span><span class="o">.</span><span class="n">interface_to_subdomain_pair</span><span class="p">(</span><span class="n">intf</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sd_primary</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="n">nd</span><span class="p">:</span>
                    <span class="n">intf_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">COUPLING_DISCRETIZATION</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">friction_coupling_term</span><span class="p">:</span> <span class="p">{</span>
                            <span class="n">sd_primary</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">displacement_variable</span><span class="p">,</span> <span class="s2">&quot;mpsa&quot;</span><span class="p">),</span>
                            <span class="n">sd_secondary</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contact_traction_variable</span><span class="p">,</span> <span class="s2">&quot;empty&quot;</span><span class="p">),</span>
                            <span class="n">intf</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mortar_displacement_variable</span><span class="p">,</span> <span class="n">contact</span><span class="p">),</span>
                        <span class="p">}</span>
                    <span class="p">}</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_assign_equations</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_assign_equations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign equations to self._eq_manager.</span>

<span class="sd">        The ad variables are set by a previous call to _create_ad_variables and</span>
<span class="sd">        accessed through self._ad.*variable_name*</span>

<span class="sd">        The following equations are assigned to the equation manager:</span>
<span class="sd">            &quot;momentum&quot; in the nd subdomain</span>
<span class="sd">            &quot;contact_mechanics_normal&quot; in all fracture subdomains</span>
<span class="sd">            &quot;contact_mechanics_tangential&quot; in all fracture subdomains</span>
<span class="sd">            &quot;force_balance&quot; at the matrix-fracture interfaces</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mdg</span><span class="p">,</span> <span class="n">nd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span>

        <span class="n">sd_nd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nd_subdomain</span><span class="p">()</span>

        <span class="n">fracture_subdomains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">]</span> <span class="o">=</span> <span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_frac_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">g</span><span class="o">.</span><span class="n">num_cells</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">fracture_subdomains</span><span class="p">])</span>

        <span class="n">matrix_fracture_interfaces</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">intf</span> <span class="k">for</span> <span class="n">intf</span> <span class="ow">in</span> <span class="n">mdg</span><span class="o">.</span><span class="n">subdomain_to_interfaces</span><span class="p">(</span><span class="n">sd_nd</span><span class="p">)</span> <span class="k">if</span> <span class="n">intf</span><span class="o">.</span><span class="n">codim</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="p">]</span>

        <span class="c1"># Projections between subdomains, rotations etc. must be wrapped into</span>
        <span class="c1"># ad objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_ad_projections</span><span class="p">()</span>

        <span class="c1"># Construct equations</span>
        <span class="n">momentum_eq</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_momentum_balance_equation</span><span class="p">([</span><span class="n">sd_nd</span><span class="p">])</span>
        <span class="n">contact_n</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contact_mechanics_normal_equation</span><span class="p">(</span>
            <span class="n">fracture_subdomains</span>
        <span class="p">)</span>
        <span class="n">contact_t</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contact_mechanics_tangential_equation</span><span class="p">(</span>
            <span class="n">fracture_subdomains</span>
        <span class="p">)</span>
        <span class="n">force_balance_eq</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_balance_equation</span><span class="p">(</span>
            <span class="p">[</span><span class="n">sd_nd</span><span class="p">],</span>
            <span class="n">fracture_subdomains</span><span class="p">,</span>
            <span class="n">matrix_fracture_interfaces</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Assign equations to manager</span>
        <span class="k">for</span> <span class="n">eq</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="p">[</span><span class="n">momentum_eq</span><span class="p">,</span> <span class="n">contact_n</span><span class="p">,</span> <span class="n">contact_t</span><span class="p">,</span> <span class="n">force_balance_eq</span><span class="p">],</span>
            <span class="p">[</span>
                <span class="s2">&quot;momentum&quot;</span><span class="p">,</span>
                <span class="s2">&quot;contact_mechanics_normal&quot;</span><span class="p">,</span>
                <span class="s2">&quot;contact_mechanics_tangential&quot;</span><span class="p">,</span>
                <span class="s2">&quot;force_balance&quot;</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">):</span>
            <span class="n">eq</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">equation_system</span><span class="o">.</span><span class="n">set_equation</span><span class="p">(</span><span class="n">momentum_eq</span><span class="p">,</span> <span class="p">[</span><span class="n">sd_nd</span><span class="p">],</span> <span class="p">{</span><span class="s2">&quot;cells&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">equation_system</span><span class="o">.</span><span class="n">set_equation</span><span class="p">(</span><span class="n">contact_n</span><span class="p">,</span> <span class="n">fracture_subdomains</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;cells&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">equation_system</span><span class="o">.</span><span class="n">set_equation</span><span class="p">(</span>
            <span class="n">contact_t</span><span class="p">,</span> <span class="n">fracture_subdomains</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;cells&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">equation_system</span><span class="o">.</span><span class="n">set_equation</span><span class="p">(</span>
            <span class="n">force_balance_eq</span><span class="p">,</span> <span class="n">matrix_fracture_interfaces</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;cells&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">}</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_ad_projections</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets projection and rotation matrices.</span>


<span class="sd">        The following attributes are set to self._ad:</span>
<span class="sd">            local_fracture_coord_transformation: Concatenated transformation matrices from</span>
<span class="sd">                global to local (fracture plane) coordinates</span>
<span class="sd">            mortar_projections_vector: Projections between matrix and fracture grids</span>
<span class="sd">                and their interface/mortar grids.</span>
<span class="sd">            subdomain_projections_vector: Prolongation and restriction operators for</span>
<span class="sd">                all grids with Nd components for each cell or face.</span>
<span class="sd">            normal_component_frac: Extract the normal component (scalar) of a</span>
<span class="sd">                Nd-dimensional fracture cell vector.</span>
<span class="sd">            tangential_component_frac: Extract the tangential component (Nd-1 vector)</span>
<span class="sd">                of a Nd-dimensional fracture cell vector.</span>
<span class="sd">            normal_to_tangential_frac: Prolong from scalar to (Nd-1) cell-wise values.</span>
<span class="sd">            internal_boundary_vector_to_outwards: Switch sign/direction of a nd</span>
<span class="sd">                vector at internal boundary faces of the matrix grid, i.e. corresponding</span>
<span class="sd">                to all matrix-fracture interfaces. Entries are 1 and -1, size is</span>
<span class="sd">                (ndgrid.num_faces * self.nd) ** 2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ad</span>

        <span class="n">subdomains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">sd</span> <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">()]</span>
        <span class="n">fracture_subdomains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">fracture_matrix_interfaces</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomain_pair_to_interface</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_nd_subdomain</span><span class="p">(),</span> <span class="n">sd</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">fracture_subdomains</span>
        <span class="p">]</span>

        <span class="c1"># Store number of fracture cells</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_frac_cells</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span> <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">fracture_subdomains</span><span class="p">]))</span>

        <span class="c1"># Special treatment in case no fractures are present</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fracture_subdomains</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">matrix_attributes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;local_fracture_coord_transformation&quot;</span><span class="p">,</span>
                <span class="s2">&quot;normal_component_frac&quot;</span><span class="p">,</span>
                <span class="s2">&quot;tangential_component_frac&quot;</span><span class="p">,</span>
                <span class="s2">&quot;normal_to_tangential_frac&quot;</span><span class="p">,</span>
                <span class="s2">&quot;internal_boundary_vector_to_outwards&quot;</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">attribute_name</span> <span class="ow">in</span> <span class="n">matrix_attributes</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">attribute_name</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))))</span>
            <span class="nb">setattr</span><span class="p">(</span>
                <span class="n">ad</span><span class="p">,</span>
                <span class="s2">&quot;internal_boundary_vector_to_outwards&quot;</span><span class="p">,</span>
                <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_nd_subdomain</span><span class="p">()</span><span class="o">.</span><span class="n">num_faces</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_nd_subdomain</span><span class="p">()</span><span class="o">.</span><span class="n">num_faces</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Global to local coordinate transformation</span>
            <span class="n">local_coord_proj_list</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomain_data</span><span class="p">(</span><span class="n">sd</span><span class="p">)[</span>
                    <span class="s2">&quot;tangential_normal_projection&quot;</span>
                <span class="p">]</span><span class="o">.</span><span class="n">project_tangential_normal</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">fracture_subdomains</span>
            <span class="p">]</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">local_fracture_coord_transformation</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span>
                <span class="n">sps</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="n">local_coord_proj_list</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># Matrices for extracting normal and tangential components on the fractures</span>
            <span class="n">n_frac_c_dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_frac_cells</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">)</span>
            <span class="n">n_frac_c_t</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_frac_cells</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">normal_rows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_frac_cells</span><span class="p">)</span>
            <span class="n">normal_cols</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_frac_c_dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">)</span>
            <span class="n">normal_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_frac_cells</span><span class="p">)</span>

            <span class="n">tangential_cols</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_frac_c_dim</span><span class="p">),</span> <span class="n">normal_cols</span>
            <span class="p">)</span>
            <span class="n">tangential_rows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_frac_c_t</span><span class="p">)</span>
            <span class="n">tangential_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_frac_c_t</span><span class="p">)</span>

            <span class="n">ad</span><span class="o">.</span><span class="n">normal_component_frac</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span>
                <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">normal_data</span><span class="p">,</span> <span class="p">(</span><span class="n">normal_rows</span><span class="p">,</span> <span class="n">normal_cols</span><span class="p">)),</span>
                    <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_frac_cells</span><span class="p">,</span> <span class="n">n_frac_c_dim</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">tangential_component_frac</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span>
                <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">tangential_data</span><span class="p">,</span> <span class="p">(</span><span class="n">tangential_rows</span><span class="p">,</span> <span class="n">tangential_cols</span><span class="p">)),</span>
                    <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_frac_c_t</span><span class="p">,</span> <span class="n">n_frac_c_dim</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Indices in local fracture bases.</span>
            <span class="c1"># There are n_frac_c normal components of local vectors and n_frac_c_t</span>
            <span class="c1"># tangential components. The Matrix constructed below expands from the former to</span>
            <span class="c1"># the latter, so that we e.g. can compare a tangential vector V_t and the</span>
            <span class="c1"># prolonged quantity normal_to_tangential * V_n</span>
            <span class="n">local_inds_t</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_frac_c_t</span><span class="p">)</span>
            <span class="n">local_inds_n</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_frac_cells</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">n2t_matrix</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_frac_c_t</span><span class="p">),</span> <span class="p">(</span><span class="n">local_inds_t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">local_inds_n</span><span class="p">))),</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_frac_c_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_frac_cells</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">normal_to_tangential_frac</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">n2t_matrix</span><span class="p">)</span>

            <span class="c1"># Sign switcher accounting for normal direction of faces on internal boundaries of</span>
            <span class="c1"># matrix grid (corresponding to matrix-fracture interfaces).</span>
            <span class="n">outwards_mat</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">intf</span> <span class="ow">in</span> <span class="n">fracture_matrix_interfaces</span><span class="p">:</span>
                <span class="n">faces_on_fracture_surface</span> <span class="o">=</span> <span class="n">intf</span><span class="o">.</span><span class="n">primary_to_mortar_int</span><span class="p">()</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span><span class="o">.</span><span class="n">indices</span>
                <span class="n">switcher_int</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">grid_utils</span><span class="o">.</span><span class="n">switch_sign_if_inwards_normal</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_nd_subdomain</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">,</span> <span class="n">faces_on_fracture_surface</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">outwards_mat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">outwards_mat</span> <span class="o">=</span> <span class="n">switcher_int</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outwards_mat</span> <span class="o">+=</span> <span class="n">switcher_int</span>

            <span class="n">ad</span><span class="o">.</span><span class="n">internal_boundary_vector_to_outwards</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">outwards_mat</span><span class="p">)</span>

        <span class="c1"># Projections between interfaces and subdomains</span>
        <span class="n">ad</span><span class="o">.</span><span class="n">mortar_projections_vector</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">MortarProjections</span><span class="p">(</span>
            <span class="n">subdomains</span><span class="o">=</span><span class="n">subdomains</span><span class="p">,</span>
            <span class="n">interfaces</span><span class="o">=</span><span class="n">fracture_matrix_interfaces</span><span class="p">,</span>
            <span class="n">mdg</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Prolongation and restriction between subdomain subsets and full subdomain list</span>
        <span class="n">ad</span><span class="o">.</span><span class="n">subdomain_projections_vector</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">SubdomainProjections</span><span class="p">(</span>
            <span class="n">subdomains</span><span class="o">=</span><span class="n">subdomains</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_displacement_jump</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">fracture_subdomains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">],</span> <span class="n">previous_timestep</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Construct AD Operator representing jump of interface displacement.</span>

<span class="sd">        Args:</span>
<span class="sd">            fracture_subdomains</span>
<span class="sd">                List of fracture subdomains.</span>

<span class="sd">        Returns:</span>
<span class="sd">            rotated_jumps</span>
<span class="sd">                Operator representing jump across all fractures.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ad</span>
        <span class="k">if</span> <span class="n">previous_timestep</span><span class="p">:</span>
            <span class="n">interface_displacement</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">interface_displacement</span><span class="o">.</span><span class="n">previous_timestep</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">interface_displacement</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">interface_displacement</span>
        <span class="n">rotated_jumps</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">local_fracture_coord_transformation</span>
            <span class="o">*</span> <span class="n">ad</span><span class="o">.</span><span class="n">subdomain_projections_vector</span><span class="o">.</span><span class="n">cell_restriction</span><span class="p">(</span><span class="n">fracture_subdomains</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">ad</span><span class="o">.</span><span class="n">mortar_projections_vector</span><span class="o">.</span><span class="n">mortar_to_secondary_avg</span>
            <span class="o">*</span> <span class="n">ad</span><span class="o">.</span><span class="n">mortar_projections_vector</span><span class="o">.</span><span class="n">sign_of_mortar_sides</span>
            <span class="o">*</span> <span class="n">interface_displacement</span>
        <span class="p">)</span>
        <span class="n">rotated_jumps</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;Rotated displacement jump&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rotated_jumps</span>

    <span class="k">def</span> <span class="nf">_contact_mechanics_normal_equation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fracture_subdomains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Contact mechanics equation for the normal constraints.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fracture_subdomains : List[pp.Grid]</span>
<span class="sd">            List of fracture subdomains.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        equation : pp.ad.Operator</span>
<span class="sd">            Contact mechanics equation for the normal constraints.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numerical_c_n</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">ParameterMatrix</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">,</span>
            <span class="n">array_keyword</span><span class="o">=</span><span class="s2">&quot;c_num_normal&quot;</span><span class="p">,</span>
            <span class="n">subdomains</span><span class="o">=</span><span class="n">fracture_subdomains</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">T_n</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ad</span><span class="o">.</span><span class="n">normal_component_frac</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ad</span><span class="o">.</span><span class="n">contact_traction</span>

        <span class="n">MaxAd</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">maximum</span><span class="p">,</span> <span class="s2">&quot;max_function&quot;</span><span class="p">)</span>
        <span class="n">zeros_frac</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_frac_cells</span><span class="p">))</span>
        <span class="n">u_n</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ad</span><span class="o">.</span><span class="n">normal_component_frac</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_displacement_jump</span><span class="p">(</span>
            <span class="n">fracture_subdomains</span>
        <span class="p">)</span>
        <span class="n">equation</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span> <span class="o">=</span> <span class="n">T_n</span> <span class="o">+</span> <span class="n">MaxAd</span><span class="p">(</span>
            <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">T_n</span> <span class="o">-</span> <span class="n">numerical_c_n</span> <span class="o">*</span> <span class="p">(</span><span class="n">u_n</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gap</span><span class="p">(</span><span class="n">fracture_subdomains</span><span class="p">)),</span>
            <span class="n">zeros_frac</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">equation</span>

    <span class="k">def</span> <span class="nf">_friction_bound</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fracture_subdomains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ad operator representing the friction bound.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fracture_subdomains : List[pp.Grid]</span>
<span class="sd">            List of fracture subdomains.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bound : pp.ad.Operator</span>
<span class="sd">            Friction bound operator.</span>

<span class="sd">        Note:</span>
<span class="sd">            Hueeber and Berge use</span>
<span class="sd">            (-1) * friction_coefficient * (T_n + c_n * (u_n - gap))</span>
<span class="sd">            The argument is that with this choice, &quot;the Newton-type iteration</span>
<span class="sd">            automatically takes the form of an active set method&quot; (Hueber&#39;s</span>
<span class="sd">            thesis p. 104). Since we abandon the sets in the ad-based</span>
<span class="sd">             implementation, the simpler form more closely related to the</span>
<span class="sd">             Coulomb friction law is preferred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">friction_coefficient</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">ParameterMatrix</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">,</span>
            <span class="n">array_keyword</span><span class="o">=</span><span class="s2">&quot;friction_coefficient&quot;</span><span class="p">,</span>
            <span class="n">subdomains</span><span class="o">=</span><span class="n">fracture_subdomains</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ad</span>
        <span class="n">T_n</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">normal_component_frac</span> <span class="o">*</span> <span class="n">ad</span><span class="o">.</span><span class="n">contact_traction</span>
        <span class="n">bound</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">friction_coefficient</span> <span class="o">*</span> <span class="n">T_n</span>
        <span class="n">bound</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;friction_bound&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bound</span>

    <span class="k">def</span> <span class="nf">_gap</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fracture_subdomains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Gap function.</span>

<span class="sd">        The gap function includes an initial (constant) value and shear dilation.</span>
<span class="sd">        It depends linearly on the norm of tangential displacement jump:</span>
<span class="sd">            g = g_0 + tan(dilation_angle) * norm([[u]]_t)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fracture_subdomains : List[pp.Grid]</span>
<span class="sd">            List of fracture subdomains.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gap : pp.ad.Operator</span>
<span class="sd">            Gap function representing the distance between the fracture</span>
<span class="sd">            interfaces when in mechanical contact.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">initial_gap</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">ParameterArray</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">,</span>
            <span class="n">array_keyword</span><span class="o">=</span><span class="s2">&quot;initial_gap&quot;</span><span class="p">,</span>
            <span class="n">subdomains</span><span class="o">=</span><span class="n">fracture_subdomains</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">angle</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">ParameterArray</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">,</span>
            <span class="n">array_keyword</span><span class="o">=</span><span class="s2">&quot;dilation_angle&quot;</span><span class="p">,</span>
            <span class="n">subdomains</span><span class="o">=</span><span class="n">fracture_subdomains</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">Norm</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span>
            <span class="n">partial</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">l2_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;norm_function&quot;</span>
        <span class="p">)</span>
        <span class="n">Tan</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">tan</span><span class="p">,</span> <span class="s2">&quot;tan_function&quot;</span><span class="p">)</span>
        <span class="n">shear_dilation</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span> <span class="o">=</span> <span class="n">Tan</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">Norm</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ad</span><span class="o">.</span><span class="n">tangential_component_frac</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_displacement_jump</span><span class="p">(</span><span class="n">fracture_subdomains</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">gap</span> <span class="o">=</span> <span class="n">initial_gap</span> <span class="o">+</span> <span class="n">shear_dilation</span>
        <span class="n">gap</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;gap_with_shear_dilation&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gap</span>

    <span class="k">def</span> <span class="nf">_contact_mechanics_tangential_equation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fracture_subdomains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Contact mechanics equation for the tangential constraints.</span>

<span class="sd">        The function reads</span>
<span class="sd">            C_t = max(b_p, ||T_t+c_t u_t||) T_t - max(0, b_p) (T_t+c_t u_t)</span>
<span class="sd">        with u being displacement jump increments, t denoting tangential</span>
<span class="sd">        component and b_p the friction bound.</span>

<span class="sd">        For b_p = 0, the equation C_t = 0 does not in itself imply T_t = 0,</span>
<span class="sd">        which is what the contact conditions require. The case is handled</span>
<span class="sd">        through the use of a characteristic function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fracture_subdomains : List[pp.Grid]</span>
<span class="sd">            List of fracture subdomains.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        complementary_eq : pp.ad.Operator</span>
<span class="sd">            Contact mechanics equation for the tangential constraints.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ad</span>

        <span class="c1"># Parameter and constants</span>
        <span class="n">numerical_c_t</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">ParameterMatrix</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">,</span>
            <span class="n">array_keyword</span><span class="o">=</span><span class="s2">&quot;c_num_tangential&quot;</span><span class="p">,</span>
            <span class="n">subdomains</span><span class="o">=</span><span class="n">fracture_subdomains</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ones_frac</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_frac_cells</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">zeros_frac</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_frac_cells</span><span class="p">))</span>

        <span class="c1"># Functions</span>
        <span class="n">MaxAd</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">maximum</span><span class="p">,</span> <span class="s2">&quot;max_function&quot;</span><span class="p">)</span>
        <span class="n">NormAd</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">l2_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;norm_function&quot;</span><span class="p">)</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-5</span>
        <span class="n">Characteristic</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span>
            <span class="n">partial</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">characteristic_function</span><span class="p">,</span> <span class="n">tol</span><span class="p">),</span>
            <span class="s2">&quot;characteristic_function_for_zero_normal_traction&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Variables</span>
        <span class="n">T_t</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">tangential_component_frac</span> <span class="o">*</span> <span class="n">ad</span><span class="o">.</span><span class="n">contact_traction</span>
        <span class="n">u_t_prime</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">tangential_component_frac</span> <span class="o">*</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_displacement_jump</span><span class="p">(</span><span class="n">fracture_subdomains</span><span class="p">)</span>
            <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_displacement_jump</span><span class="p">(</span><span class="n">fracture_subdomains</span><span class="p">,</span> <span class="n">previous_timestep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">u_t_prime</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;u_tau_increment&quot;</span><span class="p">)</span>

        <span class="c1"># Combine the above into expressions that enter the equation</span>
        <span class="n">tangential_sum</span> <span class="o">=</span> <span class="n">T_t</span> <span class="o">+</span> <span class="n">numerical_c_t</span> <span class="o">*</span> <span class="n">u_t_prime</span>

        <span class="n">norm_tangential_sum</span> <span class="o">=</span> <span class="n">NormAd</span><span class="p">(</span><span class="n">tangential_sum</span><span class="p">)</span>
        <span class="n">norm_tangential_sum</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;norm_tangential&quot;</span><span class="p">)</span>

        <span class="n">b_p</span> <span class="o">=</span> <span class="n">MaxAd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_friction_bound</span><span class="p">(</span><span class="n">fracture_subdomains</span><span class="p">),</span> <span class="n">zeros_frac</span><span class="p">)</span>
        <span class="n">b_p</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;bp&quot;</span><span class="p">)</span>

        <span class="n">bp_tang</span> <span class="o">=</span> <span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">normal_to_tangential_frac</span> <span class="o">*</span> <span class="n">b_p</span><span class="p">)</span> <span class="o">*</span> <span class="n">tangential_sum</span>

        <span class="n">maxbp_abs</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">normal_to_tangential_frac</span> <span class="o">*</span> <span class="n">MaxAd</span><span class="p">(</span><span class="n">b_p</span><span class="p">,</span> <span class="n">norm_tangential_sum</span><span class="p">)</span>
        <span class="n">characteristic</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">normal_to_tangential_frac</span> <span class="o">*</span> <span class="n">Characteristic</span><span class="p">(</span>
            <span class="n">b_p</span>
        <span class="p">)</span>
        <span class="n">characteristic</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;characteristic_function&quot;</span><span class="p">)</span>

        <span class="c1"># Compose the equation itself.</span>
        <span class="c1"># The last term handles the case bound=0, in which case T_t = 0 cannot</span>
        <span class="c1"># be deduced from the standard version of the complementary function</span>
        <span class="c1"># (i.e. without the characteristic function). Filter out the other terms</span>
        <span class="c1"># in this case to improve convergence</span>
        <span class="n">complementary_eq</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span> <span class="o">=</span> <span class="p">(</span><span class="n">ones_frac</span> <span class="o">-</span> <span class="n">characteristic</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">bp_tang</span> <span class="o">-</span> <span class="n">maxbp_abs</span> <span class="o">*</span> <span class="n">T_t</span>
        <span class="p">)</span> <span class="o">+</span> <span class="n">characteristic</span> <span class="o">*</span> <span class="p">(</span><span class="n">T_t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">complementary_eq</span>

    <span class="k">def</span> <span class="nf">_momentum_balance_equation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">matrix_subdomains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Define the momentum balance equation in the matrix subdomain.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix_subdomains : List[pp.Grid]</span>
<span class="sd">            List of N-dimensional subdomains, usually with a single entry.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        momentum_eq : pp.ad.Operator</span>
<span class="sd">            The momentum balance equation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">div</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Divergence</span><span class="p">(</span><span class="n">subdomains</span><span class="o">=</span><span class="n">matrix_subdomains</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">)</span>

        <span class="n">stress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stress</span><span class="p">(</span><span class="n">matrix_subdomains</span><span class="p">)</span>
        <span class="c1"># Source term typically represents gravity</span>
        <span class="n">source_term</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">ParameterArray</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">,</span>
            <span class="s2">&quot;source&quot;</span><span class="p">,</span>
            <span class="n">matrix_subdomains</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">momentum_eq</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span> <span class="o">=</span> <span class="n">div</span> <span class="o">*</span> <span class="n">stress</span> <span class="o">-</span> <span class="n">source_term</span>
        <span class="k">return</span> <span class="n">momentum_eq</span>

    <span class="k">def</span> <span class="nf">_stress</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">matrix_subdomains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Ad representation of mechanical stress.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix_subdomains : List[pp.Grid]</span>
<span class="sd">            List of N-dimensional subdomains, usually with a single entry.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stress : pp.ad.Operator</span>
<span class="sd">            Stress operator.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ad</span>
        <span class="n">discr</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">MpsaAd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">,</span> <span class="n">matrix_subdomains</span><span class="p">)</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">BoundaryCondition</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_parameter_key</span><span class="p">,</span> <span class="n">subdomains</span><span class="o">=</span><span class="n">matrix_subdomains</span>
        <span class="p">)</span>
        <span class="n">stress</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">discr</span><span class="o">.</span><span class="n">stress</span> <span class="o">*</span> <span class="n">ad</span><span class="o">.</span><span class="n">displacement</span>
            <span class="o">+</span> <span class="n">discr</span><span class="o">.</span><span class="n">bound_stress</span> <span class="o">*</span> <span class="n">bc</span>
            <span class="o">+</span> <span class="n">discr</span><span class="o">.</span><span class="n">bound_stress</span>
            <span class="o">*</span> <span class="n">ad</span><span class="o">.</span><span class="n">subdomain_projections_vector</span><span class="o">.</span><span class="n">face_restriction</span><span class="p">(</span><span class="n">matrix_subdomains</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">ad</span><span class="o">.</span><span class="n">mortar_projections_vector</span><span class="o">.</span><span class="n">mortar_to_primary_avg</span>
            <span class="o">*</span> <span class="n">ad</span><span class="o">.</span><span class="n">interface_displacement</span>
        <span class="p">)</span>
        <span class="c1"># Name operator. &quot;Mechanical&quot; is intended as a distinction from e.g.</span>
        <span class="c1"># &quot;thermal stress&quot; (another component of THM stress) and</span>
        <span class="c1"># &quot;poromechanical stress&quot; (combination of mechanical and pressure)</span>
        <span class="n">stress</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;mechanical_stress&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stress</span>

    <span class="k">def</span> <span class="nf">_force_balance_equation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">matrix_subdomains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">],</span>
        <span class="n">fracture_subdomains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">],</span>
        <span class="n">interfaces</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Force balance equation at matrix-fracture interfaces.</span>

<span class="sd">        Args:</span>
<span class="sd">            matrix_subdomains : List[pp.Grid]</span>
<span class="sd">                Matrix subdomains, expected to be of length 1.</span>
<span class="sd">            fracture_subdomains: List[pp.Grid].</span>
<span class="sd">                Fracture subdomains.</span>
<span class="sd">            interfaces: List[pp.MortarGrid]</span>

<span class="sd">        Returns:</span>
<span class="sd">            Operator representing the force balance equation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ad</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix_subdomains</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Implementation assumes a single Nd grid&quot;</span><span class="p">)</span>

        <span class="c1"># Contact traction from primary grid and mortar displacements (via primary grid)</span>
        <span class="n">contact_from_primary_mortar</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">mortar_projections_vector</span><span class="o">.</span><span class="n">primary_to_mortar_int</span>
            <span class="o">*</span> <span class="n">ad</span><span class="o">.</span><span class="n">subdomain_projections_vector</span><span class="o">.</span><span class="n">face_prolongation</span><span class="p">(</span><span class="n">matrix_subdomains</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">ad</span><span class="o">.</span><span class="n">internal_boundary_vector_to_outwards</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stress</span><span class="p">(</span><span class="n">matrix_subdomains</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Traction from the actual contact force.</span>
        <span class="n">contact_from_secondary</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ad</span><span class="o">.</span><span class="n">mortar_projections_vector</span><span class="o">.</span><span class="n">sign_of_mortar_sides</span>
            <span class="o">*</span> <span class="n">ad</span><span class="o">.</span><span class="n">mortar_projections_vector</span><span class="o">.</span><span class="n">secondary_to_mortar_int</span>
            <span class="o">*</span> <span class="n">ad</span><span class="o">.</span><span class="n">subdomain_projections_vector</span><span class="o">.</span><span class="n">cell_prolongation</span><span class="p">(</span><span class="n">fracture_subdomains</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">ad</span><span class="o">.</span><span class="n">local_fracture_coord_transformation</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="o">*</span> <span class="n">ad</span><span class="o">.</span><span class="n">contact_force</span>
        <span class="p">)</span>
        <span class="n">force_balance_eq</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">contact_from_primary_mortar</span> <span class="o">+</span> <span class="n">contact_from_secondary</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">force_balance_eq</span>

    <span class="c1"># Methods for discretization, numerical issues etc.</span>

    <span class="k">def</span> <span class="nf">_discretize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Discretize all terms&quot;&quot;&quot;</span>
        <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Discretize&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_ad</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">equation_system</span><span class="o">.</span><span class="n">discretize</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assembler</span><span class="o">.</span><span class="n">discretize</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Done. Elapsed time </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tic</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_is_nonlinear_problem</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If there is no fracture, the problem is usually linear.</span>
<span class="sd">        Overwrite this function if e.g. parameter nonlinearities are included.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">dim_min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022 UiB Center for Modeling of Coupled Subsurface Dynamics, GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007..</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>