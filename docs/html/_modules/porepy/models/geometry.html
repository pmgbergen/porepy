

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>porepy.models.geometry &mdash; PorePy 1.6.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
    <link rel="canonical" href="https://pmgbergen.github.io/porepy/_modules/porepy/models/geometry.html" />
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=cfbabd6b"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            PorePy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docsrc/porepy/porepy.html">porepy package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.html">porepy.fracs package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture.html">porepy.fracs.fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_importer.html">porepy.fracs.fracture_importer module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_network_2d.html">porepy.fracs.fracture_network_2d module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html">porepy.fracs.fracture_network_3d module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.gmsh_interface.html">porepy.fracs.gmsh_interface module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.line_fracture.html">porepy.fracs.line_fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.meshing.html">porepy.fracs.meshing module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.msh_2_grid.html">porepy.fracs.msh_2_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.non_conforming.html">porepy.fracs.non_conforming module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.plane_fracture.html">porepy.fracs.plane_fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.simplex.html">porepy.fracs.simplex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.split_grid.html">porepy.fracs.split_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.structured.html">porepy.fracs.structured module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.tools.html">porepy.fracs.tools module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.utils.html">porepy.fracs.utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.wells_3d.html">porepy.fracs.wells_3d module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.html">porepy.geometry package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.bounding_box.html">porepy.geometry.bounding_box module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.constrain_geometry.html">porepy.geometry.constrain_geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.distances.html">porepy.geometry.distances module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.geometry_property_checks.html">porepy.geometry.geometry_property_checks module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.half_space.html">porepy.geometry.half_space module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.intersections.html">porepy.geometry.intersections module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.map_geometry.html">porepy.geometry.map_geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.point_in_polyhedron_test.html">porepy.geometry.point_in_polyhedron_test module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.html">porepy.grids package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.html">porepy.grids.standard_grids package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.md_grids_2d.html">porepy.grids.standard_grids.md_grids_2d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.md_grids_3d.html">porepy.grids.standard_grids.md_grids_3d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.utils.html">porepy.grids.standard_grids.utils module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.boundary_grid.html">porepy.grids.boundary_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.coarsening.html">porepy.grids.coarsening module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.grid.html">porepy.grids.grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.grid_extrusion.html">porepy.grids.grid_extrusion module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.match_grids.html">porepy.grids.match_grids module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.md_grid.html">porepy.grids.md_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.mortar_grid.html">porepy.grids.mortar_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.partition.html">porepy.grids.partition module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.point_grid.html">porepy.grids.point_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.refinement.html">porepy.grids.refinement module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.simplex.html">porepy.grids.simplex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.structured.html">porepy.grids.structured module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.html">porepy.models package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.html">porepy.models.verification_setups package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.manu_flow_comp_frac.html">porepy.models.verification_setups.manu_flow_comp_frac module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.manu_flow_incomp_frac.html">porepy.models.verification_setups.manu_flow_incomp_frac module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.manu_poromech_nofrac.html">porepy.models.verification_setups.manu_poromech_nofrac module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.verifications_utils.html">porepy.models.verification_setups.verifications_utils module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.abstract_equations.html">porepy.models.abstract_equations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.abstract_model.html">porepy.models.abstract_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.constitutive_laws.html">porepy.models.constitutive_laws module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.contact_mechanics_biot_model.html">porepy.models.contact_mechanics_biot_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.contact_mechanics_model.html">porepy.models.contact_mechanics_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.energy_balance.html">porepy.models.energy_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.fluid_mass_balance.html">porepy.models.fluid_mass_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.geometry.html">porepy.models.geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.incompressible_flow_model.html">porepy.models.incompressible_flow_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.mass_and_energy_balance.html">porepy.models.mass_and_energy_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.material_constants.html">porepy.models.material_constants module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.momentum_balance.html">porepy.models.momentum_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.poromechanics.html">porepy.models.poromechanics module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.run_models.html">porepy.models.run_models module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.slightly_compressible_flow_model.html">porepy.models.slightly_compressible_flow_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.solution_strategy.html">porepy.models.solution_strategy module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.thermoporomechanics.html">porepy.models.thermoporomechanics module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.thm_model.html">porepy.models.thm_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.units.html">porepy.models.units module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.html">porepy.numerics package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.html">porepy.numerics.ad package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.discretizations.html">porepy.numerics.ad.discretizations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.equation_manager.html">porepy.numerics.ad.equation_manager module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.equation_system.html">porepy.numerics.ad.equation_system module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.forward_mode.html">porepy.numerics.ad.forward_mode module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.functions.html">porepy.numerics.ad.functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.grid_operators.html">porepy.numerics.ad.grid_operators module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.operator_functions.html">porepy.numerics.ad.operator_functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.operators.html">porepy.numerics.ad.operators module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.time_derivatives.html">porepy.numerics.ad.time_derivatives module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fem.html">porepy.numerics.fem package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fem.rt0.html">porepy.numerics.fem.rt0 module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.html">porepy.numerics.fracture_deformation package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.conforming_propagation.html">porepy.numerics.fracture_deformation.conforming_propagation module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.contact_conditions.html">porepy.numerics.fracture_deformation.contact_conditions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.propagate_fracture.html">porepy.numerics.fracture_deformation.propagate_fracture module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.propagation_model.html">porepy.numerics.fracture_deformation.propagation_model module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.html">porepy.numerics.fv package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.biot.html">porepy.numerics.fv.biot module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.fv_elliptic.html">porepy.numerics.fv.fv_elliptic module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.fvutils.html">porepy.numerics.fv.fvutils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.mass_matrix.html">porepy.numerics.fv.mass_matrix module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.mpfa.html">porepy.numerics.fv.mpfa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.mpsa.html">porepy.numerics.fv.mpsa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.source.html">porepy.numerics.fv.source module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.tpfa.html">porepy.numerics.fv.tpfa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.upwind.html">porepy.numerics.fv.upwind module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.html">porepy.numerics.interface_laws package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.abstract_interface_law.html">porepy.numerics.interface_laws.abstract_interface_law module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.cell_dof_face_dof_map.html">porepy.numerics.interface_laws.cell_dof_face_dof_map module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.contact_mechanics_interface_laws.html">porepy.numerics.interface_laws.contact_mechanics_interface_laws module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.elliptic_discretization.html">porepy.numerics.interface_laws.elliptic_discretization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.elliptic_interface_laws.html">porepy.numerics.interface_laws.elliptic_interface_laws module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.hyperbolic_interface_laws.html">porepy.numerics.interface_laws.hyperbolic_interface_laws module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linalg.html">porepy.numerics.linalg package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linalg.matrix_operations.html">porepy.numerics.linalg.matrix_operations module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.html">porepy.numerics.mixed_dim package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler.html">porepy.numerics.mixed_dim.assembler module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler_filters.html">porepy.numerics.mixed_dim.assembler_filters module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.dof_manager.html">porepy.numerics.mixed_dim.dof_manager module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.nonlinear.html">porepy.numerics.nonlinear package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.nonlinear.nonlinear_solvers.html">porepy.numerics.nonlinear.nonlinear_solvers module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.solvers.html">porepy.numerics.solvers package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.solvers.andersonacceleration.html">porepy.numerics.solvers.andersonacceleration module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.html">porepy.numerics.vem package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.dual_elliptic.html">porepy.numerics.vem.dual_elliptic module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.hybrid.html">porepy.numerics.vem.hybrid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.mass_matrix.html">porepy.numerics.vem.mass_matrix module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.mvem.html">porepy.numerics.vem.mvem module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.vem_source.html">porepy.numerics.vem.vem_source module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.discretization.html">porepy.numerics.discretization module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.displacement_correlation.html">porepy.numerics.displacement_correlation module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linear_solvers.html">porepy.numerics.linear_solvers module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.time_step_control.html">porepy.numerics.time_step_control module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.html">porepy.params package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.bc.html">porepy.params.bc module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.data.html">porepy.params.data module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.fluid.html">porepy.params.fluid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.parameter_dictionaries.html">porepy.params.parameter_dictionaries module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.rock.html">porepy.params.rock module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.tensor.html">porepy.params.tensor module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.html">porepy.utils package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.derived_discretizations.html">porepy.utils.derived_discretizations package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.derived_discretizations.implicit_euler.html">porepy.utils.derived_discretizations.implicit_euler module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.accumarray.html">porepy.utils.accumarray module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.adtree.html">porepy.utils.adtree module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.array_operations.html">porepy.utils.array_operations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.common_constants.html">porepy.utils.common_constants module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.default_domains.html">porepy.utils.default_domains module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.error.html">porepy.utils.error module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.graph.html">porepy.utils.graph module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.grid_utils.html">porepy.utils.grid_utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.interpolation_tables.html">porepy.utils.interpolation_tables module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.mcolon.html">porepy.utils.mcolon module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.permutations.html">porepy.utils.permutations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.porepy_types.html">porepy.utils.porepy_types module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.setmembership.html">porepy.utils.setmembership module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.sort_points.html">porepy.utils.sort_points module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.tags.html">porepy.utils.tags module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.tangential_normal_projection.html">porepy.utils.tangential_normal_projection module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.html">porepy.viz package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.data_saving_model_mixin.html">porepy.viz.data_saving_model_mixin module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.exporter.html">porepy.viz.exporter module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.fracture_visualization.html">porepy.viz.fracture_visualization module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.plot_grid.html">porepy.viz.plot_grid module</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docsrc/howto/howto-docstring.html">1. How to docstring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docsrc/howto/howto-build-docs.html">2. How to build documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PorePy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">porepy.models.geometry</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for porepy.models.geometry</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Geometry definition for simulation setup.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.sparse</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sps</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">porepy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pp</span>


<div class="viewcode-block" id="ModelGeometry">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.geometry.html#porepy.models.geometry.ModelGeometry">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ModelGeometry</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This class provides geometry related methods and information for a simulation</span>
<span class="sd">    model.&quot;&quot;&quot;</span>

    <span class="c1"># Define attributes to be assigned later</span>
    <span class="n">fracture_network</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">FractureNetwork2d</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">FractureNetwork3d</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Representation of fracture network including intersections.&quot;&quot;&quot;</span>
    <span class="n">well_network</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">WellNetwork3d</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Well network.&quot;&quot;&quot;</span>
    <span class="n">mdg</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">MixedDimensionalGrid</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixed-dimensional grid. Set by the method :meth:`set_md_grid`.&quot;&quot;&quot;</span>
    <span class="n">domain_bounds</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Box-shaped domain. Set by the method :meth:`set_md_grid`.&quot;&quot;&quot;</span>
    <span class="n">nd</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ambient dimension of the problem. Set by the method :meth:`set_geometry`&quot;&quot;&quot;</span>
    <span class="n">units</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Units</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unit system.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ModelGeometry.set_geometry">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.geometry.html#porepy.models.geometry.ModelGeometry.set_geometry">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define geometry and create a mixed-dimensional grid.&quot;&quot;&quot;</span>
        <span class="c1"># Create fracture network and mixed-dimensional grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_fracture_network</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_md_grid</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">dim_max</span><span class="p">()</span>
        <span class="c1"># If fractures are present, it is advised to call</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">contact_conditions</span><span class="o">.</span><span class="n">set_projections</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="p">)</span></div>


<div class="viewcode-block" id="ModelGeometry.set_fracture_network">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.geometry.html#porepy.models.geometry.ModelGeometry.set_fracture_network">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_fracture_network</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assign fracture network class.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fracture_network</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">FractureNetwork2d</span><span class="p">()</span></div>


<div class="viewcode-block" id="ModelGeometry.mesh_arguments">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.geometry.html#porepy.models.geometry.ModelGeometry.mesh_arguments">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mesh_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mesh arguments for md-grid creation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            mesh_args: Dictionary of meshing arguments compatible with</span>
<span class="sd">                FractureNetwork.mesh() method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mesh_args</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="n">mesh_args</span></div>


<div class="viewcode-block" id="ModelGeometry.set_md_grid">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.geometry.html#porepy.models.geometry.ModelGeometry.set_md_grid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_md_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the mixed-dimensional grid.</span>

<span class="sd">        A unit square grid with no fractures is assigned by default if</span>
<span class="sd">        self.fracture_network contains no fractures. Otherwise, the network&#39;s mesh</span>
<span class="sd">        method is used.</span>

<span class="sd">        The method assigns the following attributes to self:</span>
<span class="sd">            mdg (pp.MixedDimensionalGrid): The produced grid bucket.</span>
<span class="sd">            box (dict): The bounding box of the domain, defined through minimum and</span>
<span class="sd">                maximum values in each dimension.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fracture_network</span><span class="o">.</span><span class="n">num_frac</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Length scale:</span>
            <span class="n">ls</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">m</span>
            <span class="c1"># Mono-dimensional grid by default</span>
            <span class="n">phys_dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">ls</span>
            <span class="n">n_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">domain_bounds</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">from_points</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">phys_dims</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="p">)</span>
            <span class="n">g</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">CartGrid</span><span class="p">(</span><span class="n">n_cells</span><span class="p">,</span> <span class="n">phys_dims</span><span class="p">)</span>
            <span class="n">g</span><span class="o">.</span><span class="n">compute_geometry</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">meshing</span><span class="o">.</span><span class="n">subdomains_to_mdg</span><span class="p">([[</span><span class="n">g</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fracture_network</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_arguments</span><span class="p">())</span>
            <span class="n">domain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fracture_network</span><span class="o">.</span><span class="n">domain</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">domain_bounds</span> <span class="o">=</span> <span class="n">domain</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">domain_bounds</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">from_points</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span></div>


<div class="viewcode-block" id="ModelGeometry.subdomains_to_interfaces">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.geometry.html#porepy.models.geometry.ModelGeometry.subdomains_to_interfaces">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">subdomains_to_interfaces</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">subdomains</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">],</span> <span class="n">codims</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interfaces neighbouring any of the subdomains.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            subdomains: Subdomains for which to find interfaces.</span>
<span class="sd">            codims: Codimension of interfaces to return. The common option is [1], i.e.</span>
<span class="sd">                only interfaces between subdomains one dimension apart.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Unique list of all interfaces neighboring any of the subdomains. Interfaces</span>
<span class="sd">            are sorted according to their index, as defined by the mixed-dimensional</span>
<span class="sd">            grid.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize list of interfaces, build it up one subdomain at a time.</span>
        <span class="n">interfaces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">subdomains</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">intf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomain_to_interfaces</span><span class="p">(</span><span class="n">sd</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">intf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">interfaces</span> <span class="ow">and</span> <span class="n">intf</span><span class="o">.</span><span class="n">codim</span> <span class="ow">in</span> <span class="n">codims</span><span class="p">:</span>
                    <span class="n">interfaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intf</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">sort_interfaces</span><span class="p">(</span><span class="n">interfaces</span><span class="p">)</span></div>


<div class="viewcode-block" id="ModelGeometry.interfaces_to_subdomains">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.geometry.html#porepy.models.geometry.ModelGeometry.interfaces_to_subdomains">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">interfaces_to_subdomains</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">interfaces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Subdomain neighbours of interfaces.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            interfaces: List of interfaces for which to find subdomains.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Unique list of all subdomains neighbouring any of the interfaces. The</span>
<span class="sd">            subdomains are sorted according to their index as defined by the</span>
<span class="sd">            mixed-dimensional grid.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">subdomains</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">interface</span> <span class="ow">in</span> <span class="n">interfaces</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_to_subdomain_pair</span><span class="p">(</span><span class="n">interface</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subdomains</span><span class="p">:</span>
                    <span class="n">subdomains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">sort_subdomains</span><span class="p">(</span><span class="n">subdomains</span><span class="p">)</span></div>


<div class="viewcode-block" id="ModelGeometry.wrap_grid_attribute">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.geometry.html#porepy.models.geometry.ModelGeometry.wrap_grid_attribute">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrap_grid_attribute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">grids</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">GridLike</span><span class="p">],</span>
        <span class="n">attr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">inverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrap a grid attribute as an ad matrix.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            grids: List of grids on which the property is defined.</span>
<span class="sd">            attr: Grid attribute to wrap. The attribute should be a ndarray and will be</span>
<span class="sd">                flattened if it is not already one dimensional.</span>
<span class="sd">            dim: Dimensions to include for vector attributes. Intended use is to</span>
<span class="sd">                limit the number of dimensions for a vector attribute, e.g. to exclude</span>
<span class="sd">                the z-component of a vector attribute in 2d, to acieve compatibility</span>
<span class="sd">                with code which is explicitly 2d (e.g. fv discretizations).</span>
<span class="sd">            inverse: If True, the inverse of the attribute will be wrapped. This is a</span>
<span class="sd">                hack around the fact that the Ad framework does not support division.</span>
<span class="sd">                FIXME: Remove when ad supports division.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The property wrapped as an ad matrix, with the wrapped attribute on the</span>
<span class="sd">            diagonal.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If one of the grids does not have the attribute.</span>
<span class="sd">            ValueError: If the attribute is not a ndarray.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: The enforcement of keyword-only arguments, combined with this class</span>
        <span class="c1"># being used as a mixin with other classes (thus this function represented as a</span>
        <span class="c1"># Callable in the other classes) does not make mypy happy. The problem seems to</span>
        <span class="c1"># be that a method specified as Callable must be called exactly as the type</span>
        <span class="c1"># specification, thus when this method is called with arguments</span>
        <span class="c1">#</span>
        <span class="c1">#   self.wrap_grid_attribute(..., dim=some_integer, ...)</span>
        <span class="c1">#</span>
        <span class="c1"># mypy will react on the difference between the type specification (that did not</span>
        <span class="c1"># include the dim argument) and the actual call. We also tried adding the *</span>
        <span class="c1"># (indicating the start of keyword-only in the type specification), but while</span>
        <span class="c1"># this made mypy happy, it is not vald syntax. The only viable solution (save</span>
        <span class="c1"># from using typing protocols, which we really do not want to do, there are</span>
        <span class="c1"># enough classes and inheritance in the mixin combination as it is) seems to be</span>
        <span class="c1"># to add a # type: ignore[call-args] comment where the method is called. By only</span>
        <span class="c1"># ignoring call-args problems, we limit the risk of silencing other errors that</span>
        <span class="c1"># mypy might find.</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Check that all grids have the sought after attribute. We could have</span>
            <span class="c1"># avoided this loop by surrounding the getattr with a try-except, but this</span>
            <span class="c1"># would have given a more convoluted code.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Grids do not have attribute </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Check that the attribute is a ndarray</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attribute </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2"> is not a ndarray&quot;</span><span class="p">)</span>

            <span class="c1"># NOTE: We do not rule out the combination of subdomains and interfaces</span>
            <span class="c1"># in the same list. There should be no chance of errors here, and although</span>
            <span class="c1"># such a case seems to EK at the moment to be a bit of an edge case, there</span>
            <span class="c1"># is no reason to rule it out.</span>

            <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Default to all dimensions</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Only include the first dim dimensions</span>
                <span class="c1"># We need to force the array to be 2d here, in case the dimension</span>
                <span class="c1"># argument is given for a non-vector attribute like cell_volumes.</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">attr</span><span class="p">))[:</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">vals</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For an empty list of grids, return an empty matrix</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="n">ad_matrix</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
        <span class="n">ad_matrix</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Matrix wrapping attribute </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2"> on </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">grids</span><span class="p">)</span><span class="si">}</span><span class="s2"> grids&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ad_matrix</span></div>


<div class="viewcode-block" id="ModelGeometry.basis">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.geometry.html#porepy.models.geometry.ModelGeometry.basis">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grids</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">GridLike</span><span class="p">],</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a cell-wise basis for all subdomains.</span>

<span class="sd">        The basis is represented as a list of matrices, each of which represents a</span>
<span class="sd">        basis function. The individual matrices have shape ``Nc * dim, Nc`` where ``Nc``</span>
<span class="sd">        is the total number of cells in the subdomains.</span>

<span class="sd">        Examples:</span>
<span class="sd">            To extend a cell-wise scalar to a vector field, use</span>
<span class="sd">            ``sum([e_i for e_i in basis(subdomains)])``. To restrict to a vector in the</span>
<span class="sd">            tangential direction only, use</span>
<span class="sd">            ``sum([e_i for e_i in basis(subdomains, dim=nd-1)])``</span>

<span class="sd">        See also:</span>
<span class="sd">            :meth:`e_i` for the construction of a single basis function.</span>
<span class="sd">            :meth:`normal_component` for the construction of a restriction to the</span>
<span class="sd">                normal component of a vector only.</span>
<span class="sd">            :meth:`tangential_component` for the construction of a restriction to the</span>
<span class="sd">                tangential component of a vector only.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            grids: List of grids on which the basis is defined.</span>
<span class="sd">            dim: Dimension of the basis.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of pp.ad.Matrix, each of which represents a basis function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: See self.wrap_grid_attribute for comments on typing when this method</span>
        <span class="c1"># is used as a mixin, and the need to add type-ignore[call-arg] on use of this</span>
        <span class="c1"># method.</span>

        <span class="k">assert</span> <span class="n">dim</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">,</span> <span class="s2">&quot;Basis functions of higher dimension than the md grid&quot;</span>
        <span class="c1"># Collect the basis functions for each dimension</span>
        <span class="n">basis</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">basis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">(</span><span class="n">grids</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">))</span>
        <span class="c1"># Stack the basis functions horizontally</span>
        <span class="k">return</span> <span class="n">basis</span></div>


<div class="viewcode-block" id="ModelGeometry.e_i">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.geometry.html#porepy.models.geometry.ModelGeometry.e_i">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">e_i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grids</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">GridLike</span><span class="p">],</span> <span class="o">*</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a cell-wise basis function in a specified dimension.</span>

<span class="sd">        It is assumed that the grids are embedded in a space of dimension dim and</span>
<span class="sd">        aligned with the coordinate axes, that is, the reference space of the grid.</span>
<span class="sd">        Moreover, the grid is assumed to be planar.</span>

<span class="sd">        Example:</span>
<span class="sd">            For a grid with two cells, and with `i=1` and `dim=3`, the returned basis</span>
<span class="sd">            will be (aftert conversion to a numpy array)</span>
<span class="sd">            .. code-block:: python</span>
<span class="sd">                array([[0., 0.],</span>
<span class="sd">                       [1., 0.],</span>
<span class="sd">                       [0., 0.],</span>
<span class="sd">                       [0., 0.],</span>
<span class="sd">                       [0., 1.],</span>
<span class="sd">                       [0., 0.]])</span>

<span class="sd">        See also:</span>
<span class="sd">            :meth:`basis` for the construction of a full basis.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            grids: List of grids on which the basis vector is defined.</span>
<span class="sd">            dim: Dimension of the functions.</span>
<span class="sd">            i: Index of the basis function. Note: Counts from 0.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pp.ad.Matrix: Ad representation of a matrix with the basis functions as</span>
<span class="sd">                columns.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If dim is smaller than the dimension of the mixed-dimensional.</span>
<span class="sd">            ValueError: If i is larger than dim.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: See self.wrap_grid_attribute for comments on typing when this method</span>
        <span class="c1"># is used as a mixin, and the need to add type-ignore[call-arg] on use of this</span>
        <span class="c1"># method.</span>

        <span class="c1"># TODO: Should we expand this to grids not aligned with the coordinate axes, and</span>
        <span class="c1"># possibly unify with ``porepy.utils.projections.TangentialNormalProjection``?</span>
        <span class="c1"># This is not a priority for the moment, though.</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span>

        <span class="c1"># Sanity checks</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Basis functions of higher dimension than the md grid&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Basis function index out of range&quot;</span><span class="p">)</span>

        <span class="c1"># Construct a single vector, and later stack it to a matrix</span>
        <span class="c1"># Collect the basis functions for each dimension</span>
        <span class="n">e_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">e_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Expand to cell-wise column vectors.</span>
        <span class="n">num_cells</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">g</span><span class="o">.</span><span class="n">num_cells</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">])</span>
        <span class="c1"># Expand to a matrix.</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">sps</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">num_cells</span><span class="p">),</span> <span class="n">e_i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span></div>


    <span class="c1"># Local basis related methods</span>
<div class="viewcode-block" id="ModelGeometry.tangential_component">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.geometry.html#porepy.models.geometry.ModelGeometry.tangential_component">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tangential_component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subdomains</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the tangential component of a vector field.</span>

<span class="sd">        The tangential space is defined according to the local coordinates of the</span>
<span class="sd">        subdomains, with the tangential space defined by the first `self.nd` components</span>
<span class="sd">        of the cell-wise vector. It is assumed that the components of the vector are</span>
<span class="sd">        stored with a dimension-major ordering (the dimension varies fastest).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            subdomains: List of grids on which the vector field is defined.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Operator extracting tangential component of the vector field and expressing</span>
<span class="sd">            it in tangential basis.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We first need an inner product (or dot product), i.e. extract the tangential</span>
        <span class="c1"># component of the cell-wise vector v to be transformed. Then we want to express</span>
        <span class="c1"># it in the tangential basis. The two operations are combined in a single</span>
        <span class="c1"># operator composed right to left: v will be hit by first e_i.T (row vector) and</span>
        <span class="c1"># secondly t_i (column vector).</span>
        <span class="n">op</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">(</span><span class="n">subdomains</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">(</span><span class="n">subdomains</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">op</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;tangential_component&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">op</span></div>


<div class="viewcode-block" id="ModelGeometry.normal_component">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.geometry.html#porepy.models.geometry.ModelGeometry.normal_component">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">normal_component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subdomains</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the normal component of a vector field.</span>

<span class="sd">        The normal space is defined according to the local coordinates of the</span>
<span class="sd">        subdomains, with the normal space defined by final component, e.g., number</span>
<span class="sd">        `self.nd-1` (zero offset). of the cell-wise vector. It is assumed that the</span>
<span class="sd">        components of a vector are stored with a dimension-major ordering (the dimension</span>
<span class="sd">        varies fastest).</span>

<span class="sd">        See also:</span>
<span class="sd">            :meth:`e_i` for the definition of the basis functions.</span>
<span class="sd">            :meth:`tangential_component` for the definition of the tangential space.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            subdomains: List of grids on which the vector field is defined.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Matrix extracting normal component of the vector field and expressing it</span>
<span class="sd">            in normal basis. The size of the matrix is `(Nc, Nc * self.nd)`, where</span>
<span class="sd">            `Nc` is the total number of cells in the subdomains.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the basis function for the normal component (which is known to be the</span>
        <span class="c1"># last component).</span>
        <span class="n">e_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_i</span><span class="p">(</span><span class="n">subdomains</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">)</span>
        <span class="n">e_n</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;normal_component&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">e_n</span><span class="o">.</span><span class="n">T</span></div>


<div class="viewcode-block" id="ModelGeometry.local_coordinates">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.geometry.html#porepy.models.geometry.ModelGeometry.local_coordinates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">local_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subdomains</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Ad wrapper around tangential_normal_projections for fractures.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            subdomains: List of subdomains for which to compute the local coordinates.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Local coordinates as a pp.ad.Matrix.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: If we ever implement a mapping to reference space for all subdomains,</span>
        <span class="c1"># the present method should be revisiting.</span>

        <span class="c1"># For now, assert all subdomains are fractures, i.e. dim == nd - 1.</span>
        <span class="c1"># TODO: Extend to all subdomains, not only codimension 1?</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">sd</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">subdomains</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subdomains</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Compute the local coordinates for each subdomain. For this, we use the</span>
            <span class="c1"># preset tangential_normal_projection attribute of the subdomains.</span>
            <span class="n">local_coord_proj_list</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomain_data</span><span class="p">(</span><span class="n">sd</span><span class="p">)[</span>
                    <span class="s2">&quot;tangential_normal_projection&quot;</span>
                <span class="p">]</span><span class="o">.</span><span class="n">project_tangential_normal</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">subdomains</span>
            <span class="p">]</span>
            <span class="n">local_coord_proj</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="n">local_coord_proj_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Also treat no subdomains</span>
            <span class="n">local_coord_proj</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">local_coord_proj</span><span class="p">)</span></div>


<div class="viewcode-block" id="ModelGeometry.subdomain_projections">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.geometry.html#porepy.models.geometry.ModelGeometry.subdomain_projections">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">subdomain_projections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">SubdomainProjections</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the projection operators for all subdomains in md-grid.</span>

<span class="sd">        The projection operators restrict or prolong a dim-dimensional quantity from the</span>
<span class="sd">        full set of subdomains to any subset. Projection operators are constructed once</span>
<span class="sd">        and then stored. If you need to use projection operators based on a different</span>
<span class="sd">        set of subdomains, please construct them yourself. Alternatively, compose a</span>
<span class="sd">        projection from subset A to subset B as</span>
<span class="sd">            P_A_to_B = P_full_to_B * P_A_to_full.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            dim: Dimension of the quantities to be projected.</span>

<span class="sd">        Returns:</span>
<span class="sd">            proj: Projection operator.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_subdomain_proj_of_dimension_</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
            <span class="n">proj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">proj</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">SubdomainProjections</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(),</span> <span class="n">dim</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">proj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">proj</span></div>


<div class="viewcode-block" id="ModelGeometry.domain_boundary_sides">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.geometry.html#porepy.models.geometry.ModelGeometry.domain_boundary_sides">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">domain_boundary_sides</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-10</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">DomainSides</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Obtain indices of the faces lying on the sides of the domain boundaries.</span>

<span class="sd">        The method is primarily intended for box-shaped domains. However, it can also be</span>
<span class="sd">        applied to non-box-shaped domains (e.g., domains with perturbed boundary nodes)</span>
<span class="sd">        provided `tol` is tuned accordingly.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            sd: Subdomain grid.</span>
<span class="sd">            tol: Tolerance used to determine whether a face center lies on a boundary side.</span>

<span class="sd">        Returns:</span>
<span class="sd">            NamedTuple containing the domain boundary sides. Available attributes are:</span>

<span class="sd">                - all_bf (np.ndarray of int): indices of the boundary faces.</span>
<span class="sd">                - east (np.ndarray of bool): flags of the faces lying on the East side.</span>
<span class="sd">                - west (np.ndarray of bool): flags of the faces lying on the West side.</span>
<span class="sd">                - north (np.ndarray of bool): flags of the faces lying on the North side.</span>
<span class="sd">                - south (np.ndarray of bool): flags of the faces lying on the South side.</span>
<span class="sd">                - top (np.ndarray of bool): flags of the faces lying on the Top side.</span>
<span class="sd">                - bottom (np.ndarray of bool): flags of the faces lying on Bottom side.</span>

<span class="sd">        Examples:</span>

<span class="sd">            .. code:: python</span>

<span class="sd">                model = pp.SinglePhaseFlow({})</span>
<span class="sd">                model.prepare_simulation()</span>
<span class="sd">                sd = model.mdg.subdomains()[0]</span>
<span class="sd">                sides = model.domain_boundary_sides(sd)</span>
<span class="sd">                # Access north faces using index or name is equivalent:</span>
<span class="sd">                north_by_index = sides[3]</span>
<span class="sd">                north_by_name = sides.north</span>
<span class="sd">                assert all(north_by_index == north_by_name)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get domain boundary sides</span>
        <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain_bounds</span>
        <span class="n">east</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="s2">&quot;xmax&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">sd</span><span class="o">.</span><span class="n">face_centers</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">tol</span>
        <span class="n">west</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="s2">&quot;xmin&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">sd</span><span class="o">.</span><span class="n">face_centers</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">tol</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">dim_max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">north</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">num_faces</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">south</span> <span class="o">=</span> <span class="n">north</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">north</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="s2">&quot;ymax&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">sd</span><span class="o">.</span><span class="n">face_centers</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">tol</span>
            <span class="n">south</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="s2">&quot;ymin&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">sd</span><span class="o">.</span><span class="n">face_centers</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">tol</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">dim_max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">num_faces</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="s2">&quot;zmax&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">sd</span><span class="o">.</span><span class="n">face_centers</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">tol</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="s2">&quot;zmin&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">sd</span><span class="o">.</span><span class="n">face_centers</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">tol</span>
        <span class="n">all_bf</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">get_boundary_faces</span><span class="p">()</span>

        <span class="c1"># Create a namedtuple to store the arrays</span>
        <span class="n">domain_sides</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">bounding_box</span><span class="o">.</span><span class="n">DomainSides</span><span class="p">(</span>
            <span class="n">all_bf</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">west</span><span class="p">,</span> <span class="n">north</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">bottom</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">domain_sides</span></div>


<div class="viewcode-block" id="ModelGeometry.internal_boundary_normal_to_outwards">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.geometry.html#porepy.models.geometry.ModelGeometry.internal_boundary_normal_to_outwards">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">internal_boundary_normal_to_outwards</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">subdomains</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Obtain a vector for flipping normal vectors on internal boundaries.</span>

<span class="sd">        For a list of subdomains, check if the normal vector on internal boundaries</span>
<span class="sd">        point into the internal interface (e.g., into the fracture), and if so, flip the</span>
<span class="sd">        normal vector. The flipping takes the form of an operator that multiplies the</span>
<span class="sd">        normal vectors of all faces on fractures, leaves internal faces (internal to the</span>
<span class="sd">        subdomain proper, that is) unchanged, but flips the relevant normal vectors on</span>
<span class="sd">        subdomain faces that are part of an internal boundary.</span>

<span class="sd">        Currently, this is a helper method for the computation of outward normals in</span>
<span class="sd">        :meth:`outwards_internal_boundary_normals`. Other usage is allowed, but one</span>
<span class="sd">        is adviced to carefully consider subdomain lists when combining this with other</span>
<span class="sd">        operators.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            subdomains: List of subdomains.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Operator with flipped signs if normal vector points inwards.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subdomains</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Special case if no interfaces.</span>
            <span class="n">sign_flipper</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># There is already a method to construct a switcher matrix in grid_utils,</span>
            <span class="c1"># so we use that. Loop over all subdomains, construct a local switcher</span>
            <span class="c1"># matrix and store it. The mixed-dimensional version can then be constructed</span>
            <span class="c1"># by block diagonal concatenation.</span>
            <span class="c1"># NOTE: While it is somewhat unfortunate to have the method in grid_utils,</span>
            <span class="c1"># since this leads to a more nested code, it also means we can use the</span>
            <span class="c1"># method outside the Ad framework. For the time being, we keep it.</span>
            <span class="n">matrices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">subdomains</span><span class="p">:</span>
                <span class="c1"># Use the tagging of fracture surfaces to identify the faces on internal</span>
                <span class="c1"># boundaries.</span>
                <span class="n">faces_on_fracture_surface</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s2">&quot;fracture_faces&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">switcher_int</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">grid_utils</span><span class="o">.</span><span class="n">switch_sign_if_inwards_normal</span><span class="p">(</span>
                    <span class="n">sd</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">faces_on_fracture_surface</span>
                <span class="p">)</span>
                <span class="n">matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">switcher_int</span><span class="p">)</span>

            <span class="c1"># Construct the block diagonal matrix.</span>
            <span class="n">sign_flipper</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">sps</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="n">matrices</span><span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">())</span>
        <span class="n">sign_flipper</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;Flip_normal_vectors&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sign_flipper</span></div>


<div class="viewcode-block" id="ModelGeometry.outwards_internal_boundary_normals">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.models.geometry.html#porepy.models.geometry.ModelGeometry.outwards_internal_boundary_normals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">outwards_internal_boundary_normals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">interfaces</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">unitary</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Operator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute outward normal vectors on internal boundaries.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            interfaces: List of interfaces.</span>
<span class="sd">            unitary: If True, return unit vectors, i.e. normalize by face area.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Operator computing outward normal vectors on internal boundaries. Evaluated</span>
<span class="sd">            shape `(num_intf_cells * dim, num_intf_cells * dim)`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: See self.wrap_grid_attribute for comments on typing when this method</span>
        <span class="c1"># is used as a mixin, and the need to add type-ignore[call-arg] on use of this</span>
        <span class="c1"># method.</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">interfaces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Special case if no interfaces.</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>

        <span class="c1"># Main ingredients: Normal vectors for primary subdomains for each interface,</span>
        <span class="c1"># and a switcher matrix to flip the sign if the normal vector points inwards.</span>
        <span class="c1"># The first is constructed herein, the second is a method of this class.</span>

        <span class="c1"># Since the normal vectors are stored on the primary subdomains, but are to be</span>
        <span class="c1"># computed on the interfaces, we need mortar projections.</span>

        <span class="c1"># Get hold of the primary subdomains, i.e. the higher-dimensional neighbors of</span>
        <span class="c1"># the interfaces.</span>
        <span class="n">primary_subdomains</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">intf</span> <span class="ow">in</span> <span class="n">interfaces</span><span class="p">:</span>
            <span class="n">primary_subdomains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_to_subdomain_pair</span><span class="p">(</span><span class="n">intf</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Projection operator between the subdomains and interfaces. The projection is</span>
        <span class="c1"># constructed to only consider the higher-dimensional subdomains.</span>
        <span class="n">mortar_projection</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">MortarProjections</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="p">,</span> <span class="n">primary_subdomains</span><span class="p">,</span> <span class="n">interfaces</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span>
        <span class="p">)</span>
        <span class="c1"># Ignore mypy complaint about unexpected keyword arguments.</span>
        <span class="n">primary_face_normals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap_grid_attribute</span><span class="p">(</span>  <span class="c1"># type: ignore[call-arg]</span>
            <span class="n">primary_subdomains</span><span class="p">,</span> <span class="s2">&quot;face_normals&quot;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="c1"># Account for sign of boundary face normals. This will give a matrix with a</span>
        <span class="c1"># shape equal to the total number of faces in all primary subdomains.</span>
        <span class="c1"># Ignore mypy complaint about unexpected keyword arguments.</span>
        <span class="n">flip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_boundary_normal_to_outwards</span><span class="p">(</span>
            <span class="n">primary_subdomains</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span>  <span class="c1"># type: ignore[call-arg]</span>
        <span class="p">)</span>
        <span class="c1"># Flip the normal vectors. Unravelled from the right: Restrict from faces on all</span>
        <span class="c1"># subdomains to the primary ones, multiply with the face normals, flip the</span>
        <span class="c1"># signs, and project back up to all subdomains.</span>
        <span class="n">flipped_normals</span> <span class="o">=</span> <span class="n">flip</span> <span class="o">*</span> <span class="n">primary_face_normals</span>
        <span class="c1"># Project to mortar grid, as a mapping from mortar to the subdomains and back</span>
        <span class="c1"># again.</span>
        <span class="n">outwards_normals</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">mortar_projection</span><span class="o">.</span><span class="n">primary_to_mortar_avg</span>
            <span class="o">*</span> <span class="n">flipped_normals</span>
            <span class="o">*</span> <span class="n">mortar_projection</span><span class="o">.</span><span class="n">mortar_to_primary_avg</span>
        <span class="p">)</span>
        <span class="n">outwards_normals</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;outwards_internal_boundary_normals&quot;</span><span class="p">)</span>

        <span class="c1"># Normalize by face area if requested.</span>
        <span class="k">if</span> <span class="n">unitary</span><span class="p">:</span>
            <span class="c1"># 1 over cell volumes on the interfaces</span>
            <span class="c1"># Ignore mypy complaint about unexpected keyword arguments.</span>
            <span class="n">cell_volumes_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap_grid_attribute</span><span class="p">(</span>  <span class="c1"># type: ignore[call-arg]</span>
                <span class="n">interfaces</span><span class="p">,</span> <span class="s2">&quot;cell_volumes&quot;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

            <span class="c1"># Expand cell volumes to nd by (from the right) mapping from nd to 1 (e.T),</span>
            <span class="c1"># multiplying with the cell volumes, mapping back to nd (e), and summing</span>
            <span class="c1"># over all dimensions.</span>
            <span class="c1"># EK: It should be possible to do this in a better, less opaque, way. A</span>
            <span class="c1"># Kronecker product comes to mind, but this will require an extension of the</span>
            <span class="c1"># Ad matrix.</span>
            <span class="n">cell_volumes_inv_nd</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="p">[</span><span class="n">e</span> <span class="o">*</span> <span class="n">cell_volumes_inv</span> <span class="o">*</span> <span class="n">e</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">interfaces</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nd</span><span class="p">)]</span>
            <span class="p">)</span>
            <span class="c1"># Scale normals.</span>
            <span class="n">outwards_normals</span> <span class="o">=</span> <span class="n">cell_volumes_inv_nd</span> <span class="o">*</span> <span class="n">outwards_normals</span>
            <span class="n">outwards_normals</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;unitary_outwards_internal_boundary_normals&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">outwards_normals</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022 UiB Center for Modeling of Coupled Subsurface Dynamics, GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007..</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>