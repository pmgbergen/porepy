

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>porepy.geometry.intersections &mdash; PorePy 1.6.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
    <link rel="canonical" href="https://pmgbergen.github.io/porepy/_modules/porepy/geometry/intersections.html" />
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=cfbabd6b"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            PorePy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docsrc/porepy/porepy.html">porepy package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.html">porepy.fracs package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture.html">porepy.fracs.fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_importer.html">porepy.fracs.fracture_importer module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_network_2d.html">porepy.fracs.fracture_network_2d module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html">porepy.fracs.fracture_network_3d module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.gmsh_interface.html">porepy.fracs.gmsh_interface module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.line_fracture.html">porepy.fracs.line_fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.meshing.html">porepy.fracs.meshing module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.msh_2_grid.html">porepy.fracs.msh_2_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.non_conforming.html">porepy.fracs.non_conforming module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.plane_fracture.html">porepy.fracs.plane_fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.simplex.html">porepy.fracs.simplex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.split_grid.html">porepy.fracs.split_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.structured.html">porepy.fracs.structured module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.tools.html">porepy.fracs.tools module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.utils.html">porepy.fracs.utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.wells_3d.html">porepy.fracs.wells_3d module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.html">porepy.geometry package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.bounding_box.html">porepy.geometry.bounding_box module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.constrain_geometry.html">porepy.geometry.constrain_geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.distances.html">porepy.geometry.distances module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.geometry_property_checks.html">porepy.geometry.geometry_property_checks module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.half_space.html">porepy.geometry.half_space module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.intersections.html">porepy.geometry.intersections module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.map_geometry.html">porepy.geometry.map_geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.point_in_polyhedron_test.html">porepy.geometry.point_in_polyhedron_test module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.html">porepy.grids package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.html">porepy.grids.standard_grids package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.md_grids_2d.html">porepy.grids.standard_grids.md_grids_2d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.md_grids_3d.html">porepy.grids.standard_grids.md_grids_3d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.utils.html">porepy.grids.standard_grids.utils module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.boundary_grid.html">porepy.grids.boundary_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.coarsening.html">porepy.grids.coarsening module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.grid.html">porepy.grids.grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.grid_extrusion.html">porepy.grids.grid_extrusion module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.match_grids.html">porepy.grids.match_grids module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.md_grid.html">porepy.grids.md_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.mortar_grid.html">porepy.grids.mortar_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.partition.html">porepy.grids.partition module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.point_grid.html">porepy.grids.point_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.refinement.html">porepy.grids.refinement module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.simplex.html">porepy.grids.simplex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.structured.html">porepy.grids.structured module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.html">porepy.models package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.html">porepy.models.verification_setups package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.manu_flow_comp_frac.html">porepy.models.verification_setups.manu_flow_comp_frac module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.manu_flow_incomp_frac.html">porepy.models.verification_setups.manu_flow_incomp_frac module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.manu_poromech_nofrac.html">porepy.models.verification_setups.manu_poromech_nofrac module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.verification_setups.verifications_utils.html">porepy.models.verification_setups.verifications_utils module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.abstract_equations.html">porepy.models.abstract_equations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.abstract_model.html">porepy.models.abstract_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.constitutive_laws.html">porepy.models.constitutive_laws module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.contact_mechanics_biot_model.html">porepy.models.contact_mechanics_biot_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.contact_mechanics_model.html">porepy.models.contact_mechanics_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.energy_balance.html">porepy.models.energy_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.fluid_mass_balance.html">porepy.models.fluid_mass_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.geometry.html">porepy.models.geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.incompressible_flow_model.html">porepy.models.incompressible_flow_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.mass_and_energy_balance.html">porepy.models.mass_and_energy_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.material_constants.html">porepy.models.material_constants module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.momentum_balance.html">porepy.models.momentum_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.poromechanics.html">porepy.models.poromechanics module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.run_models.html">porepy.models.run_models module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.slightly_compressible_flow_model.html">porepy.models.slightly_compressible_flow_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.solution_strategy.html">porepy.models.solution_strategy module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.thermoporomechanics.html">porepy.models.thermoporomechanics module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.thm_model.html">porepy.models.thm_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.units.html">porepy.models.units module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.html">porepy.numerics package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.html">porepy.numerics.ad package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.discretizations.html">porepy.numerics.ad.discretizations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.equation_manager.html">porepy.numerics.ad.equation_manager module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.equation_system.html">porepy.numerics.ad.equation_system module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.forward_mode.html">porepy.numerics.ad.forward_mode module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.functions.html">porepy.numerics.ad.functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.grid_operators.html">porepy.numerics.ad.grid_operators module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.operator_functions.html">porepy.numerics.ad.operator_functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.operators.html">porepy.numerics.ad.operators module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.time_derivatives.html">porepy.numerics.ad.time_derivatives module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fem.html">porepy.numerics.fem package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fem.rt0.html">porepy.numerics.fem.rt0 module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.html">porepy.numerics.fracture_deformation package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.conforming_propagation.html">porepy.numerics.fracture_deformation.conforming_propagation module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.contact_conditions.html">porepy.numerics.fracture_deformation.contact_conditions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.propagate_fracture.html">porepy.numerics.fracture_deformation.propagate_fracture module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.propagation_model.html">porepy.numerics.fracture_deformation.propagation_model module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.html">porepy.numerics.fv package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.biot.html">porepy.numerics.fv.biot module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.fv_elliptic.html">porepy.numerics.fv.fv_elliptic module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.fvutils.html">porepy.numerics.fv.fvutils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.mass_matrix.html">porepy.numerics.fv.mass_matrix module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.mpfa.html">porepy.numerics.fv.mpfa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.mpsa.html">porepy.numerics.fv.mpsa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.source.html">porepy.numerics.fv.source module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.tpfa.html">porepy.numerics.fv.tpfa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.upwind.html">porepy.numerics.fv.upwind module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.html">porepy.numerics.interface_laws package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.abstract_interface_law.html">porepy.numerics.interface_laws.abstract_interface_law module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.cell_dof_face_dof_map.html">porepy.numerics.interface_laws.cell_dof_face_dof_map module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.contact_mechanics_interface_laws.html">porepy.numerics.interface_laws.contact_mechanics_interface_laws module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.elliptic_discretization.html">porepy.numerics.interface_laws.elliptic_discretization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.elliptic_interface_laws.html">porepy.numerics.interface_laws.elliptic_interface_laws module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.hyperbolic_interface_laws.html">porepy.numerics.interface_laws.hyperbolic_interface_laws module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linalg.html">porepy.numerics.linalg package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linalg.matrix_operations.html">porepy.numerics.linalg.matrix_operations module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.html">porepy.numerics.mixed_dim package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler.html">porepy.numerics.mixed_dim.assembler module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler_filters.html">porepy.numerics.mixed_dim.assembler_filters module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.dof_manager.html">porepy.numerics.mixed_dim.dof_manager module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.nonlinear.html">porepy.numerics.nonlinear package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.nonlinear.nonlinear_solvers.html">porepy.numerics.nonlinear.nonlinear_solvers module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.solvers.html">porepy.numerics.solvers package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.solvers.andersonacceleration.html">porepy.numerics.solvers.andersonacceleration module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.html">porepy.numerics.vem package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.dual_elliptic.html">porepy.numerics.vem.dual_elliptic module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.hybrid.html">porepy.numerics.vem.hybrid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.mass_matrix.html">porepy.numerics.vem.mass_matrix module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.mvem.html">porepy.numerics.vem.mvem module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.vem_source.html">porepy.numerics.vem.vem_source module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.discretization.html">porepy.numerics.discretization module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.displacement_correlation.html">porepy.numerics.displacement_correlation module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linear_solvers.html">porepy.numerics.linear_solvers module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.time_step_control.html">porepy.numerics.time_step_control module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.html">porepy.params package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.bc.html">porepy.params.bc module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.data.html">porepy.params.data module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.fluid.html">porepy.params.fluid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.parameter_dictionaries.html">porepy.params.parameter_dictionaries module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.rock.html">porepy.params.rock module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.tensor.html">porepy.params.tensor module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.html">porepy.utils package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.derived_discretizations.html">porepy.utils.derived_discretizations package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.derived_discretizations.implicit_euler.html">porepy.utils.derived_discretizations.implicit_euler module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.accumarray.html">porepy.utils.accumarray module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.adtree.html">porepy.utils.adtree module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.array_operations.html">porepy.utils.array_operations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.common_constants.html">porepy.utils.common_constants module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.default_domains.html">porepy.utils.default_domains module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.error.html">porepy.utils.error module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.graph.html">porepy.utils.graph module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.grid_utils.html">porepy.utils.grid_utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.interpolation_tables.html">porepy.utils.interpolation_tables module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.mcolon.html">porepy.utils.mcolon module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.permutations.html">porepy.utils.permutations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.porepy_types.html">porepy.utils.porepy_types module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.setmembership.html">porepy.utils.setmembership module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.sort_points.html">porepy.utils.sort_points module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.tags.html">porepy.utils.tags module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.tangential_normal_projection.html">porepy.utils.tangential_normal_projection module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.html">porepy.viz package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.data_saving_model_mixin.html">porepy.viz.data_saving_model_mixin module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.exporter.html">porepy.viz.exporter module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.fracture_visualization.html">porepy.viz.fracture_visualization module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.plot_grid.html">porepy.viz.plot_grid module</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docsrc/howto/howto-docstring.html">1. How to docstring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docsrc/howto/howto-build-docs.html">2. How to build documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PorePy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">porepy.geometry.intersections</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for porepy.geometry.intersections</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Module with functions for computing intersections between geometric objects.&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.sparse</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sps</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">porepy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pp</span>

<span class="c1"># Module level logger</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="segments_2d">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.geometry.intersections.html#porepy.geometry.intersections.segments_2d">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">segments_2d</span><span class="p">(</span>
    <span class="n">start_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">end_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">start_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">end_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Check if two line segments, defined by their start- and endpoints, intersect.</span>

<span class="sd">    The lines are assumed to be in 2D.</span>

<span class="sd">    If the lines are (almost) parallel, i.e. if</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{vmatrix}</span>
<span class="sd">            start_1 &amp; end_1 \\</span>
<span class="sd">            start_2 &amp; end_2</span>
<span class="sd">        \end{vmatrix}\leq tol\times|start_1-end_1|\times|start_2-end_2|,</span>

<span class="sd">    a line segment is returned instead of an intersection point.</span>

<span class="sd">    Todo:</span>
<span class="sd">        This function can be replaced by a call to :meth:`segments_3d`.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; segments_2d([0, 0], [1, 1], [0, 1], [1, 0])</span>
<span class="sd">        array([[ 0.5],</span>
<span class="sd">               [ 0.5]])</span>

<span class="sd">        &gt;&gt;&gt; segments_2d([0, 0], [1, 1], [0, 0], [2, 2])</span>
<span class="sd">        array([[0., 1.],</span>
<span class="sd">               [0., 1.]])</span>

<span class="sd">        &gt;&gt;&gt; segments_2d([0, 0], [1, 0], [0, 1], [1, 1]) is None</span>
<span class="sd">        True</span>

<span class="sd">    Parameters:</span>
<span class="sd">        start_1: ``shape=(2,)``</span>

<span class="sd">            Coordinates of start point for first line.</span>
<span class="sd">        end_1: ``shape=(2,)``</span>

<span class="sd">            Coordinates of end point for first line.</span>
<span class="sd">        start_2: ``shape=(2,)``</span>

<span class="sd">            Coordinates of start point for first line.</span>
<span class="sd">        end_2: ``shape=(2,)``</span>

<span class="sd">            Coordinates of end point for first line.</span>
<span class="sd">        tol: ``default=1e-8``</span>

<span class="sd">            Tolerance for detecting parallel lines.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the start and endpoints of a line are the same.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Coordinates of intersection point, or the endpoints of the intersection segments</span>
<span class="sd">        if relevant. In the case of a segment, the first point (column) will be closest</span>
<span class="sd">        to ``start_1``. Shape is ``(2, np)``, where ``np`` is ``1`` for a point</span>
<span class="sd">        intersection, or ``2`` for a segment intersection. If the lines do not</span>
<span class="sd">        intersect, ``None`` is returned.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">start_1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">end_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">end_1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">start_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">start_2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">end_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">end_2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Vectors along first and second line</span>
    <span class="n">d_1</span> <span class="o">=</span> <span class="n">end_1</span> <span class="o">-</span> <span class="n">start_1</span>
    <span class="n">d_2</span> <span class="o">=</span> <span class="n">end_2</span> <span class="o">-</span> <span class="n">start_2</span>

    <span class="n">length_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d_1</span> <span class="o">*</span> <span class="n">d_1</span><span class="p">))</span>
    <span class="n">length_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d_2</span> <span class="o">*</span> <span class="n">d_2</span><span class="p">))</span>

    <span class="c1"># Vector between the start points</span>
    <span class="n">d_s</span> <span class="o">=</span> <span class="n">start_2</span> <span class="o">-</span> <span class="n">start_1</span>

    <span class="c1"># An intersection point is characterized by</span>
    <span class="c1">#   start_1 + d_1 * t_1 = start_2 + d_2 * t_2</span>
    <span class="c1">#</span>
    <span class="c1"># which on component form becomes</span>
    <span class="c1">#</span>
    <span class="c1">#   d_1[0] * t_1 - d_2[0] * t_2 = d_s[0]</span>
    <span class="c1">#   d_1[1] * t_1 - d_2[1] * t_2 = d_s[1]</span>
    <span class="c1">#</span>
    <span class="c1"># First check for solvability of the system (e.g. parallel lines) by the determinant</span>
    <span class="c1"># of the matrix.</span>

    <span class="n">discr</span> <span class="o">=</span> <span class="n">d_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">d_2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">d_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">d_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Check if lines are parallel.</span>
    <span class="c1"># The tolerance should be relative to the length of d_1 and d_2</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">discr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">length_1</span> <span class="o">*</span> <span class="n">length_2</span><span class="p">:</span>
        <span class="c1"># The lines are parallel, and will only cross if they are also colinear</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;The segments are parallel&quot;</span><span class="p">)</span>
        <span class="c1"># Cross product between line 1 and line between start points on line</span>
        <span class="n">start_cross_line</span> <span class="o">=</span> <span class="n">d_s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d_s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">start_cross_line</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">length_1</span><span class="p">,</span> <span class="n">length_2</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Lines are colinear&quot;</span><span class="p">)</span>
            <span class="c1"># The lines are co-linear</span>

            <span class="c1"># Write l1 on the form start_1 + t * d_1, find the parameter value needed</span>
            <span class="c1"># for equality with start_2 and end_2</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">length_1</span><span class="p">:</span>
                <span class="n">t_start_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">d_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">t_end_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">d_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d_1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">length_2</span><span class="p">:</span>
                <span class="n">t_start_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">d_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">t_end_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">d_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># d_1 is zero</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Found what must be a point-edge&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Start and endpoint of line should be different&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t_start_2</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">t_end_2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Lines are not overlapping&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">t_start_2</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">t_end_2</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Lines are not overlapping&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="c1"># We have an overlap, find its parameter values</span>
            <span class="n">t_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">t_start_2</span><span class="p">,</span> <span class="n">t_end_2</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">t_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">t_start_2</span><span class="p">,</span> <span class="n">t_end_2</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">t_max</span> <span class="o">-</span> <span class="n">t_min</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="c1"># It seems this can only happen if they are also equal to 0 or 1, that</span>
                <span class="c1"># is, the lines share a single point</span>
                <span class="n">p_1</span> <span class="o">=</span> <span class="n">start_1</span> <span class="o">+</span> <span class="n">d_1</span> <span class="o">*</span> <span class="n">t_min</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Colinear lines share a single point&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">p_1</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Colinear lines intersect along segment&quot;</span><span class="p">)</span>
            <span class="n">p_1</span> <span class="o">=</span> <span class="n">start_1</span> <span class="o">+</span> <span class="n">d_1</span> <span class="o">*</span> <span class="n">t_min</span>
            <span class="n">p_2</span> <span class="o">=</span> <span class="n">start_1</span> <span class="o">+</span> <span class="n">d_1</span> <span class="o">*</span> <span class="n">t_max</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">p_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">p_1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Lines are not colinear&quot;</span><span class="p">)</span>
            <span class="c1"># Lines are parallel, but not colinear</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Solve linear system using Cramer&#39;s rule</span>
        <span class="n">t_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">d_s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">d_2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">d_s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">d_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">/</span> <span class="n">discr</span>
        <span class="n">t_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">d_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">discr</span>

        <span class="n">isect_1</span> <span class="o">=</span> <span class="n">start_1</span> <span class="o">+</span> <span class="n">t_1</span> <span class="o">*</span> <span class="n">d_1</span>
        <span class="n">isect_2</span> <span class="o">=</span> <span class="n">start_2</span> <span class="o">+</span> <span class="n">t_2</span> <span class="o">*</span> <span class="n">d_2</span>
        <span class="c1"># Safeguarding</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">isect_1</span><span class="p">,</span> <span class="n">isect_2</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

        <span class="c1"># The intersection lies on both segments if both t_1 and t_2 are on the unit</span>
        <span class="c1"># interval.</span>
        <span class="c1"># Use tol to allow some approximations</span>
        <span class="k">if</span> <span class="n">t_1</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">tol</span> <span class="ow">and</span> <span class="n">t_1</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">tol</span><span class="p">)</span> <span class="ow">and</span> <span class="n">t_2</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">tol</span> <span class="ow">and</span> <span class="n">t_2</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">tol</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Segment intersection found in one point&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">isect_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">isect_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>

        <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="segments_3d">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.geometry.intersections.html#porepy.geometry.intersections.segments_3d">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">segments_3d</span><span class="p">(</span>
    <span class="n">start_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">end_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">start_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">end_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find intersection points (or segments) of two 3d lines.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        start_1: ``shape=(3,)``</span>

<span class="sd">            Coordinates of start point for first line.</span>
<span class="sd">        end_1: ``shape=(3,)``</span>

<span class="sd">            Coordinates of end point for first line.</span>
<span class="sd">        start_2: ``shape=(3,)``</span>

<span class="sd">            Coordinates of start point for first line.</span>
<span class="sd">        end_2: ``shape=(3,)``</span>

<span class="sd">            Coordinates of end point for first line.</span>
<span class="sd">        tol: ``default=1e-8``</span>

<span class="sd">            Tolerance for detecting parallel lines.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Coordinates of intersection points. Shape is ``(3, np)``, where ``np`` is ``1``</span>
<span class="sd">        for a point intersection, or ``2`` for a segment intersection. If the lines do</span>
<span class="sd">        not intersect, ``None`` is returned.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Shorthand for component of start and end points, as well as vectors</span>
    <span class="c1"># along lines.</span>
    <span class="n">xs_1</span> <span class="o">=</span> <span class="n">start_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ys_1</span> <span class="o">=</span> <span class="n">start_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">zs_1</span> <span class="o">=</span> <span class="n">start_1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">xe_1</span> <span class="o">=</span> <span class="n">end_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ye_1</span> <span class="o">=</span> <span class="n">end_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ze_1</span> <span class="o">=</span> <span class="n">end_1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">dx_1</span> <span class="o">=</span> <span class="n">xe_1</span> <span class="o">-</span> <span class="n">xs_1</span>
    <span class="n">dy_1</span> <span class="o">=</span> <span class="n">ye_1</span> <span class="o">-</span> <span class="n">ys_1</span>
    <span class="n">dz_1</span> <span class="o">=</span> <span class="n">ze_1</span> <span class="o">-</span> <span class="n">zs_1</span>

    <span class="n">xs_2</span> <span class="o">=</span> <span class="n">start_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ys_2</span> <span class="o">=</span> <span class="n">start_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">zs_2</span> <span class="o">=</span> <span class="n">start_2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">xe_2</span> <span class="o">=</span> <span class="n">end_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ye_2</span> <span class="o">=</span> <span class="n">end_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ze_2</span> <span class="o">=</span> <span class="n">end_2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">dx_2</span> <span class="o">=</span> <span class="n">xe_2</span> <span class="o">-</span> <span class="n">xs_2</span>
    <span class="n">dy_2</span> <span class="o">=</span> <span class="n">ye_2</span> <span class="o">-</span> <span class="n">ys_2</span>
    <span class="n">dz_2</span> <span class="o">=</span> <span class="n">ze_2</span> <span class="o">-</span> <span class="n">zs_2</span>

    <span class="c1"># The lines are parallel in the x-y plane, but we don&#39;t know about the</span>
    <span class="c1"># z-direction. Check this.</span>
    <span class="n">deltas_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dx_1</span><span class="p">,</span> <span class="n">dy_1</span><span class="p">,</span> <span class="n">dz_1</span><span class="p">])</span>
    <span class="n">deltas_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dx_2</span><span class="p">,</span> <span class="n">dy_2</span><span class="p">,</span> <span class="n">dz_2</span><span class="p">])</span>

    <span class="c1"># Find non-zero elements</span>
    <span class="n">mask_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">deltas_1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span>
    <span class="n">mask_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">deltas_2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span>

    <span class="c1"># Check for two dimensions that are not parallel with at least one line</span>
    <span class="n">mask_sum</span> <span class="o">=</span> <span class="n">mask_1</span> <span class="o">+</span> <span class="n">mask_2</span>

    <span class="k">if</span> <span class="n">mask_sum</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mask_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">mask_sum</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">in_discr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">not_in_discr</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="n">mask_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">mask_sum</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">in_discr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">not_in_discr</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">in_discr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">not_in_discr</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># We&#39;re going to have a zero discriminant anyhow, just pick some dimensions.</span>
        <span class="n">in_discr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">not_in_discr</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="n">discr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">deltas_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">deltas_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="o">-</span> <span class="n">deltas_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="n">deltas_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="p">)</span>

    <span class="c1"># An intersection will be a solution of the linear system</span>
    <span class="c1">#   xs_1 + dx_1 * t_1 = xs_2 + dx_2 * t_2 (1)</span>
    <span class="c1">#   ys_1 + dy_1 * t_1 = ys_2 + dy_2 * t_2 (2)</span>
    <span class="c1">#</span>
    <span class="c1"># In addition, the solution should satisfy</span>
    <span class="c1">#   zs_1 + dz_1 * t_1 = zs_2 + dz_2 * t_2 (3)</span>
    <span class="c1">#</span>
    <span class="c1"># The intersection is on the line segments if 0 &lt;= (t_1, t_2) &lt;= 1</span>

    <span class="c1"># Either the lines are parallel in two directions</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">discr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
        <span class="c1"># If the lines are (almost) parallel, there is no single intersection, but it</span>
        <span class="c1"># may be a segment.</span>

        <span class="c1"># First check if the third dimension is also parallel, if not, no intersection.</span>

        <span class="c1"># A first, simple test</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask_1</span> <span class="o">!=</span> <span class="n">mask_2</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">deltas_1</span><span class="p">[</span><span class="n">mask_1</span><span class="p">]</span> <span class="o">/</span> <span class="n">deltas_2</span><span class="p">[</span><span class="n">mask_2</span><span class="p">]</span>

        <span class="c1"># Second, test for alignment in all directions</span>
        <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># If we have made it this far, the lines are indeed parallel. Next, check that</span>
        <span class="c1"># they lay along the same line.</span>
        <span class="n">diff_start</span> <span class="o">=</span> <span class="n">start_2</span> <span class="o">-</span> <span class="n">start_1</span>

        <span class="n">dstart_x_delta_x</span> <span class="o">=</span> <span class="n">diff_start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">deltas_1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">diff_start</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">deltas_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dstart_x_delta_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">dstart_x_delta_y</span> <span class="o">=</span> <span class="n">diff_start</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">deltas_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">diff_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">deltas_1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dstart_x_delta_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">dstart_x_delta_z</span> <span class="o">=</span> <span class="n">diff_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">deltas_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">diff_start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">deltas_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dstart_x_delta_z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># For dimensions with an incline, the vector between segment start points should</span>
        <span class="c1"># be parallel to the segments. Since the masks are equal, we can use any of</span>
        <span class="c1"># them. For dimensions with no incline, the start coordinates should be the</span>
        <span class="c1"># same.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">start_1</span><span class="p">[</span><span class="o">~</span><span class="n">mask_1</span><span class="p">],</span> <span class="n">start_2</span><span class="p">[</span><span class="o">~</span><span class="n">mask_1</span><span class="p">],</span> <span class="n">tol</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># We have overlapping lines! finally check if segments are overlapping.</span>

        <span class="c1"># Since everything is parallel, it suffices to work with a single coordinate</span>
        <span class="n">s_1</span> <span class="o">=</span> <span class="n">start_1</span><span class="p">[</span><span class="n">mask_1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">e_1</span> <span class="o">=</span> <span class="n">end_1</span><span class="p">[</span><span class="n">mask_1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">s_2</span> <span class="o">=</span> <span class="n">start_2</span><span class="p">[</span><span class="n">mask_1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">e_2</span> <span class="o">=</span> <span class="n">end_2</span><span class="p">[</span><span class="n">mask_1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">max_1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">s_1</span><span class="p">,</span> <span class="n">e_1</span><span class="p">)</span>
        <span class="n">min_1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">s_1</span><span class="p">,</span> <span class="n">e_1</span><span class="p">)</span>
        <span class="n">max_2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">s_2</span><span class="p">,</span> <span class="n">e_2</span><span class="p">)</span>
        <span class="n">min_2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">s_2</span><span class="p">,</span> <span class="n">e_2</span><span class="p">)</span>

        <span class="c1"># Rule out case with non-overlapping segments</span>
        <span class="k">if</span> <span class="n">max_1</span> <span class="o">&lt;</span> <span class="n">min_2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">max_2</span> <span class="o">&lt;</span> <span class="n">min_1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># The lines are overlapping, we need to find their common line</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s_1</span><span class="p">,</span> <span class="n">e_1</span><span class="p">,</span> <span class="n">s_2</span><span class="p">,</span> <span class="n">e_2</span><span class="p">])</span>
        <span class="n">sort_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

        <span class="c1"># The overlap will be between the middle two points in the sorted list</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">sort_ind</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

        <span class="c1"># Array of the full coordinates - same order as lines</span>
        <span class="n">lines_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">start_1</span><span class="p">,</span> <span class="n">end_1</span><span class="p">,</span> <span class="n">start_2</span><span class="p">,</span> <span class="n">end_2</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="c1"># Our segment consists of the second and third column. We&#39;re done!</span>
        <span class="k">return</span> <span class="n">lines_full</span><span class="p">[:,</span> <span class="n">target</span><span class="p">]</span>

    <span class="c1"># or we are looking for a point intersection</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Solve 2x2 system by Cramer&#39;s rule</span>

        <span class="n">discr</span> <span class="o">=</span> <span class="n">deltas_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">deltas_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">-</span> <span class="n">deltas_1</span><span class="p">[</span>
            <span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">deltas_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">t_1</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">start_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">start_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">deltas_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="o">-</span> <span class="p">(</span><span class="n">start_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">start_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">deltas_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="p">)</span> <span class="o">/</span> <span class="n">discr</span>

        <span class="n">t_2</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">deltas_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="p">(</span><span class="n">start_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">start_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="o">-</span> <span class="n">deltas_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="p">(</span><span class="n">start_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">start_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="p">)</span> <span class="o">/</span> <span class="n">discr</span>

        <span class="c1"># Check that we are on the line segment</span>
        <span class="k">if</span> <span class="n">t_1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">t_1</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">t_2</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">t_2</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Compute the z-coordinates of the intersection points</span>
        <span class="n">z_1_isect</span> <span class="o">=</span> <span class="n">start_1</span><span class="p">[</span><span class="n">not_in_discr</span><span class="p">]</span> <span class="o">+</span> <span class="n">t_1</span> <span class="o">*</span> <span class="n">deltas_1</span><span class="p">[</span><span class="n">not_in_discr</span><span class="p">]</span>
        <span class="n">z_2_isect</span> <span class="o">=</span> <span class="n">start_2</span><span class="p">[</span><span class="n">not_in_discr</span><span class="p">]</span> <span class="o">+</span> <span class="n">t_2</span> <span class="o">*</span> <span class="n">deltas_2</span><span class="p">[</span><span class="n">not_in_discr</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z_1_isect</span> <span class="o">-</span> <span class="n">z_2_isect</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">vec</span><span class="p">[</span><span class="n">in_discr</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">]</span> <span class="o">+</span> <span class="n">t_1</span> <span class="o">*</span> <span class="n">deltas_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">]</span>
            <span class="n">vec</span><span class="p">[</span><span class="n">not_in_discr</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_1_isect</span>
            <span class="k">return</span> <span class="n">vec</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="polygons_3d">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.geometry.intersections.html#porepy.geometry.intersections.polygons_3d">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">polygons_3d</span><span class="p">(</span>
    <span class="n">polys</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">target_poly</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
    <span class="n">include_point_contact</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the intersection between polygons embedded in 3d.</span>

<span class="sd">    In addition to intersection points, the function also decides:</span>

<span class="sd">        1) Whether intersection points lie in the interior, on a segment or a vertex.</span>
<span class="sd">           If segment or vertex, the index of the segment or vertex is returned.</span>
<span class="sd">        2) Whether a pair of intersection points lie on the same boundary segment of a</span>
<span class="sd">           polygon, that is, if the polygon has a T or L-type intersection with another</span>
<span class="sd">           polygon.</span>

<span class="sd">    Assumptions:</span>

<span class="sd">        - All polygons are convex. Non-convex polygons will simply be treated in a wrong</span>
<span class="sd">          way. To circumvent this, split the non-convex polygon into convex parts.</span>
<span class="sd">        - No polygon contains three points on a line, that is, an angle of pi. This can</span>
<span class="sd">          be included, possibly by temporarily stripping the hanging node from the</span>
<span class="sd">          polygon definition.</span>
<span class="sd">        - If two polygons meet in a vertex, this is not considered an intersection.</span>
<span class="sd">        - If two polygons lie in the same plane, intersection types (vertex, segment,</span>
<span class="sd">          interior) are not classified. This will be clear from the returned values.</span>
<span class="sd">          Inclusion of this should be possible, but it has not been a priority.</span>
<span class="sd">        - Contact between polygons in a single point may not be accurately calculated.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        polys: ``shape=(3, np)``</span>

<span class="sd">            Each list item represents a polygon, specified by its</span>
<span class="sd">            vertices as a numpy array. There should be at least three vertices in the</span>
<span class="sd">            polygon.</span>
<span class="sd">        target_poly: ``default=None``</span>

<span class="sd">            Index in poly of the polygons that should be targeted for</span>
<span class="sd">            intersection findings. These will be compared with the whole set in poly.</span>

<span class="sd">            If not provided, all polygons are compared with each other.</span>
<span class="sd">        tol: ``default=1e-8``</span>

<span class="sd">            Geometric tolerance for the computations.</span>
<span class="sd">        include_point_contact: ``default=True``</span>

<span class="sd">            If True, point contacts will be considered an</span>
<span class="sd">            intersection. This is an experimental feature, use with care.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Returns a tuple consisting of:</span>

<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(3, np)``</span>

<span class="sd">            Intersection coordinates.</span>
<span class="sd">        :obj:`~numpy.ndarray`:</span>
<span class="sd">            For each of the polygons, give the index of the intersection points,</span>
<span class="sd">            referring to the columns of the intersection coordinates.</span>
<span class="sd">        :obj:`~numpy.ndarray`:</span>
<span class="sd">            For each polygon, a list telling whether each of the intersections is on the</span>
<span class="sd">            boundary of the polygon or not. For polygon ``i``, the first element in this</span>
<span class="sd">            list tells whether the point formed by point-indices ``0`` and ``1`` in the</span>
<span class="sd">            previous return argument is on the boundary.</span>
<span class="sd">        :obj:`list`:</span>
<span class="sd">            Each list element is a 2-tuple with the indices of intersecting polygons.</span>
<span class="sd">        :obj:`~numpy.ndarray`:</span>
<span class="sd">            For each polygon, for all intersection points (same order as the second</span>
<span class="sd">            return value), a 2-tuple, where the first value gives an index, the second</span>
<span class="sd">            is a Boolean, ``True`` if the intersection is on a segment, ``False`` if</span>
<span class="sd">            vertex. The index identifies the vertex, or the first vertex of the segment.</span>
<span class="sd">            If the intersection is in the interior of a polygon, the tuple is replaced</span>
<span class="sd">            by an empty list.</span>
<span class="sd">        :obj:`~numpy.ndarray`:</span>
<span class="sd">            For each polygon, for all intersection points, ``True`` if this intersection</span>
<span class="sd">            is formed by a single point.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">target_poly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">target_poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_poly</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">target_poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">target_poly</span><span class="p">)</span>

    <span class="c1"># Obtain bounding boxes for the polygons</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span> <span class="o">=</span> <span class="n">_axis_aligned_bounding_box_3d</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>

    <span class="c1"># If a polygon is perfectly aligned with a coordinate axis, and another polygon</span>
    <span class="c1"># terminates in the first one, rounding errors in the coordinates may lead to the</span>
    <span class="c1"># intersection not being picked up. To circumvent the issue, detect such situations</span>
    <span class="c1"># and give ourselves a bit wiggle room.</span>
    <span class="c1"># It seems that this will not give problems in other cases.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">cmin</span><span class="p">,</span> <span class="n">cmax</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">),</span> <span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">),</span> <span class="p">(</span><span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span><span class="p">)]:</span>
        <span class="n">hit</span> <span class="o">=</span> <span class="n">cmax</span> <span class="o">-</span> <span class="n">cmin</span> <span class="o">&lt;</span> <span class="n">tol</span>
        <span class="n">cmin</span><span class="p">[</span><span class="n">hit</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">tol</span>
        <span class="n">cmax</span><span class="p">[</span><span class="n">hit</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">tol</span>

    <span class="c1"># Identify overlapping bounding boxes: First, use a fast method to find overlapping</span>
    <span class="c1"># rectangles in the xy-plane.</span>
    <span class="n">pairs_xy</span> <span class="o">=</span> <span class="n">_identify_overlapping_rectangles</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span>
    <span class="c1"># Next, find overlapping intervals in the z-directien</span>
    <span class="n">pairs_z</span> <span class="o">=</span> <span class="n">_identify_overlapping_intervals</span><span class="p">(</span><span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span><span class="p">)</span>

    <span class="c1"># Finally, do the intersection</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="n">_intersect_pairs</span><span class="p">(</span><span class="n">pairs_xy</span><span class="p">,</span> <span class="n">pairs_z</span><span class="p">)</span>

    <span class="c1"># Various utility functions</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">center</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="c1"># Compute the mean coordinate of a set of points</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
        <span class="c1"># Normalize a vector</span>
        <span class="n">nrm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">v</span> <span class="o">/</span> <span class="n">nrm</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mod_sign</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="c1"># Modified signum function: The value is 0 if it is very close to zero.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">sgn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">sgn</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">sgn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">intersection</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">center</span><span class="p">):</span>
        <span class="c1"># Find a point p on the segment between start and end, so that the vector p -</span>
        <span class="c1"># center is perpendicular to normal</span>

        <span class="c1"># Vector along the segment</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
        <span class="n">dot_prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">normal</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dot_prod</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-6</span>
        <span class="n">t</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">start</span> <span class="o">-</span> <span class="n">center</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span> <span class="o">*</span> <span class="n">normal</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span> <span class="o">/</span> <span class="n">dot_prod</span>

        <span class="k">assert</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">start</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dx</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">vector_pointset_point</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="c1"># Create a set of non-zero vectors from a point in the plane spanned by a, to</span>
        <span class="c1"># all points in b.</span>
        <span class="c1"># Loop over all points in a, search for a point that is sufficiently far away</span>
        <span class="c1"># from b. Mainly this involves finding a point in a which is not in b</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">dist</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tol</span>
        <span class="k">return</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">num_polys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>

    <span class="c1"># Storage array for storing the index of the intersection points for each polygon</span>
    <span class="n">isect_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">num_polys</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="c1"># Storage for whether an intersection is on the boundary of a polygon</span>
    <span class="n">is_bound_isect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">isect_pt</span><span class="p">)</span>
    <span class="c1"># Storage for which segment or vertex of a polygon is intersected</span>
    <span class="n">segment_vertex_intersection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">isect_pt</span><span class="p">)</span>
    <span class="n">is_point_contact</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">num_polys</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

    <span class="c1"># Initialization</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">isect_pt</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="n">isect_pt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">is_point_contact</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Array for storing the newly found points</span>
    <span class="n">new_pt</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_pt_ind</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Index of the main fractures, to which the other ones will be compared. Filter out</span>
    <span class="c1"># all that are not among the targets.</span>
    <span class="n">start_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">target_poly</span><span class="p">,</span> <span class="n">pairs</span><span class="p">)</span>

    <span class="c1"># Store index of pairs of intersecting polygons</span>
    <span class="n">polygon_pairs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Pre-compute polygon normals to save computational time</span>
    <span class="n">polygon_normals</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">map_geometry</span><span class="o">.</span><span class="n">compute_normal</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polys</span>
    <span class="p">]</span>

    <span class="c1"># Loop over all fracture pairs (taking more than one simultaneously if an index</span>
    <span class="c1"># occurs several times in pairs[0]), and look for intersections</span>
    <span class="k">for</span> <span class="n">di</span><span class="p">,</span> <span class="n">line_ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">start_inds</span><span class="p">):</span>
        <span class="c1"># The algorithm first does a coarse filtering, to check if the candidate pairs</span>
        <span class="c1"># both crosses each others plane. For those pairs that passes this test, we next</span>
        <span class="c1"># compute the intersection points, and check if they are contained within the</span>
        <span class="c1"># fractures.</span>

        <span class="c1"># The main fracture, from the first row in pairs</span>
        <span class="n">main</span> <span class="o">=</span> <span class="n">line_ind</span>

        <span class="c1"># Find the other fracture of all pairs starting with the main one</span>
        <span class="n">hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">main</span><span class="p">)</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">hit</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Center point and normal vector of the main fracture</span>
        <span class="n">main_center</span> <span class="o">=</span> <span class="n">center</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">main</span><span class="p">])</span>
        <span class="n">main_normal</span> <span class="o">=</span> <span class="n">polygon_normals</span><span class="p">[</span><span class="n">main</span><span class="p">]</span>

        <span class="c1"># Create an expanded version of the main points, so that the start and end</span>
        <span class="c1"># points are the same. Thus the segments can be formed by merging</span>
        <span class="c1"># main_p_expanded[:-1] with main_p_expanded[1:]</span>
        <span class="n">num_main</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ind_main_cyclic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_main</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">num_main</span>
        <span class="n">main_p_expanded</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[</span><span class="n">main</span><span class="p">][:,</span> <span class="n">ind_main_cyclic</span><span class="p">]</span>

        <span class="c1"># Declare types for the seg_vert information. The data structure is somewhat</span>
        <span class="c1"># awkward, but it is what it is.</span>
        <span class="n">seg_vert_main_0</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span>
        <span class="n">seg_vert_main_1</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span>
        <span class="n">seg_vert_other_0</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span>
        <span class="n">seg_vert_other_1</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span>

        <span class="c1"># Loop over the other polygon in the pairs, look for intersections</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
            <span class="c1"># Expanded version of the other polygon</span>
            <span class="n">num_other</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ind_other_cyclic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_other</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">num_other</span>
            <span class="n">other_p_expanded</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[</span><span class="n">o</span><span class="p">][:,</span> <span class="n">ind_other_cyclic</span><span class="p">]</span>

            <span class="c1"># Normal vector and cetner of the other polygon</span>
            <span class="n">other_normal</span> <span class="o">=</span> <span class="n">polygon_normals</span><span class="p">[</span><span class="n">o</span><span class="p">]</span>
            <span class="n">other_center</span> <span class="o">=</span> <span class="n">center</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">o</span><span class="p">])</span>

            <span class="c1"># Point a vector from the main center to the vertices of the other polygon.</span>
            <span class="c1"># Then take the dot product with the normal vector of the main fracture. If</span>
            <span class="c1"># all dot products have the same sign, the other fracture does not cross the</span>
            <span class="c1"># plane of the main polygon. Note that we use mod_sign to safeguard the</span>
            <span class="c1"># computation - if the vertices are close, we will take a closer look at the</span>
            <span class="c1"># combination.</span>
            <span class="n">vec_from_main</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span>
                <span class="n">vector_pointset_point</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">main</span><span class="p">],</span> <span class="n">other_p_expanded</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">dot_prod_from_main</span> <span class="o">=</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">main_normal</span> <span class="o">*</span> <span class="n">vec_from_main</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

            <span class="c1"># Similar procedure: Vector from ohter center to the main polygon,</span>
            <span class="c1"># then dot product.</span>
            <span class="n">vec_from_other</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">vector_pointset_point</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">o</span><span class="p">],</span> <span class="n">main_p_expanded</span><span class="p">))</span>
            <span class="n">dot_prod_from_other</span> <span class="o">=</span> <span class="n">mod_sign</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">other_normal</span> <span class="o">*</span> <span class="n">vec_from_other</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># If one of the polygons lie completely on one side of the other, there can</span>
            <span class="c1"># be no intersection.</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dot_prod_from_main</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dot_prod_from_main</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dot_prod_from_other</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dot_prod_from_other</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># At this stage, we are fairly sure both polygons cross the plane of the</span>
            <span class="c1"># other polygon.</span>
            <span class="c1"># Identify the segments where the polygon crosses the plane</span>
            <span class="n">sign_change_main</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dot_prod_from_main</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sign_change_other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dot_prod_from_other</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># The default option is that the intersection is not on the boundary of main</span>
            <span class="c1"># or other, that is, the two intersection points are identical to two</span>
            <span class="c1"># vertices of the polygon.</span>
            <span class="n">isect_on_boundary_main</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">isect_on_boundary_other</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># We know that the polygons at least are very close to intersecting each-</span>
            <span class="c1"># others planes. There are four options, differing in whether the vertices</span>
            <span class="c1"># are in the plane of the other polygon or not:</span>
            <span class="c1">#   1) The polygon has no vertex in the other plane. Intersection is found</span>
            <span class="c1">#      by computing intersection between polygon segments and the other</span>
            <span class="c1">#      plane.</span>
            <span class="c1">#   2) The polygon has one vertex in the other plane. This is one</span>
            <span class="c1">#      intersection point. The other one should be on a segment, that is,</span>
            <span class="c1">#      the polygon should have points on both sides of the plane.</span>
            <span class="c1">#   3) The polygon has two vertices in the other plane. These will be the</span>
            <span class="c1">#      intersection points. The remaining vertices should be on the same</span>
            <span class="c1">#      side of the plane.</span>
            <span class="c1">#   4) All vertices lie in the plane. The intersection points will be found</span>
            <span class="c1">#      by what is essentially a 2d algorithm. Note that the current</span>
            <span class="c1">#      implementation if this case is a bit rudimentary.</span>
            <span class="c1">#</span>
            <span class="c1"># NOTE: This part of the code only considers intersection between polygon</span>
            <span class="c1"># and plane. The analysis whether the intersection points are within</span>
            <span class="c1"># each polygon is done below.</span>
            <span class="c1">#</span>
            <span class="c1"># We first compute the intersection of the other polygon with the plane of</span>
            <span class="c1"># the main one. The reverse operation is found below.</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dot_prod_from_main</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c1"># In the case where one polygon does not have a vertex in the plane of</span>
                <span class="c1"># the other polygon, there should be exactly two segments crossing the</span>
                <span class="c1"># plane.</span>
                <span class="k">assert</span> <span class="n">sign_change_main</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="c1"># Compute the intersection points between the segments of the other</span>
                <span class="c1"># polygon and the plane of the main polygon.</span>
                <span class="n">other_intersects_main_0</span> <span class="o">=</span> <span class="n">intersection</span><span class="p">(</span>
                    <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_main</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_main</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">main_normal</span><span class="p">,</span>
                    <span class="n">main_center</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">other_intersects_main_1</span> <span class="o">=</span> <span class="n">intersection</span><span class="p">(</span>
                    <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_main</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                    <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_main</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">main_normal</span><span class="p">,</span>
                    <span class="n">main_center</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># First indices, next is whether this refers to segment. False means</span>
                <span class="c1"># vertex.</span>
                <span class="n">seg_vert_other_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">sign_change_main</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">seg_vert_other_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">sign_change_main</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dot_prod_from_main</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># The first and last element represent the same point, thus include only</span>
                <span class="c1"># one of them when counting the number of points in the plane of the</span>
                <span class="c1"># other fracture.</span>
                <span class="n">hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dot_prod_from_main</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">other_intersects_main_0</span> <span class="o">=</span> <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">sign_change_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dot_prod_from_main</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">sign_change_full</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># This corresponds to a point contact between one polygon and the</span>
                    <span class="c1"># other (at least other plane, perhaps also other polygon)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">include_point_contact</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Point of the intersection - known to be on o.</span>
                    <span class="n">tmp_p</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[</span><span class="n">o</span><span class="p">][:,</span> <span class="n">hit</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

                    <span class="c1"># Check whether the point is inside, or on the boundary, of outside.</span>
                    <span class="c1"># in_or_on is 0 for outside, 1 for on boundary, 2 for internal. If</span>
                    <span class="c1"># the contact is on an index of other, vert_ind_on_other gives the</span>
                    <span class="c1"># index of this vertex, if not, it is False.</span>
                    <span class="n">in_or_on</span><span class="p">,</span> <span class="n">vert_ind_on_main</span> <span class="o">=</span> <span class="n">_point_in_or_on_polygon</span><span class="p">(</span>
                        <span class="n">tmp_p</span><span class="p">,</span> <span class="n">polys</span><span class="p">[</span><span class="n">main</span><span class="p">],</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="n">in_or_on</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># The intersection is between the polygons proper.</span>
                        <span class="c1"># Store point, assign it to both polygons.</span>
                        <span class="n">new_pt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp_p</span><span class="p">)</span>
                        <span class="n">isect_pt</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                        <span class="n">isect_pt</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                        <span class="n">polygon_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">main</span><span class="p">,</span> <span class="n">o</span><span class="p">))</span>
                        <span class="n">new_pt_ind</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="c1"># This is certainly a point on the boundary on main.</span>
                        <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

                        <span class="c1"># Store index of the point contact vertex for main.</span>
                        <span class="n">is_point_contact</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                        <span class="c1"># Store vertex information for other.</span>
                        <span class="n">is_point_contact</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">])</span>

                        <span class="c1"># Store boundary information on other.</span>
                        <span class="k">if</span> <span class="n">in_or_on</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vert_ind_on_main</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">vert_ind_on_main</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                            <span class="c1"># EK: mypy complains about a tuple index out of range below</span>
                            <span class="c1"># despite the check that the length is 2. Ignore it.</span>
                            <span class="k">if</span> <span class="n">vert_ind_on_main</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
                                <span class="c1"># This is a segment, but not a vertex intersection</span>
                                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">[</span><span class="n">vert_ind_on_main</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">]</span>
                                <span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># Intersection is on vertex of other as well</span>
                                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">[</span><span class="n">vert_ind_on_main</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">False</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                                <span class="p">)</span>
                            <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                            <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

                    <span class="c1"># if in_or_or is 0, the intersection is external, and we do nothing.</span>
                    <span class="c1"># There is no need to do further processing of the combination of</span>
                    <span class="c1"># main and o.</span>
                    <span class="k">continue</span>

                <span class="n">other_intersects_main_1</span> <span class="o">=</span> <span class="n">intersection</span><span class="p">(</span>
                    <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_full</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_full</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">main_normal</span><span class="p">,</span>
                    <span class="n">main_center</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">seg_vert_other_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">seg_vert_other_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">sign_change_full</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dot_prod_from_main</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c1"># The two polygons lie in the same plane. The intersection points will</span>
                <span class="c1"># be found on the segments of the polygons</span>
                <span class="n">isect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="c1"># Loop over both set of polygon segments, look for intersections</span>
                <span class="k">for</span> <span class="n">sm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="c1"># Store the intersection points found for this segment of the main</span>
                    <span class="c1"># polygon. If there are more than one, we know that the intersection</span>
                    <span class="c1"># is on the boundary of that polygon.</span>
                    <span class="n">tmp_isect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">so</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">loc_isect</span> <span class="o">=</span> <span class="n">segments_3d</span><span class="p">(</span>
                            <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sm</span><span class="p">],</span>
                            <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sm</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                            <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">so</span><span class="p">],</span>
                            <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">so</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">loc_isect</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">isect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">isect</span><span class="p">,</span> <span class="n">loc_isect</span><span class="p">))</span>
                            <span class="n">tmp_isect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">tmp_isect</span><span class="p">,</span> <span class="n">loc_isect</span><span class="p">))</span>

                    <span class="c1"># Uniquify the intersection points found on this segment of main.</span>
                    <span class="c1"># If more than one, the intersection is on the boundary of main.</span>
                    <span class="n">tmp_unique_isect</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">setmembership</span><span class="o">.</span><span class="n">uniquify_point_set</span><span class="p">(</span>
                        <span class="n">tmp_isect</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">tmp_unique_isect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">isect_on_boundary_main</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="n">isect</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">setmembership</span><span class="o">.</span><span class="n">uniquify_point_set</span><span class="p">(</span><span class="n">isect</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">isect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># The polygons share a plane, but no intersections</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">isect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">include_point_contact</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Register point</span>
                    <span class="n">new_pt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>
                    <span class="n">isect_pt</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">isect_pt</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">polygon_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">main</span><span class="p">,</span> <span class="n">o</span><span class="p">))</span>
                    <span class="n">new_pt_ind</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="c1"># This is certainly a point on the boundary on both</span>
                    <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="c1"># Store point index information</span>
                    <span class="n">is_point_contact</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">is_point_contact</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

                    <span class="c1"># For each of the polygons, check proximity of intersection first</span>
                    <span class="c1"># with vertices, next segments.</span>
                    <span class="k">for</span> <span class="n">tmp_ind</span> <span class="ow">in</span> <span class="p">[</span><span class="n">main</span><span class="p">,</span> <span class="n">o</span><span class="p">]:</span>
                        <span class="n">dist_vert</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">point_pointset</span><span class="p">(</span><span class="n">isect</span><span class="p">,</span> <span class="n">polys</span><span class="p">[</span><span class="n">tmp_ind</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">dist_vert</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                            <span class="c1"># This is a point</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">tmp_ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_vert</span><span class="p">),</span> <span class="kc">False</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Point failed, look for closest segment.</span>
                            <span class="n">start</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[</span><span class="n">tmp_ind</span><span class="p">]</span>
                            <span class="n">end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                            <span class="n">dist_seg</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">points_segments</span><span class="p">(</span>
                                <span class="n">isect</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span>
                            <span class="p">)</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">tmp_ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_seg</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="kc">True</span><span class="p">]</span>
                            <span class="p">)</span>
                    <span class="c1"># Intersection information is complete, move on.</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">isect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">other_intersects_main_0</span> <span class="o">=</span> <span class="n">isect</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">other_intersects_main_1</span> <span class="o">=</span> <span class="n">isect</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There should be at most two intersections&quot;</span><span class="p">)</span>

                <span class="n">seg_vert_other_0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;not implemented for shared planes&quot;</span><span class="p">)</span>
                <span class="n">seg_vert_other_1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;not implemented for shared planes&quot;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Both of the intersection points are vertices.</span>
                <span class="c1"># Check that there are only two points - if this assertion fails, there</span>
                <span class="c1"># is a hanging node of the other polygon, which is in the plane of the</span>
                <span class="c1"># other polygon. Extending to cover this case should be possible, but</span>
                <span class="c1"># further treatment is unclear at the moment.</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dot_prod_from_main</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="n">hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dot_prod_from_main</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">other_intersects_main_0</span> <span class="o">=</span> <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="c1"># Pick the last of the intersection points. This is valid also for</span>
                <span class="c1"># multiple (&gt;2) intersection points, but we keep the assertion for now.</span>
                <span class="n">other_intersects_main_1</span> <span class="o">=</span> <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">hit</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

                <span class="n">seg_vert_other_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">seg_vert_other_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">hit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>

                <span class="c1"># The other polygon has an edge laying in the plane of the main polygon.</span>
                <span class="c1"># This will be registered as a boundary intersection, but only if the</span>
                <span class="c1"># polygons (not only plane) intersect.</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">hit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="ow">or</span> <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="ow">and</span> <span class="n">hit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">dot_prod_from_main</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">isect_on_boundary_other</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Next, analyze intersection between main polygon and the plane of the other</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dot_prod_from_other</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c1"># In the case where one polygon does not have a vertex in the plane of</span>
                <span class="c1"># the other polygon, there should be exactly two segments crossing the</span>
                <span class="c1"># plane.</span>
                <span class="k">assert</span> <span class="n">sign_change_other</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="c1"># Compute the intersection points between the segments of the main</span>
                <span class="c1"># polygon and the plane of the other polygon.</span>
                <span class="n">main_intersects_other_0</span> <span class="o">=</span> <span class="n">intersection</span><span class="p">(</span>
                    <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_other</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">other_normal</span><span class="p">,</span>
                    <span class="n">other_center</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">main_intersects_other_1</span> <span class="o">=</span> <span class="n">intersection</span><span class="p">(</span>
                    <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_other</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                    <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_other</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">other_normal</span><span class="p">,</span>
                    <span class="n">other_center</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">seg_vert_main_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">sign_change_other</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">seg_vert_main_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">sign_change_other</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dot_prod_from_other</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># The first and last element represent the same point, thus include only</span>
                <span class="c1"># one of them when counting the number of points in the plane of the</span>
                <span class="c1"># other fracture.</span>
                <span class="n">hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dot_prod_from_other</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">main_intersects_other_0</span> <span class="o">=</span> <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">sign_change_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dot_prod_from_other</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">sign_change_full</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># This corresponds to a point contact between one polygon and the</span>
                    <span class="c1"># other (at least other plane, perhaps also other polygon)</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">include_point_contact</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Point of the intersection - known to be on main.</span>
                    <span class="n">tmp_p</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[</span><span class="n">main</span><span class="p">][:,</span> <span class="n">hit</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

                    <span class="c1"># Check whether the point is inside, or on the boundary, of outside.</span>
                    <span class="c1"># in_or_on is 0 for outside, 1 for on boundary, 2 for internal. If</span>
                    <span class="c1"># the contact is on an index of other, vert_ind_on_other gives the</span>
                    <span class="c1"># index of this vertex, if not, it is False.</span>
                    <span class="n">in_or_on</span><span class="p">,</span> <span class="n">vert_ind_on_other</span> <span class="o">=</span> <span class="n">_point_in_or_on_polygon</span><span class="p">(</span>
                        <span class="n">tmp_p</span><span class="p">,</span> <span class="n">polys</span><span class="p">[</span><span class="n">o</span><span class="p">],</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="n">in_or_on</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># The intersection is between the polygons proper.</span>
                        <span class="c1"># Store point, assign it to both polygons.</span>
                        <span class="n">new_pt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp_p</span><span class="p">)</span>
                        <span class="n">isect_pt</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                        <span class="n">isect_pt</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                        <span class="n">polygon_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">main</span><span class="p">,</span> <span class="n">o</span><span class="p">))</span>
                        <span class="n">new_pt_ind</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="c1"># This is certainly a point on the boundary on main.</span>
                        <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

                        <span class="c1"># Store index of the point contact vertex for main.</span>
                        <span class="n">is_point_contact</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                        <span class="c1"># Store vertex information for other.</span>
                        <span class="n">is_point_contact</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">])</span>

                        <span class="c1"># Store boundary information on other.</span>
                        <span class="k">if</span> <span class="n">in_or_on</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vert_ind_on_other</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>  <span class="c1"># for mypy</span>
                            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">vert_ind_on_other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>  <span class="c1"># for mypy</span>
                            <span class="c1"># EK: mypy complains about a tuple index out of range below</span>
                            <span class="c1"># despite the check that the length is 2. Ignore it.</span>
                            <span class="k">if</span> <span class="n">vert_ind_on_other</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
                                <span class="c1"># This is a segment, but not a vertex intersection</span>
                                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">[</span><span class="n">vert_ind_on_other</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">]</span>
                                <span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># Intersection is on vertex of other as well</span>
                                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">[</span><span class="n">vert_ind_on_other</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">False</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                                <span class="p">)</span>
                            <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                            <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

                    <span class="c1"># if in_or_or is 0, the intersection is external, and we do nothing.</span>
                    <span class="c1"># There is no need to do further processing of the combination of</span>
                    <span class="c1"># main and o.</span>
                    <span class="k">continue</span>

                <span class="n">main_intersects_other_1</span> <span class="o">=</span> <span class="n">intersection</span><span class="p">(</span>
                    <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_full</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_full</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">other_normal</span><span class="p">,</span>
                    <span class="n">other_center</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">seg_vert_main_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">seg_vert_main_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">sign_change_full</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dot_prod_from_other</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>

                <span class="n">isect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">so</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">tmp_isect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">sm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">loc_isect</span> <span class="o">=</span> <span class="n">segments_3d</span><span class="p">(</span>
                            <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sm</span><span class="p">],</span>
                            <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sm</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                            <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">so</span><span class="p">],</span>
                            <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">so</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">loc_isect</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">isect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">isect</span><span class="p">,</span> <span class="n">loc_isect</span><span class="p">))</span>
                            <span class="n">tmp_isect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">tmp_isect</span><span class="p">,</span> <span class="n">loc_isect</span><span class="p">))</span>

                    <span class="n">tmp_unique_isect</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">setmembership</span><span class="o">.</span><span class="n">uniquify_point_set</span><span class="p">(</span>
                        <span class="n">tmp_isect</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="n">tmp_unique_isect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">isect_on_boundary_other</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="n">isect</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">setmembership</span><span class="o">.</span><span class="n">uniquify_point_set</span><span class="p">(</span><span class="n">isect</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>

                <span class="n">seg_vert_main_0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;not implemented for shared planes&quot;</span><span class="p">)</span>
                <span class="n">seg_vert_main_1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;not implemented for shared planes&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">isect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># The polygons share a plane, but no intersections</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">isect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Point contact. Must be on the boundary of both, but not clear</span>
                    <span class="c1"># whether it is on vertex of both (must be at least on one).</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">include_point_contact</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Register point</span>
                    <span class="n">new_pt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>
                    <span class="n">isect_pt</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">isect_pt</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">polygon_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">main</span><span class="p">,</span> <span class="n">o</span><span class="p">))</span>
                    <span class="n">new_pt_ind</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="c1"># This is certainly a point on the boundary on both</span>
                    <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="c1"># Store point index information</span>
                    <span class="n">is_point_contact</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">is_point_contact</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

                    <span class="c1"># For each of the polygons, check proximity of intersection first</span>
                    <span class="c1"># with vertices, next segments.</span>
                    <span class="k">for</span> <span class="n">tmp_ind</span> <span class="ow">in</span> <span class="p">[</span><span class="n">main</span><span class="p">,</span> <span class="n">o</span><span class="p">]:</span>
                        <span class="n">dist_vert</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">point_pointset</span><span class="p">(</span><span class="n">isect</span><span class="p">,</span> <span class="n">polys</span><span class="p">[</span><span class="n">tmp_ind</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">dist_vert</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                            <span class="c1"># This is a point</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">tmp_ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_vert</span><span class="p">),</span> <span class="kc">True</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Point failed, look for closest segment.</span>
                            <span class="n">start</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[</span><span class="n">tmp_ind</span><span class="p">]</span>
                            <span class="n">end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                            <span class="n">dist_seg</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">points_segments</span><span class="p">(</span>
                                <span class="n">isect</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span>
                            <span class="p">)</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">tmp_ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_seg</span><span class="p">),</span> <span class="kc">False</span><span class="p">]</span>
                            <span class="p">)</span>

                    <span class="c1"># Intersection information is complete, move on.</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">isect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">main_intersects_other_0</span> <span class="o">=</span> <span class="n">isect</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">main_intersects_other_1</span> <span class="o">=</span> <span class="n">isect</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There should be at most two intersections&quot;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Both of the intersection points are vertices.</span>
                <span class="c1"># Check that there are only two points - if this assertion fails, there</span>
                <span class="c1"># is a hanging node of the main polygon, which is in the plane of the</span>
                <span class="c1"># other polygon. Extending to cover this case should be possible, but</span>
                <span class="c1"># further treatment is unclear at the moment.</span>
                <span class="c1"># Do not count the last point here, this is identical to the first one.</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dot_prod_from_other</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="n">hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dot_prod_from_other</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">main_intersects_other_0</span> <span class="o">=</span> <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="c1"># Pick the last of the intersection points. This is valid also for</span>
                <span class="c1"># multiple (&gt;2) intersection points, but we keep the assertion for now.</span>
                <span class="n">main_intersects_other_1</span> <span class="o">=</span> <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">hit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

                <span class="n">seg_vert_main_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">seg_vert_main_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">hit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>

                <span class="c1"># The main polygon has an edge laying in the plane of the other polygon.</span>
                <span class="c1"># If the two intersection points form a segment, this will be registered</span>
                <span class="c1"># as a boundary intersection, but only if the polygons (not only plane)</span>
                <span class="c1"># intersect. The two points can either be one apart in the main polygon,</span>
                <span class="c1"># or it can be the first and the penultimate point (in the latter case,</span>
                <span class="c1"># the final point, which is identical to the first one, will also be in</span>
                <span class="c1"># the plane, but this is disregarded by the [:-1] above)</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">hit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="ow">or</span> <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="ow">and</span> <span class="n">hit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">dot_prod_from_other</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">isect_on_boundary_main</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1">###</span>
            <span class="c1"># We now have the intersections between polygons and planes.</span>
            <span class="c1"># To finalize the computation, we need to sort out how the intersection</span>
            <span class="c1"># points are located relative to each other. Only if there is an overlap</span>
            <span class="c1"># between the intersection points of the main and the other polygon is there</span>
            <span class="c1"># a real intersection (contained within the polygons, not only) in their</span>
            <span class="c1"># planes, but outside the features themselves.</span>

            <span class="c1"># Vectors from the intersection points in the main fracture to the</span>
            <span class="c1"># intersection point in the other fracture</span>
            <span class="n">main_0_other_0</span> <span class="o">=</span> <span class="n">other_intersects_main_0</span> <span class="o">-</span> <span class="n">main_intersects_other_0</span>
            <span class="n">main_0_other_1</span> <span class="o">=</span> <span class="n">other_intersects_main_1</span> <span class="o">-</span> <span class="n">main_intersects_other_0</span>
            <span class="n">main_1_other_0</span> <span class="o">=</span> <span class="n">other_intersects_main_0</span> <span class="o">-</span> <span class="n">main_intersects_other_1</span>
            <span class="n">main_1_other_1</span> <span class="o">=</span> <span class="n">other_intersects_main_1</span> <span class="o">-</span> <span class="n">main_intersects_other_1</span>

            <span class="c1"># e_1 is positive if both points of the other fracture lie on the same side</span>
            <span class="c1"># of the first intersection point of the main one.</span>
            <span class="c1"># e_1 negative means the first intersection point of main with the plane of</span>
            <span class="c1"># the others is surrounded by the intersection points of the other polygon</span>
            <span class="c1"># with the main plane.</span>
            <span class="c1"># Use a mod_sign here to avoid issues related to rounding errors</span>
            <span class="n">e_1</span> <span class="o">=</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">main_0_other_0</span> <span class="o">*</span> <span class="n">main_0_other_1</span><span class="p">))</span>
            <span class="c1"># e_2 is positive if both points of the other fracture lie on the same side</span>
            <span class="c1"># of the second intersection point of the main one</span>
            <span class="n">e_2</span> <span class="o">=</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">main_1_other_0</span> <span class="o">*</span> <span class="n">main_1_other_1</span><span class="p">))</span>
            <span class="c1"># e_3 is positive if both points of the main fracture lie on the same side</span>
            <span class="c1"># of the first intersection point of the other one</span>
            <span class="n">e_3</span> <span class="o">=</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="o">-</span><span class="n">main_0_other_0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">main_1_other_0</span><span class="p">)))</span>
            <span class="c1"># e_4 is positive if both points of the main fracture lie on the same side</span>
            <span class="c1"># of the second intersection point of the other one</span>
            <span class="n">e_4</span> <span class="o">=</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="o">-</span><span class="n">main_0_other_1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">main_1_other_1</span><span class="p">)))</span>

            <span class="c1"># This is in essence an implementation of the flow chart in Figure 9 in Dong</span>
            <span class="c1"># et al, however the inequality signs are changed a bit to make the logic</span>
            <span class="c1"># clearer.</span>
            <span class="k">if</span> <span class="n">e_1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">e_2</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">e_3</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">e_4</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># The intersection points for the two fractures are separated.</span>
                <span class="c1"># There is no intersection</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">sum</span><span class="p">([</span><span class="n">e_1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e_2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="nb">sum</span><span class="p">([</span><span class="n">e_1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e_2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="nb">sum</span><span class="p">([</span><span class="n">e_3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e_4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="nb">sum</span><span class="p">([</span><span class="n">e_3</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e_4</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="p">):</span>
                <span class="c1"># Contact in a single point</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">e_1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># The first point on the main fracture is at most marginally involved in</span>
                <span class="c1"># the intersection (if e_1 == 0, two segments intersect)</span>
                <span class="k">if</span> <span class="n">e_2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># The second point on the main fracture is at most marginally</span>
                    <span class="c1"># involved.</span>
                    <span class="c1"># We know that e_3 and e_4 are non-positive (positive is covered</span>
                    <span class="c1"># above and a combination is not possible)</span>

                    <span class="c1"># The intersection points are defined by the intersection of other</span>
                    <span class="c1"># with the plane of main</span>
                    <span class="n">isect_pt_loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">other_intersects_main_0</span><span class="p">,</span> <span class="n">other_intersects_main_1</span><span class="p">]</span>

                    <span class="c1"># Next, we need to classify the intersection types (segments or not)</span>
                    <span class="c1"># For the other polygon, we know both intersections are on the</span>
                    <span class="c1"># segments</span>
                    <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_other_0</span><span class="p">)</span>
                    <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_other_1</span><span class="p">)</span>

                    <span class="c1"># For the main segment, the intersection most likely hits in the</span>
                    <span class="c1"># interior, however, there is still the chance that the intersection</span>
                    <span class="c1"># is on the segment (if e_1 == 0 and / or e__2 == 0)</span>

                    <span class="c1"># Check if the first intersection point is on the boundary of main</span>
                    <span class="k">if</span> <span class="n">e_3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># e_3 = main_0_other_0.dot(main_1_other_0) == 0</span>
                        <span class="c1"># We know all of e_i are parallel, thus orthogonality is not</span>
                        <span class="c1"># an option. Thus, at least of the components of e_3 is 0.</span>

                        <span class="c1"># main_0_other_0 is involved in e_1, check if this is zero</span>
                        <span class="k">if</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">main_0_other_0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># other_intersects_main_0 == main_intersects_other_0</span>
                            <span class="c1"># The first intersection point, seen from main, should have</span>
                            <span class="c1"># seg_vert info 0.</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_0</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># other_intersects_main_0 == main_intersects_other_1</span>
                            <span class="c1"># The first intersection point, seen from main, should have</span>
                            <span class="c1"># seg_vert info 1.</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">isect_on_boundary_main</span><span class="p">:</span>
                            <span class="c1"># The first intersection coincides with a segment of main</span>
                            <span class="n">ind</span> <span class="o">=</span> <span class="n">seg_vert_main_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ind</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># The first intersection is in the interior of main</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

                    <span class="c1"># Next, treat the second intersection point</span>
                    <span class="c1"># Check if other_intersects_main_1 equalls either</span>
                    <span class="c1"># main_intersects_other_0 or main_intersects_other_1</span>
                    <span class="k">if</span> <span class="n">e_4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># e_4 = main_0_other_1.dot(main_1_other_1) == 0</span>
                        <span class="k">if</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">main_1_other_1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># other_intersects_main_1 == main_intersects_other_0</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_1</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># other_intersects_main_1 == main_intersects_other_1</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_0</span><span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">isect_on_boundary_main</span><span class="p">:</span>
                            <span class="n">ind</span> <span class="o">=</span> <span class="n">seg_vert_main_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="n">num_main</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">seg_vert_main_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                                <span class="n">ind</span> <span class="o">-=</span> <span class="mi">1</span>

                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ind</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

                <span class="k">else</span><span class="p">:</span>  <span class="c1"># e_2 &lt; 0</span>
                    <span class="c1"># The second point on the main fracture is surrounded by points on</span>
                    <span class="c1"># the other fracture. One of them will in turn be surrounded by the</span>
                    <span class="c1"># points on the main fracture, this is the intersecting one.</span>
                    <span class="k">if</span> <span class="n">e_3</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Intersection consists of second point from main, then first</span>
                        <span class="c1"># from other</span>
                        <span class="n">isect_pt_loc</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">main_intersects_other_1</span><span class="p">,</span>
                            <span class="n">other_intersects_main_0</span><span class="p">,</span>
                        <span class="p">]</span>

                        <span class="c1"># seg-vert information for the first point is simple for main</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_1</span><span class="p">)</span>

                        <span class="c1"># Second point for main is more difficult</span>
                        <span class="k">if</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">main_0_other_0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># e_1 == 0 gives main_intersects_other_0 equals either</span>
                            <span class="c1">#  other_intersects_main_0 or other_intersects_main_1</span>
                            <span class="c1"># e_3 == 0 confirms</span>
                            <span class="c1">#  main_intersects_other_0 == other_intersects_main_0</span>
                            <span class="c1"># (otherwise e_2 would also have been zero)</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_0</span><span class="p">)</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">isect_on_boundary_main</span><span class="p">:</span>
                                <span class="c1"># No intersection for the first point of main</span>
                                <span class="n">ind</span> <span class="o">=</span> <span class="n">seg_vert_main_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ind</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

                        <span class="c1"># seg-vert information for first point, seen from other</span>
                        <span class="c1"># We know that e_2 &lt; 0, thus main_intersects_other_1 cannot</span>
                        <span class="c1"># equal other_intersects_main_0 or other_intersects_main_1</span>
                        <span class="k">if</span> <span class="n">e_4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_other_1</span><span class="p">)</span>
                            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;this should not happen&quot;</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">isect_on_boundary_other</span><span class="p">:</span>
                                <span class="n">ind</span> <span class="o">=</span> <span class="n">seg_vert_other_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                                    <span class="n">ind</span> <span class="o">==</span> <span class="n">num_other</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">seg_vert_other_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                                <span class="p">):</span>
                                    <span class="n">ind</span> <span class="o">-=</span> <span class="mi">1</span>
                                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ind</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

                        <span class="c1"># seg-vert information for the second point is simple for other</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_other_0</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">e_4</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">isect_pt_loc</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">main_intersects_other_1</span><span class="p">,</span>
                            <span class="n">other_intersects_main_1</span><span class="p">,</span>
                        <span class="p">]</span>
                        <span class="c1"># seg-vert information for the first point is simple for main</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_1</span><span class="p">)</span>

                        <span class="c1"># For the second point, we need to check if</span>
                        <span class="c1">#  other_intersects_main_1 == main_intersects_other_0</span>
                        <span class="c1"># this will imply</span>
                        <span class="k">if</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">main_0_other_1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># The first point on the main fracture barely hits the other</span>
                            <span class="c1"># fracture</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_0</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># No intersection for the first point of main</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

                        <span class="c1"># Check if main_intersects_other_1 == other_intersects_main_0</span>
                        <span class="k">if</span> <span class="n">e_3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;this should not happen for e_2 &lt; 0&quot;</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_other_0</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

                        <span class="c1"># seg-vert information for the second point is simple for other</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_other_1</span><span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># We may eventually end up here for overlapping fractures</span>
                        <span class="k">assert</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">e_2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Since e_1 is known to be negative, we know that main_intersects_other</span>
                <span class="c1"># is one intersection point.</span>
                <span class="k">if</span> <span class="n">e_1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Equality is covered above</span>
                    <span class="c1"># The first point on the main fracture is surrounded by points on</span>
                    <span class="c1"># the other fracture. One of them will in turn be surrounded by the</span>
                    <span class="c1"># points on the main fracture, this is the intersecting one.</span>
                    <span class="k">if</span> <span class="n">e_3</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">isect_pt_loc</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">main_intersects_other_0</span><span class="p">,</span>
                            <span class="n">other_intersects_main_0</span><span class="p">,</span>
                        <span class="p">]</span>
                        <span class="c1"># seg-vert information for the first point is simple for main</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">e_3</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># The second intersection point is interior to main</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                        <span class="k">else</span><span class="p">:</span>  <span class="c1"># On the boundary of main</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_1</span><span class="p">)</span>

                        <span class="c1"># For other, the first intersection point is known to be</span>
                        <span class="c1"># interior, or else e_1 would have been 0</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_other_0</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">e_4</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">isect_pt_loc</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">main_intersects_other_0</span><span class="p">,</span>
                            <span class="n">other_intersects_main_1</span><span class="p">,</span>
                        <span class="p">]</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">main_1_other_1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_1</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_other_1</span><span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># We may eventually end up here for overlapping fractures</span>
                        <span class="k">assert</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">e_1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">e_2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># The points in on the main fracture are the intersection points</span>
                <span class="n">isect_pt_loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">main_intersects_other_0</span><span class="p">,</span> <span class="n">main_intersects_other_1</span><span class="p">]</span>
                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_0</span><span class="p">)</span>
                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_1</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">isect_on_boundary_other</span><span class="p">:</span>
                    <span class="n">ind_0</span> <span class="o">=</span> <span class="n">seg_vert_other_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">ind_1</span> <span class="o">=</span> <span class="n">seg_vert_other_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ind_0</span> <span class="o">-</span> <span class="n">ind_1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">ind_0</span><span class="p">,</span> <span class="n">ind_1</span><span class="p">),</span> <span class="kc">True</span><span class="p">))</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">ind_0</span><span class="p">,</span> <span class="n">ind_1</span><span class="p">),</span> <span class="kc">True</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">num_other</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">num_other</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                    <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This should never happen</span>
                <span class="k">assert</span> <span class="kc">False</span>

            <span class="c1"># Append data for this combination of polygons.</span>
            <span class="n">new_pt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">isect_pt_loc</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">num_new</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">isect_pt_loc</span><span class="p">)</span>
            <span class="n">isect_pt</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_new</span><span class="p">))</span>
            <span class="n">isect_pt</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_new</span><span class="p">))</span>
            <span class="n">new_pt_ind</span> <span class="o">+=</span> <span class="n">num_new</span>
            <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isect_on_boundary_main</span><span class="p">)</span>
            <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isect_on_boundary_other</span><span class="p">)</span>
            <span class="n">polygon_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">main</span><span class="p">,</span> <span class="n">o</span><span class="p">))</span>

            <span class="n">is_point_contact</span><span class="p">[</span><span class="n">main</span><span class="p">]</span> <span class="o">+=</span> <span class="n">num_new</span> <span class="o">*</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>
            <span class="n">is_point_contact</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">+=</span> <span class="n">num_new</span> <span class="o">*</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>

    <span class="c1"># Cleanup and return. Puh!</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_pt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_pt</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">isect_pt</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">isect_pt</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">isect_pt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">isect_pt</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">isect_pt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">isect_pt</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">isect_pt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">new_points</span><span class="p">,</span>
        <span class="n">isect_pt</span><span class="p">,</span>
        <span class="n">is_bound_isect</span><span class="p">,</span>
        <span class="n">polygon_pairs</span><span class="p">,</span>
        <span class="n">segment_vertex_intersection</span><span class="p">,</span>
        <span class="n">is_point_contact</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="segments_polygon">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.geometry.intersections.html#porepy.geometry.intersections.segments_polygon">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">segments_polygon</span><span class="p">(</span>
    <span class="n">start</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">poly</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the internal intersection from line segments to a polygon in 3d.</span>
<span class="sd">    Intersections with the boundary of the polygon are not computed.</span>

<span class="sd">    Note:</span>
<span class="sd">        It is required that all points lie in a plane. A sanity check will be</span>
<span class="sd">        performed.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import porepy as pp</span>
<span class="sd">        &gt;&gt;&gt; start = np.array([0.5, 0.5, -0.5])</span>
<span class="sd">        &gt;&gt;&gt; end = np.array([0.5, 0.5, 0.5])</span>
<span class="sd">        &gt;&gt;&gt; poly = np.array([[0, 1, 1, 0], [0, 0, 1, 1], [0, 0, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; is_cross, pt = pp.intersections.segments_polygon(start, end, poly)</span>
<span class="sd">        &gt;&gt;&gt; print(is_cross)</span>
<span class="sd">        &gt;&gt;&gt; print(pt)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        start: ``shape=(nd, num_segments)``</span>

<span class="sd">            One endpoint of segments.</span>
<span class="sd">        end: ``shape=(nd, num_segments)``</span>

<span class="sd">            Other endpoint of segments.</span>
<span class="sd">        poly: ``shape=(nd, num_vertices)``</span>

<span class="sd">            Vertices of polygon.</span>
<span class="sd">        tol: ``default=1e-5``</span>

<span class="sd">            Tolerance for the geometric computations.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple consisting of</span>

<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(num_segments)``</span>

<span class="sd">            boolean array, identifying whether a segment has an intersection with the</span>
<span class="sd">            polygon (useful to filter the second return parameter).</span>
<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(nd, num_segments)``</span>

<span class="sd">            float array containing the intersection points.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Reshape if only one point is given</span>
    <span class="k">if</span> <span class="n">start</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">end</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">num_p</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nd</span><span class="p">,</span> <span class="n">num_p</span><span class="p">))</span>

    <span class="c1"># First translate the points so that the first plane is located at the origin</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">poly</span> <span class="o">=</span> <span class="n">poly</span> <span class="o">-</span> <span class="n">center</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">center</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">center</span>

    <span class="c1"># Obtain the rotation matrix that projects p1 to the xy-plane</span>
    <span class="n">rot_p</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">map_geometry</span><span class="o">.</span><span class="n">project_plane_matrix</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
    <span class="n">irot</span> <span class="o">=</span> <span class="n">rot_p</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">poly_rot</span> <span class="o">=</span> <span class="n">rot_p</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>

    <span class="c1"># Sanity check: The points should lie on a plane</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">poly_rot</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>

    <span class="n">poly_xy</span> <span class="o">=</span> <span class="n">poly_rot</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># Rotate the point set, using the same coordinate system.</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">rot_p</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">rot_p</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>

    <span class="n">dz</span> <span class="o">=</span> <span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">start</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">non_zero_incline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span>

    <span class="c1"># Parametrization along line of intersection point</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">dz</span>

    <span class="c1"># Intersection point for segments with non-zero incline</span>
    <span class="n">t</span><span class="p">[</span><span class="n">non_zero_incline</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">start</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">non_zero_incline</span><span class="p">]</span> <span class="o">/</span> <span class="n">dz</span><span class="p">[</span><span class="n">non_zero_incline</span><span class="p">]</span>

    <span class="c1"># Segments with z=0 along the segment</span>
    <span class="n">zero_along_segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
        <span class="n">non_zero_incline</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">tol</span><span class="p">,</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span>
    <span class="c1"># Check if zero point is inside the polygon</span>
    <span class="n">inside</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">geometry_property_checks</span><span class="o">.</span><span class="n">point_in_polygon</span><span class="p">(</span><span class="n">poly_xy</span><span class="p">,</span> <span class="n">x0</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">crosses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">inside</span><span class="p">,</span> <span class="n">zero_along_segment</span><span class="p">)</span>

    <span class="c1"># Verify that the computed points are in the interior of the associated segments</span>
    <span class="n">dot_product</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,ij-&gt;j&quot;</span><span class="p">,</span> <span class="n">x0</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
    <span class="n">sq_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,ij-&gt;j&quot;</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>

    <span class="n">crosses</span><span class="p">[</span><span class="n">dot_product</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">crosses</span><span class="p">[</span><span class="n">dot_product</span> <span class="o">&gt;</span> <span class="n">sq_length</span> <span class="o">+</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Rotate back the points</span>
    <span class="n">x0</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">crosses</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cp</span><span class="p">[:,</span> <span class="n">crosses</span><span class="p">]</span> <span class="o">=</span> <span class="n">center</span> <span class="o">+</span> <span class="n">irot</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x0</span><span class="p">[:,</span> <span class="n">crosses</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">crosses</span><span class="p">,</span> <span class="n">cp</span></div>



<div class="viewcode-block" id="segments_polyhedron">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.geometry.intersections.html#porepy.geometry.intersections.segments_polyhedron">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">segments_polyhedron</span><span class="p">(</span>
    <span class="n">start</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">poly</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the intersection from line segments to the interior of a convex</span>
<span class="sd">    polyhedron. Intersections with the boundary of the polyhedron are not computed.</span>

<span class="sd">    Note:</span>
<span class="sd">        There are four possibilities for each segment:</span>

<span class="sd">        1. the segment is completely inside the polyhedron, meaning that its vertices</span>
<span class="sd">        are both inside the polyhedron;</span>
<span class="sd">        2. the segment has only one vertex in the polyhedron;</span>
<span class="sd">        3. the segment is completely outside the polyhedron;</span>
<span class="sd">        4. the segment has in intersection but both vertices are outside the</span>
<span class="sd">        polyhedron.</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import porepy as pp</span>
<span class="sd">        &gt;&gt;&gt; s = np.array([0.5, 0.5, 0.25])</span>
<span class="sd">        &gt;&gt;&gt; e = np.array([0.5, 0.5, 0.75])</span>
<span class="sd">        &gt;&gt;&gt; p = np.array(</span>
<span class="sd">        &gt;&gt;&gt;     [</span>
<span class="sd">        &gt;&gt;&gt;         [[0.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 1.0], [0.0, 0.0, 1.0, 1.0]],</span>
<span class="sd">        &gt;&gt;&gt;         [[1.0, 1.0, 1.0, 1.0], [0.0, 1.0, 0.0, 1.0], [0.0, 0.0, 1.0, 1.0]],</span>
<span class="sd">        &gt;&gt;&gt;         [[0.0, 1.0, 0.0, 1.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 1.0, 1.0]],</span>
<span class="sd">        &gt;&gt;&gt;         [[0.0, 1.0, 0.0, 1.0], [1.0, 1.0, 1.0, 1.0], [0.0, 0.0, 1.0, 1.0]],</span>
<span class="sd">        &gt;&gt;&gt;         [[0.0, 1.0, 0.0, 1.0], [0.0, 0.0, 1.0, 1.0], [0.0, 0.0, 0.0, 0.0]],</span>
<span class="sd">        &gt;&gt;&gt;         [[0.0, 1.0, 0.0, 1.0], [0.0, 0.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0]],</span>
<span class="sd">        &gt;&gt;&gt;     ]</span>
<span class="sd">        &gt;&gt;&gt; )</span>
<span class="sd">        &gt;&gt;&gt; pts, s_in, e_in, perc = pp.intersections.segments_polyhedron(s, e, p)</span>

<span class="sd">    Parameters:</span>
<span class="sd">        start: ``shape=(nd, num_segments)``</span>

<span class="sd">            One endpoint of segments.</span>
<span class="sd">        end: ``shape=(nd, num_segments)``</span>

<span class="sd">            Other endpoint of segments.</span>
<span class="sd">        poly: ``shape(nd, num_vertices)``</span>

<span class="sd">            Vertices of polyhedron organised face by face.</span>
<span class="sd">        tol: ``default=1e-5``</span>

<span class="sd">            Tolerance for the geometric computations.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple consisting of</span>

<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(num_segments,)``</span>

<span class="sd">            Intersection points with the polyhedron, start and end points are not</span>
<span class="sd">            included in this list.</span>
<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(num_segments,)``</span>

<span class="sd">            Boolean array indicating whether the start of a segment is inside the</span>
<span class="sd">            polyhedron.</span>
<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(num_segments,)``</span>

<span class="sd">            Boolean array indicating whether the end of a segment is inside the</span>
<span class="sd">            polyhedron.</span>
<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(num_segments,)``</span>

<span class="sd">            Length percentage of a segment inside the polyhedron.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># For a single point make its shape consistent</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">start</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">end</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Check if the vertices are inside or outside the polyhedron</span>
    <span class="n">is_in_start</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">geometry_property_checks</span><span class="o">.</span><span class="n">point_in_polyhedron</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
    <span class="n">is_in_end</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">geometry_property_checks</span><span class="o">.</span><span class="n">point_in_polyhedron</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

    <span class="c1"># Check how many intersections a segment has with the faces of the polyhedron</span>
    <span class="n">extra_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">start</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">extra_pts</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">poly</span><span class="p">:</span>
        <span class="c1"># the face vertices need to be sorted</span>
        <span class="n">sort_ind</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">sort_points</span><span class="o">.</span><span class="n">sort_point_plane</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="c1"># compute if the current face intersect the segments</span>
        <span class="n">is_inside</span><span class="p">,</span> <span class="n">pts</span> <span class="o">=</span> <span class="n">segments_polygon</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">face</span><span class="p">[:,</span> <span class="n">sort_ind</span><span class="p">],</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">is_inside</span><span class="p">):</span>
            <span class="n">extra_pts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">extra_pts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pts</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]]</span>

    <span class="c1"># Loop on the segments and compute the length in the polyhedron</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">start</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="c1"># The segment is all inside</span>
        <span class="k">if</span> <span class="n">is_in_start</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="ow">and</span> <span class="n">is_in_end</span><span class="p">[</span><span class="n">seg</span><span class="p">]:</span>
            <span class="n">length</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">end</span><span class="p">[:,</span> <span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">start</span><span class="p">[:,</span> <span class="n">seg</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">is_in_start</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="ow">and</span> <span class="n">extra_pts</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">length</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">start</span><span class="p">[:,</span> <span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">extra_pts</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">is_in_end</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="ow">and</span> <span class="n">extra_pts</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">length</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">end</span><span class="p">[:,</span> <span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">extra_pts</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">extra_pts</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">length</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">extra_pts</span><span class="p">[</span><span class="n">seg</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">extra_pts</span><span class="p">[</span><span class="n">seg</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Compute the percentage of segment in the polyhedron</span>
    <span class="n">ratio</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,ij-&gt;j&quot;</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">extra_pts</span><span class="p">,</span> <span class="n">is_in_start</span><span class="p">,</span> <span class="n">is_in_end</span><span class="p">,</span> <span class="n">ratio</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_point_in_or_on_polygon</span><span class="p">(</span>
    <span class="n">p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">poly</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function to get intersection information between a point and a polygon.</span>

<span class="sd">    The polygon is classified as being outside, on the boundary or in the interior of</span>
<span class="sd">    the polygon. If on the boundary, the intersection is further classified according</span>
<span class="sd">    to whether it is on a segment or vertex.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        p: ``shape=(nd,)``</span>

<span class="sd">            Point.</span>
<span class="sd">        poly: ``shape=(nd, num_vertices)``</span>

<span class="sd">            Vertices of polygon.</span>
<span class="sd">        tol: ``default=1e-8``</span>

<span class="sd">            Tolerance for the geometric computations.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple consisting of</span>

<span class="sd">        :obj:`int`:</span>
<span class="sd">            value ``0`` for &#39;outside&#39;, ``1`` for &#39;on boundatry&#39;, and ``2`` for</span>
<span class="sd">            &#39;interior&#39;.</span>

<span class="sd">        Optional[tuple[int, None] | tuple[None, int]]:</span>
<span class="sd">            ``None`` if the first value is ``0`` or ``2``. A ``tuple`` if the first</span>
<span class="sd">            value is ``1``. The first and second items are ``None`` in the case of</span>
<span class="sd">            an intersection on a segment and vertex, respectively. Otherwise, the</span>
<span class="sd">            segment or vertex index, correspondingly.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Rotate polygon to its natural plane, also map point.</span>
    <span class="n">cp</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">map_geometry</span><span class="o">.</span><span class="n">project_plane_matrix</span><span class="p">(</span><span class="n">poly</span> <span class="o">-</span> <span class="n">cp</span><span class="p">)</span>
    <span class="n">rot_poly</span> <span class="o">=</span> <span class="n">rot</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">poly</span> <span class="o">-</span> <span class="n">cp</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">rot_p</span> <span class="o">=</span> <span class="n">rot</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">cp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rot_p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
        <span class="c1"># Point not even in the plane of the polygon.</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">pp</span><span class="o">.</span><span class="n">geometry_property_checks</span><span class="o">.</span><span class="n">point_in_polygon</span><span class="p">(</span><span class="n">rot_poly</span><span class="p">,</span> <span class="n">rot_p</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># Point outside the polygon</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span>

    <span class="n">dist</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">points_segments</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">dist</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
        <span class="c1"># Intersection on boundary. Either vertex of segment.</span>
        <span class="n">vert_dist</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">point_pointset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">poly</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vert_dist</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">vert_dist</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)),</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Point inside</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span>


<div class="viewcode-block" id="triangulations">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.geometry.intersections.html#porepy.geometry.intersections.triangulations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">triangulations</span><span class="p">(</span>
    <span class="n">p_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">p_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">t_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">t_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute intersection of two triangle tessellations of a surface.</span>

<span class="sd">    The function will identify partly overlapping triangles between ``t_1`` and ``t_2``,</span>
<span class="sd">    and compute their common area. If parts of domain 1 or 2 are covered by one</span>
<span class="sd">    tessellation only, this will simply be ignored by the function.</span>

<span class="sd">    Note:</span>
<span class="sd">        The function relies on the intersection algorithm in shapely.geometry.Polygon.</span>

<span class="sd">    See also:</span>
<span class="sd">        :meth:`surface_tessellations`</span>

<span class="sd">    Parameters:</span>
<span class="sd">        p_1: ``shape=(2, n_p1)``</span>

<span class="sd">            Points in first tessellation.</span>
<span class="sd">        p_2: ``shape=(2, n_p2)``</span>

<span class="sd">            Points in second tessellation.</span>
<span class="sd">        t_1: ``shape=(3, n_tri_1)``</span>

<span class="sd">            Triangles in first tessellation, referring</span>
<span class="sd">            to indices in p_1.</span>
<span class="sd">        t_2: ``shape = (3, n_tri_1)``</span>

<span class="sd">            Triangles in second tessellation, referring to indices in p_2.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of tuples with each representing an overlap. The tuple consists of</span>

<span class="sd">        :obj:`int`:</span>
<span class="sd">            the index of the triangle in the first tesselation.</span>
<span class="sd">        :obj:`int`:</span>
<span class="sd">            the index of the triangle in the second tesselation.</span>
<span class="sd">        :obj:`float`:</span>
<span class="sd">            the common area of the two triangles in the two tessellations.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># NOTE: Regarding the use of shapely. It may be possible to extend the functionality</span>
    <span class="c1"># to other cell shapes. This would require more general data structures, but should</span>
    <span class="c1"># not be too much of an effort.</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">shapely_geometry</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">shapely.speedups</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">shapely_speedups</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">shapely_speedups</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">n_1</span> <span class="o">=</span> <span class="n">t_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_2</span> <span class="o">=</span> <span class="n">t_2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">t_1</span> <span class="o">=</span> <span class="n">t_1</span><span class="o">.</span><span class="n">T</span>
    <span class="n">t_2</span> <span class="o">=</span> <span class="n">t_2</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Find x and y coordinates of the triangles of first tessellation</span>
    <span class="n">x_1</span> <span class="o">=</span> <span class="n">p_1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_1</span><span class="p">]</span>
    <span class="n">y_1</span> <span class="o">=</span> <span class="n">p_1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_1</span><span class="p">]</span>
    <span class="c1"># Same with second tessellation</span>
    <span class="n">x_2</span> <span class="o">=</span> <span class="n">p_2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_2</span><span class="p">]</span>
    <span class="n">y_2</span> <span class="o">=</span> <span class="n">p_2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_2</span><span class="p">]</span>

    <span class="n">intersections</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Bounding box of each triangle for first and second tessellation</span>
    <span class="n">min_x_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">max_x_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">min_y_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">max_y_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y_1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">min_x_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">max_x_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">min_y_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">max_y_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Represent the second tessellation using a Polygon from the shapely package</span>
    <span class="n">poly_2</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">shapely_geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">x_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">y_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">x_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">x_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">y_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="p">])]</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_2</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># Loop over all triangles in first tessellation, look for overlapping members in</span>
    <span class="c1"># second tessellation</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_1</span><span class="p">):</span>
        <span class="c1"># Polygon representation of the first triangle.</span>
        <span class="n">poly_1</span> <span class="o">=</span> <span class="n">shapely_geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">x_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">y_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">x_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">x_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">y_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">])]</span>
        <span class="p">)</span>
        <span class="c1"># Find triangles in the second tessellation that are outside the</span>
        <span class="c1"># bounding box of this triangle.</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">min_x_2</span> <span class="o">&gt;</span> <span class="n">max_x_1</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">max_x_2</span> <span class="o">&lt;</span> <span class="n">min_x_1</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">above</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">min_y_2</span> <span class="o">&gt;</span> <span class="n">max_y_1</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">max_y_2</span> <span class="o">&lt;</span> <span class="n">min_y_1</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="c1"># Candidates for intersection are only elements not outside</span>
        <span class="n">outside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">above</span><span class="p">,</span> <span class="n">below</span><span class="p">)))</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_2</span><span class="p">),</span> <span class="n">outside</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Loop over remaining candidates, call upon shapely to find</span>
        <span class="c1"># intersection</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
            <span class="n">isect</span> <span class="o">=</span> <span class="n">poly_1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">poly_2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">isect</span><span class="p">,</span> <span class="n">shapely_geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">):</span>
                <span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">isect</span><span class="o">.</span><span class="n">area</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">intersections</span></div>



<div class="viewcode-block" id="line_tessellation">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.geometry.intersections.html#porepy.geometry.intersections.line_tessellation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">line_tessellation</span><span class="p">(</span>
    <span class="n">p1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">p2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">l1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">l2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute intersection of two line segment tessellations of a line.</span>

<span class="sd">    The function will identify partly overlapping line segments between l1 and</span>
<span class="sd">    l2, and compute their common length.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        p1: ``shape=(3, n_p1)``</span>

<span class="sd">            Points in first tessellation.</span>
<span class="sd">        p2: ``shape=(3, n_p2)``</span>

<span class="sd">            Points in second tessellation.</span>
<span class="sd">        l1: ``shape=(2, n_tri_1)``</span>

<span class="sd">            Line segments in first tessellation, referring to indices in ``p2``.</span>
<span class="sd">        l2: ``shape= (2, n_tri_1)``</span>

<span class="sd">            Line segments in second tessellation, referring to indices in ``p2``.</span>

<span class="sd">    Raise:</span>
<span class="sd">        AssertionError: If ``porepy.intersections.segments_3d`` returns an unknown</span>
<span class="sd">            shape.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of tuples with each representing an overlap. The tuple consists of</span>

<span class="sd">        :obj:`int`:</span>
<span class="sd">            the index of the segment in the first tesselation.</span>
<span class="sd">        :obj:`int`:</span>
<span class="sd">            the index of the segment in the second tesselation.</span>
<span class="sd">        :obj:`float`:</span>
<span class="sd">            the common length of the two segments in the two tessellations.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Loop over both set of lines, use segment intersection method to compute common</span>
    <span class="c1"># segments, thus areas.</span>
    <span class="n">intersections</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">start_1</span> <span class="o">=</span> <span class="n">p1</span><span class="p">[:,</span> <span class="n">l1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]]</span>
        <span class="n">end_1</span> <span class="o">=</span> <span class="n">p1</span><span class="p">[:,</span> <span class="n">l1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">start_2</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[:,</span> <span class="n">l2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span>
            <span class="n">end_2</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[:,</span> <span class="n">l2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">segments_3d</span><span class="p">(</span><span class="n">start_1</span><span class="p">,</span> <span class="n">end_1</span><span class="p">,</span> <span class="n">start_2</span><span class="p">,</span> <span class="n">end_2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">X</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Point intersection (zero measure)</span>
                <span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">intersections</span></div>



<div class="viewcode-block" id="surface_tessellations">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.geometry.intersections.html#porepy.geometry.intersections.surface_tessellations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">surface_tessellations</span><span class="p">(</span>
    <span class="n">poly_sets</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="n">return_simplexes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Intersect a set of surface tessellations to find a finer subdivision that does</span>
<span class="sd">    not intersect with any of the input tessellations.</span>

<span class="sd">    It is assumed that the polygon sets are 2d.</span>

<span class="sd">    The implementation relies heavily on shapely&#39;s intersection finders.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        poly_sets: Lists of polygons to be intersected.</span>
<span class="sd">        return_simplexes: ``default=False``</span>

<span class="sd">            If True, the subdivision is further split into a</span>
<span class="sd">            triangulation. The mappings from the original polygons is updated</span>
<span class="sd">            accordingly.</span>

<span class="sd">    Raises:</span>
<span class="sd">        NotImplementedError: If a triangulation of a non-convex polygon is attempted.</span>
<span class="sd">            Can only happen if ``return_simplexes`` is ``True``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple consisting of</span>

<span class="sd">        list of :obj:`~numpy.ndarray`:</span>
<span class="sd">            Each element being a polygon so that the list together form a subdivision</span>
<span class="sd">            of the intersection of all polygons in the input sets.</span>
<span class="sd">        list of :obj:`~scipy.sparse.spmatrix`:</span>
<span class="sd">            Mappings from each of the input polygons to the intersected polygons. If</span>
<span class="sd">            the mapping&#39;s ``item[i][j, k]`` is non-zero, polygon ``k`` in set ``i``</span>
<span class="sd">            has a (generally partial) overlap with polygon ``j`` in the intersected</span>
<span class="sd">            polygon set. Specifically the value will be ``1``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># local imports</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">shapely_geometry</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">shapely.speedups</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">shapely_speedups</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">shapely_speedups</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="c1"># Nothing to do here, but this may be slow.</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_min_max_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
        <span class="c1"># Convenience function to get max and minimum coordinates for a set of polygons</span>
        <span class="n">min_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coord</span><span class="p">])</span>
        <span class="n">max_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coord</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">min_coord</span><span class="p">,</span> <span class="n">max_coord</span>

    <span class="c1"># Convert polygons into a more convenient data structure</span>
    <span class="n">list_of_sets</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">poly_sets</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">poly</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">))]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">poly</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">))]</span>

        <span class="n">list_of_sets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>  <span class="c1"># type: ignore</span>

    <span class="c1"># The below algorithm relies heavily on shapely&#39;s functionality for intersection of</span>
    <span class="c1"># polygons. The idea is to intersect represent each set of polygons in the shapely</span>
    <span class="c1"># format, do the intersections with a new set of polygons to find a finer</span>
    <span class="c1"># intersection, and move on. Also keep track of the mapping from each of the sets of</span>
    <span class="c1"># polygons to the intersected mesh.</span>

    <span class="c1"># Initialize the intersection set as the first set of polygons</span>
    <span class="n">poly_x</span><span class="p">,</span> <span class="n">poly_y</span> <span class="o">=</span> <span class="n">list_of_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">min_x_poly</span><span class="p">,</span> <span class="n">max_x_poly</span> <span class="o">=</span> <span class="n">_min_max_coord</span><span class="p">(</span><span class="n">poly_x</span><span class="p">)</span>
    <span class="n">min_y_poly</span><span class="p">,</span> <span class="n">max_y_poly</span> <span class="o">=</span> <span class="n">_min_max_coord</span><span class="p">(</span><span class="n">poly_y</span><span class="p">)</span>

    <span class="c1"># poly_shapely will at any time represent the intersected polygon in shapely format,</span>
    <span class="c1"># for the currently covered set of polygon sets.</span>
    <span class="n">poly_shapely</span><span class="p">:</span> <span class="n">shapely_geometry</span><span class="o">.</span><span class="n">Polygon</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">poly_x</span><span class="p">,</span> <span class="n">poly_y</span><span class="p">):</span>
        <span class="n">poly_shapely</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">shapely_geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([(</span><span class="n">px</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">py</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">px</span><span class="o">.</span><span class="n">size</span><span class="p">)])</span>
        <span class="p">)</span>

    <span class="c1"># Data structure for mappings from original polygon sets to the intersected one</span>
    <span class="c1"># As the partition is extended to cover more polygons, a new mapping will be added</span>
    <span class="c1"># and the previous mappings are updated to account for the new intersection level.</span>
    <span class="n">nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly_shapely</span><span class="p">)</span>
    <span class="n">mappings</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">sps</span><span class="o">.</span><span class="n">dia_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
    <span class="p">]</span>

    <span class="c1"># Loop over all set of polygons, do intersection with existing</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_sets</span><span class="p">)):</span>

        <span class="c1"># Represent this polygon as in shapely format. Also find max and min coordinates</span>
        <span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span> <span class="o">=</span> <span class="n">list_of_sets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">min_x_new</span><span class="p">,</span> <span class="n">max_x_new</span> <span class="o">=</span> <span class="n">_min_max_coord</span><span class="p">(</span><span class="n">new_x</span><span class="p">)</span>
        <span class="n">min_y_new</span><span class="p">,</span> <span class="n">max_y_new</span> <span class="o">=</span> <span class="n">_min_max_coord</span><span class="p">(</span><span class="n">new_y</span><span class="p">)</span>
        <span class="n">new_shapely</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">):</span>
            <span class="n">new_shapely</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">shapely_geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([(</span><span class="n">px</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">py</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">px</span><span class="o">.</span><span class="n">size</span><span class="p">)])</span>
            <span class="p">)</span>
        <span class="n">num_new</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_shapely</span><span class="p">)</span>

        <span class="c1"># Data structure to store the new intersected polygon</span>
        <span class="n">isect_x</span><span class="p">,</span> <span class="n">isect_y</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="c1"># Data structure to construct mappings to the new intersection from both this</span>
        <span class="c1"># and the previously covered polygons</span>
        <span class="n">row_new</span><span class="p">,</span> <span class="n">row_poly</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">col_new</span><span class="p">,</span> <span class="n">col_poly</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="n">isect_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Loop over all elements in the intersected polygon</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly_shapely</span><span class="p">)):</span>

            <span class="c1"># Find cells in the new polygon that are clearly outside this polygon This</span>
            <span class="c1"># corresponds to creating a box around this intersected polygon, and</span>
            <span class="c1"># disregard all new polygons clearly outside this box.</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">min_x_new</span> <span class="o">&gt;</span> <span class="n">max_x_poly</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">max_x_new</span> <span class="o">&lt;</span> <span class="n">min_x_poly</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="n">above</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">min_y_new</span> <span class="o">&gt;</span> <span class="n">max_y_poly</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="n">below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">max_y_new</span> <span class="o">&lt;</span> <span class="n">min_y_poly</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

            <span class="n">outside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">above</span><span class="p">,</span> <span class="n">below</span><span class="p">)))</span>
            <span class="c1"># Candidates are near this box</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_new</span><span class="p">),</span> <span class="n">outside</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Loop over remaining candidates, call upon shapely to find intersection</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
                <span class="n">isect</span> <span class="o">=</span> <span class="n">poly_shapely</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">new_shapely</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">isect</span><span class="p">,</span> <span class="n">shapely_geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">):</span>
                    <span class="c1"># This is what must be done to get the coordinates from shapely</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">isect</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
                    <span class="c1"># The shapely Polygon has the start/endpoint represented twice.</span>
                    <span class="c1"># Disregard the end.</span>
                    <span class="n">isect_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="n">ci</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]))</span>
                    <span class="n">isect_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="n">ci</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]))</span>

                    <span class="c1"># Build up the mapping to the new intersected polygon</span>
                    <span class="n">col_new</span> <span class="o">+=</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">col_poly</span> <span class="o">+=</span> <span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">row_new</span> <span class="o">+=</span> <span class="p">[</span><span class="n">isect_counter</span><span class="p">]</span>
                    <span class="n">row_poly</span> <span class="o">+=</span> <span class="p">[</span><span class="n">isect_counter</span><span class="p">]</span>
                    <span class="n">isect_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Mapping from the previously considered polygon to the newly found dissection.</span>
        <span class="c1"># This will be applied to update all previous mappings.</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">isect_counter</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="n">row_poly</span><span class="p">,</span> <span class="n">col_poly</span><span class="p">)),</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">isect_counter</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly_shapely</span><span class="p">)),</span>
        <span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mappings</span><span class="p">)):</span>
            <span class="n">mappings</span><span class="p">[</span><span class="n">mi</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span> <span class="o">*</span> <span class="n">mappings</span><span class="p">[</span><span class="n">mi</span><span class="p">]</span>

        <span class="c1"># Add a mapping between the current polygon and the newly found intersection.</span>
        <span class="n">mappings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">sps</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">isect_counter</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="n">row_new</span><span class="p">,</span> <span class="n">col_new</span><span class="p">)),</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">isect_counter</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_shapely</span><span class="p">)),</span>
            <span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># Define the new set of intersected polygons</span>
        <span class="n">min_x_poly</span><span class="p">,</span> <span class="n">max_x_poly</span> <span class="o">=</span> <span class="n">_min_max_coord</span><span class="p">(</span><span class="n">isect_x</span><span class="p">)</span>
        <span class="n">min_y_poly</span><span class="p">,</span> <span class="n">max_y_poly</span> <span class="o">=</span> <span class="n">_min_max_coord</span><span class="p">(</span><span class="n">isect_y</span><span class="p">)</span>
        <span class="n">poly_shapely</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">isect_x</span><span class="p">,</span> <span class="n">isect_y</span><span class="p">):</span>
            <span class="n">poly_shapely</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">shapely_geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([(</span><span class="n">px</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">py</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">px</span><span class="o">.</span><span class="n">size</span><span class="p">)])</span>
            <span class="p">)</span>

    <span class="c1"># Finally, translate the intersected polygons back to a list of np.ndarrays</span>
    <span class="n">isect_polys</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">))</span> <span class="k">for</span> <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">isect_x</span><span class="p">,</span> <span class="n">isect_y</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="n">return_simplexes</span><span class="p">:</span>
        <span class="c1"># Finally, if requested, convert the subdivision into a triangulation. This</span>
        <span class="c1"># option is primarily intended for easy quadrature on the subdivision. Note that</span>
        <span class="c1"># no guarantees are given on the quality of the triangulation.</span>

        <span class="c1"># IMPLEMENTATION NOTE: This could have been turned into a separate function.</span>
        <span class="c1"># However, the code is only tested for a limited set of cases (specifically,</span>
        <span class="c1"># we have considered intersection of non-matching grids on surfaces), so it</span>
        <span class="c1"># seems premature to promote it to a general-purpose function.</span>

        <span class="c1"># We will need a triangulation below</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">Delaunay</span>

        <span class="c1"># Data structure for the mapping from isect_polys to the triangulation</span>
        <span class="n">rows</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cols</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tri_counter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Data structure for the triangulation</span>
        <span class="n">tri</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Loop over all isect_polys, split those with more than three vertices</span>
        <span class="c1"># EK: Somehow, mypy does not understand poly will be an np.ndarray, thus all</span>
        <span class="c1"># ignores</span>
        <span class="k">for</span> <span class="n">pi</span><span class="p">,</span> <span class="n">poly</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">isect_polys</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
            <span class="k">if</span> <span class="n">poly</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
                <span class="c1"># Triangles can be used as they are</span>
                <span class="n">tri</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tri_counter</span><span class="p">)</span>
                <span class="n">tri_counter</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Check if the polygon is convex. Loop over the polygon vertices, and</span>
                <span class="c1"># check if they form a CW or CCW part of the polygon. If they all have</span>
                <span class="c1"># the same configuration, the polygon is convex</span>

                <span class="c1"># Three representation of the polygon vertices, by shifting their order</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">poly</span>
                <span class="c1"># This is the vertex we test</span>
                <span class="n">middle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                <span class="c1"># Use ccw test on all vertices in the polygon</span>
                <span class="n">is_ccw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">pp</span><span class="o">.</span><span class="n">geometry_property_checks</span><span class="o">.</span><span class="n">is_ccw_polyline</span><span class="p">(</span>
                            <span class="n">start</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">middle</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">end</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>  <span class="c1"># type:ignore</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># type:ignore</span>
                    <span class="p">]</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">is_ccw</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">is_ccw</span><span class="p">)):</span>
                    <span class="c1"># This is a convex polygon. The triangulation can be formed by a</span>
                    <span class="c1"># Delaunay tessellation of the polygon. In an attempt to improve the</span>
                    <span class="c1"># quality of the simplexes, we add the center of the polygon</span>
                    <span class="c1"># (defined as the mean coordinate, should be fine since the polygon</span>
                    <span class="c1"># is convex) to the points to be triangulated. This may not be</span>
                    <span class="c1"># necessary, and should be up for revision. If the polygon has a bad</span>
                    <span class="c1"># shape, the triangulation will also have bad triangles - to improve</span>
                    <span class="c1"># we would need to do a more careful triangulation, adding more</span>
                    <span class="c1"># points</span>
                    <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
                    <span class="n">ext_poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">poly</span><span class="p">,</span> <span class="n">center</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># type: ignore</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">ext_poly</span><span class="p">)</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span>
                        <span class="n">tri</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ext_poly</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                        <span class="c1">#</span>
                        <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
                        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tri_counter</span><span class="p">)</span>
                        <span class="n">tri_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># For non-convex polygons, the Delaunay triangulation will generate</span>
                    <span class="c1"># simplexes not inside the polygon; specifically the triangulation</span>
                    <span class="c1"># will cover the convex hull of the polygon. These can likely be</span>
                    <span class="c1"># pruned by excluding triangles with a center not inside the polygon</span>
                    <span class="c1"># (would need a point-in-polygon test for non-convex polygons), but</span>
                    <span class="c1"># that would be for another day.</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Non-convex polygons not covered&quot;</span><span class="p">)</span>

        <span class="c1"># Also update the mapping.</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)),</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">isect_polys</span><span class="p">)),</span>
        <span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mappings</span><span class="p">)):</span>
            <span class="n">mappings</span><span class="p">[</span><span class="n">mi</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span> <span class="o">*</span> <span class="n">mappings</span><span class="p">[</span><span class="n">mi</span><span class="p">]</span>

        <span class="n">isect_polys</span> <span class="o">=</span> <span class="n">tri</span>

    <span class="k">return</span> <span class="n">isect_polys</span><span class="p">,</span> <span class="n">mappings</span></div>



<div class="viewcode-block" id="split_intersecting_segments_2d">
<a class="viewcode-back" href="../../../docsrc/porepy/porepy.geometry.intersections.html#porepy.geometry.intersections.split_intersecting_segments_2d">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">split_intersecting_segments_2d</span><span class="p">(</span>
    <span class="n">p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="n">return_argsort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
    <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
<span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Process a set of points and connections between them so that the result</span>
<span class="sd">    is an extended point set and new connections that do not intersect.</span>

<span class="sd">    The function is written for gridding of fractured domains, but may be of use in</span>
<span class="sd">    other cases as well. The geometry is assumed to be 2D.</span>

<span class="sd">    The connections are defined by their start and endpoints, and can also have tags</span>
<span class="sd">    assigned. If so, the tags are preserved as connections are split. The connections</span>
<span class="sd">    are uniquified, so that no combination of point indices occurs more than once.</span>

<span class="sd">    Note:</span>
<span class="sd">        For (partly) overlapping segments, only one of the tags will survive the</span>
<span class="sd">        uniquification. The other can be reconstructed by using the third output.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        p: ``shape=(2, n_pt)``</span>

<span class="sd">            Coordinates of points to be processed.</span>
<span class="sd">        e: ``shape=(n, n_con)``</span>

<span class="sd">            Connections between lines. n &gt;= 2, row</span>
<span class="sd">            0 and 1 are index of start and endpoints, additional rows are tags.</span>
<span class="sd">        tol: ``default=1e-8``</span>

<span class="sd">            Tolerance used for comparing equal points.</span>
<span class="sd">        return_argsort: ``default=False``</span>

<span class="sd">            Return the mapping between the input segments and the output</span>
<span class="sd">            segments.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tuple with three or four entries (last only returned if ``return_argsort``</span>
<span class="sd">        is ``True``). The entries are as follows</span>

<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(2, n_pt)``</span>

<span class="sd">            Points.</span>
<span class="sd">        :obj:`~numpy.ndarray`: ``shape=)2, n_edges)``</span>

<span class="sd">            new, non-intersecting edges.</span>
<span class="sd">        2-tuple of :obj:`~numpy.ndarray`:</span>
<span class="sd">            two arrays with length ``n_con`` with the first item being a set of tags,</span>
<span class="sd">            before uniquification of the edges, and the second being a column mapping</span>
<span class="sd">            from the unique edges to all edges. To recover lost tags associated with</span>
<span class="sd">            the points in column ``i``, first find all original columns which maps</span>
<span class="sd">            to ``i`` (``tuple[1] == i``), then recover the tags by the hits.</span>
<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(n_edges,)``</span>

<span class="sd">            mapping of the new edges to the input edges.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Find the bounding box</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">_axis_aligned_bounding_box_2d</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>

    <span class="c1"># If a polygon is perfectly aligned with a coordinate axis, and another polygon</span>
    <span class="c1"># terminates in the first one, rounding errors in the coordinates may lead to the</span>
    <span class="c1"># intersection not being picked up. To circumvent the issue, detect such situations</span>
    <span class="c1"># and give ourselves a bit wiggle room. It seems that this will not give problems in</span>
    <span class="c1"># other cases.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">cmin</span><span class="p">,</span> <span class="n">cmax</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">),</span> <span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)]:</span>
        <span class="n">hit</span> <span class="o">=</span> <span class="n">cmax</span> <span class="o">-</span> <span class="n">cmin</span> <span class="o">&lt;</span> <span class="n">tol</span>
        <span class="n">cmin</span><span class="p">[</span><span class="n">hit</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">tol</span>
        <span class="n">cmax</span><span class="p">[</span><span class="n">hit</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">tol</span>

    <span class="c1"># Identify fractures with overlapping bounding boxes</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="n">_identify_overlapping_rectangles</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span>

    <span class="c1"># Identify all fractures that are the first (by index) of a potentially crossing</span>
    <span class="c1"># pair. A better way to group the fractures may be feasible, but this has not been</span>
    <span class="c1"># investigated.</span>
    <span class="n">start_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">num_lines</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Data structure for storage of intersection points. For each fracture,</span>
    <span class="c1"># we have an array that will contain the index of the intersections.</span>
    <span class="n">isect_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">num_lines</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">isect_pt</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="n">isect_pt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Array of new points, found in the intersection of old ones.</span>
    <span class="n">new_pts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># The new points will be appended to the old ones, thus their index</span>
    <span class="c1"># must be adjusted.</span>
    <span class="n">new_ind</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Loop through all candidate pairs of intersecting fractures, check if they do</span>
    <span class="c1"># intersect. If so, store the point, and for each crossing fracture take note of the</span>
    <span class="c1"># index of the cross point.</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">line_ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">start_inds</span><span class="p">):</span>
        <span class="c1"># First fracture in the candidate pair</span>
        <span class="n">main</span> <span class="o">=</span> <span class="n">line_ind</span>
        <span class="c1"># Find all other fractures that is in a pair with the main as the first one.</span>
        <span class="n">hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">main</span><span class="p">)</span>
        <span class="c1"># Sort the other points; this makes debugging simpler if nothing else.</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">hit</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># We will first do a coarse sorting, to rule out fractures that are clearly</span>
        <span class="c1"># not intersecting, and then do a finer search for an intersection below.</span>

        <span class="c1"># Utility function to pull out one or several points from an array based on</span>
        <span class="c1"># index</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">pt</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ind</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span>

        <span class="c1"># Obtain start and endpoint of the main and other fractures</span>
        <span class="n">start_main</span> <span class="o">=</span> <span class="n">pt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">main</span><span class="p">])</span>
        <span class="n">end_main</span> <span class="o">=</span> <span class="n">pt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">main</span><span class="p">])</span>
        <span class="n">start_other</span> <span class="o">=</span> <span class="n">pt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>
        <span class="n">end_other</span> <span class="o">=</span> <span class="n">pt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>

        <span class="c1"># Utility function to normalize the fracture length</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="n">nrm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

            <span class="c1"># If the norm of the vector is essentially zero, do not normalize the vector</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="n">nrm</span> <span class="o">&lt;</span> <span class="n">tol</span>
            <span class="n">nrm</span><span class="p">[</span><span class="n">hit</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">v</span> <span class="o">/</span> <span class="n">nrm</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">dist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Vectors along the main fracture, and from the start of the main to the start</span>
        <span class="c1"># and end of the other fractures. All normalized. If the other edges share start</span>
        <span class="c1"># or endpoint with the main one, normalization of the distance vector will make</span>
        <span class="c1"># the vector nans. In this case, we use another point along the other line, this</span>
        <span class="c1"># works equally well for the coarse identification (based on cross products). If</span>
        <span class="c1"># the segments are overlapping, there will still be issues with nans, but these</span>
        <span class="c1"># are dealt with below.</span>
        <span class="n">main_vec</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">end_main</span> <span class="o">-</span> <span class="n">start_main</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dist</span><span class="p">(</span><span class="n">start_other</span><span class="p">,</span> <span class="n">start_main</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">main_other_start</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">start_other</span> <span class="o">-</span> <span class="n">start_main</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">main_other_start</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">start_other</span> <span class="o">+</span> <span class="n">end_other</span><span class="p">)</span> <span class="o">-</span> <span class="n">start_main</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dist</span><span class="p">(</span><span class="n">end_other</span><span class="p">,</span> <span class="n">start_main</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">main_other_end</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">end_other</span> <span class="o">-</span> <span class="n">start_main</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Values 0.3 and 0.7 are quite random here.</span>
            <span class="n">main_other_end</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="mf">0.3</span> <span class="o">*</span> <span class="n">start_other</span> <span class="o">+</span> <span class="mf">0.7</span> <span class="o">*</span> <span class="n">end_other</span> <span class="o">-</span> <span class="n">start_main</span><span class="p">)</span>

        <span class="c1"># Modified signum function: The value is 0 if it is very close to zero.</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">mod_sign</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
            <span class="n">sgn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">sgn</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">sgn</span>

        <span class="c1"># Take the cross product between the vector along the main line, and the</span>
        <span class="c1"># vectors to the start and end of the other lines, respectively.</span>
        <span class="n">start_cross</span> <span class="o">=</span> <span class="n">mod_sign</span><span class="p">(</span>
            <span class="n">main_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">main_other_start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">main_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">main_other_start</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tol</span>
        <span class="p">)</span>
        <span class="n">end_cross</span> <span class="o">=</span> <span class="n">mod_sign</span><span class="p">(</span>
            <span class="n">main_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">main_other_end</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">main_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">main_other_end</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tol</span>
        <span class="p">)</span>

        <span class="c1"># If the start and endpoint of the other fracture are clearly on the same side</span>
        <span class="c1"># of the main one, these are not crossing. For completely ovrelapping edges, the</span>
        <span class="c1"># normalization will leave the vectors nan. There may be better ways of dealing</span>
        <span class="c1"># with this, but we simply run the intersection finder in this case.</span>
        <span class="n">relevant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                <span class="p">(</span><span class="n">start_cross</span> <span class="o">*</span> <span class="n">end_cross</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">main_other_start</span> <span class="o">+</span> <span class="n">main_other_end</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Loop over all relevant (possibly crossing) fractures, look closer for an</span>
        <span class="c1"># intersection.</span>
        <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">relevant</span><span class="p">:</span>
            <span class="n">ipt</span> <span class="o">=</span> <span class="n">segments_2d</span><span class="p">(</span>
                <span class="n">start_main</span><span class="p">,</span> <span class="n">end_main</span><span class="p">,</span> <span class="n">pt</span><span class="p">(</span><span class="n">start_other</span><span class="p">,</span> <span class="n">ri</span><span class="p">),</span> <span class="n">pt</span><span class="p">(</span><span class="n">end_other</span><span class="p">,</span> <span class="n">ri</span><span class="p">),</span> <span class="n">tol</span>
            <span class="p">)</span>
            <span class="c1"># Add the intersection point, if any. If two intersection points are found,</span>
            <span class="c1"># that is the edges are overlapping both points are added.</span>
            <span class="k">if</span> <span class="n">ipt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">num_isect</span> <span class="o">=</span> <span class="n">ipt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># Add indices of the new points to the main and other edge</span>
                <span class="n">isect_pt</span><span class="p">[</span><span class="n">main</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">isect_pt</span><span class="p">[</span><span class="n">main</span><span class="p">],</span> <span class="n">new_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_isect</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">isect_pt</span><span class="p">[</span><span class="n">other</span><span class="p">[</span><span class="n">ri</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">isect_pt</span><span class="p">[</span><span class="n">other</span><span class="p">[</span><span class="n">ri</span><span class="p">]],</span> <span class="n">new_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_isect</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">new_ind</span> <span class="o">+=</span> <span class="n">num_isect</span>

                <span class="c1"># Add the one or two intertion points</span>
                <span class="k">if</span> <span class="n">num_isect</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">new_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ipt</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># It turned out the transport was needed to get the code to work</span>
                    <span class="n">new_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ipt</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="c1"># If we have found no intersection points, we can safely return the incoming</span>
    <span class="c1"># points and edges.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_pts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Tag information is trivial in this case</span>
        <span class="n">tags</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">tag_info</span> <span class="o">=</span> <span class="p">(</span><span class="n">tags</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_argsort</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">tag_info</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">tag_info</span>

    <span class="c1"># If intersection points are found, the intersecting lines must be split into</span>
    <span class="c1"># shorter segments.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># The full set of points, both original and newly found intersection points</span>
        <span class="n">all_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new_pts</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
        <span class="c1"># Remove duplicates in the point set.</span>
        <span class="c1"># NOTE: The tolerance used here is a bit sensitive, if set too loose, this</span>
        <span class="c1"># may merge non-intersecting fractures.</span>

        <span class="n">unique_all_pt</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">ib</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">setmembership</span><span class="o">.</span><span class="n">uniquify_point_set</span><span class="p">(</span><span class="n">all_pt</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

        <span class="c1"># Data structure for storing the split edges.</span>
        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">e</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">argsort</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Loop over all lines, split it into non-overlapping segments.</span>
        <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_lines</span><span class="p">):</span>
            <span class="c1"># Find indices of all points involved in this fracture. Map them to the</span>
            <span class="c1"># unique point set, and uniquify</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ib</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">e</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ei</span><span class="p">],</span> <span class="n">isect_pt</span><span class="p">[</span><span class="n">ei</span><span class="p">]))])</span>
            <span class="n">num_branches</span> <span class="o">=</span> <span class="n">inds</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># Get the coordinates themselves.</span>
            <span class="n">loc_pts</span> <span class="o">=</span> <span class="n">pt</span><span class="p">(</span><span class="n">unique_all_pt</span><span class="p">,</span> <span class="n">inds</span><span class="p">)</span>
            <span class="c1"># Specifically get the start point: Pick one of the points of the original</span>
            <span class="c1"># edge, e[0, ei], which is known to be at an end of the edge. map to the</span>
            <span class="c1"># unique indices</span>
            <span class="n">loc_start</span> <span class="o">=</span> <span class="n">pt</span><span class="p">(</span><span class="n">unique_all_pt</span><span class="p">,</span> <span class="n">ib</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ei</span><span class="p">]])</span>
            <span class="c1"># Measure the distance of the points from the start. This can be used to</span>
            <span class="c1"># sort the points along the line</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">loc_pts</span> <span class="o">-</span> <span class="n">loc_start</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>  <span class="c1"># Needed to appease mypy</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
            <span class="n">new_inds</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
            <span class="c1"># All new segments share the tags of the old one.</span>
            <span class="n">loc_tags</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span> <span class="n">ei</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_branches</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="c1"># Define the new segments, in terms of the unique points</span>
            <span class="n">loc_edge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">new_inds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">new_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">loc_tags</span><span class="p">))</span>

            <span class="c1"># Add to the global list of segments</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">loc_edge</span><span class="p">))</span>
            <span class="n">argsort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">argsort</span><span class="p">,</span> <span class="p">[</span><span class="n">ei</span><span class="p">]</span> <span class="o">*</span> <span class="n">loc_edge</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># Finally, uniquify edges. This operation is necessary for overlapping edges.</span>
        <span class="c1"># Operate on sorted point indices per edge</span>
        <span class="n">new_edge</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">new_edge</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Keep the old tags before uniquifying</span>
        <span class="n">tags</span> <span class="o">=</span> <span class="n">new_edge</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="c1"># Uniquify.</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">edge_map</span><span class="p">,</span> <span class="n">all_2_unique</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">setmembership</span><span class="o">.</span><span class="n">unique_columns_tol</span><span class="p">(</span>
            <span class="n">new_edge</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">tol</span>
        <span class="p">)</span>
        <span class="n">tag_info</span> <span class="o">=</span> <span class="p">(</span><span class="n">tags</span><span class="p">,</span> <span class="n">all_2_unique</span><span class="p">)</span>

        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">new_edge</span><span class="p">[:,</span> <span class="n">edge_map</span><span class="p">]</span>
        <span class="n">argsort</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">[</span><span class="n">edge_map</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">return_argsort</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">unique_all_pt</span><span class="p">,</span> <span class="n">new_edge</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">tag_info</span><span class="p">,</span> <span class="n">argsort</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">unique_all_pt</span><span class="p">,</span> <span class="n">new_edge</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">tag_info</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_axis_aligned_bounding_box_2d</span><span class="p">(</span>
    <span class="n">p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For a set of lines in 2d, obtain the bounding box for each line.</span>

<span class="sd">    The lines are specified as a list of points, together with connections between</span>
<span class="sd">    the points.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        p: ``shape=(2, n_pt)``</span>

<span class="sd">            Coordinates of points to be processed.</span>
<span class="sd">        e: ``shape = (n, n_con)``</span>

<span class="sd">            Connections between lines. ``n &gt;= 2``, row 0 and 1 are indices of start and</span>
<span class="sd">            endpoints, additional rows are tags</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple consisting of</span>

<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(n_pt,)``</span>
<span class="sd">            Minimum x-coordinate for all lines.</span>
<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(n_pt,)``</span>
<span class="sd">            Maximum x-coordinate for all lines.</span>
<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(n_pt,)``</span>
<span class="sd">            Minimum y-coordinate for all lines.</span>
<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(n_pt,)``</span>
<span class="sd">            Maximum y-coordinate for all lines.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">x_0</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">x_1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">y_0</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">y_1</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="n">x_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x_0</span><span class="p">,</span> <span class="n">x_1</span><span class="p">)</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x_0</span><span class="p">,</span> <span class="n">x_1</span><span class="p">)</span>
    <span class="n">y_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">y_0</span><span class="p">,</span> <span class="n">y_1</span><span class="p">)</span>
    <span class="n">y_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">y_0</span><span class="p">,</span> <span class="n">y_1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_axis_aligned_bounding_box_3d</span><span class="p">(</span>
    <span class="n">polys</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For a set of polygons embedded in 3d, obtain the bounding box for each object.</span>

<span class="sd">    The polygons are specified as a list of numpy arrays.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        p: ``shape=(3, n_pt)``</span>

<span class="sd">            Each list element specifies a polygon,</span>
<span class="sd">            described by its vertices in a ``(3, num_points)`` array.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple consisting of</span>

<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(n_pt,)``</span>

<span class="sd">            Minimum x-coordinate for all lines.</span>
<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(n_pt,)``</span>

<span class="sd">            Maximum x-coordinate for all lines.</span>
<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(n_pt,)``</span>

<span class="sd">            Minimum y-coordinate for all lines.</span>
<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(n_pt,)``</span>

<span class="sd">            Maximum y-coordinate for all lines.</span>
<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(n_pt,)``</span>

<span class="sd">            Minimum z-coordinate for all lines.</span>
<span class="sd">        :obj:`~numpy.ndarray`: ``shape=(n_pt,)``</span>

<span class="sd">            Maximum z-coordinate for all lines.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">polys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>

    <span class="n">num_poly</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>

    <span class="n">x_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">num_poly</span><span class="p">)</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span>
    <span class="n">y_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span>
    <span class="n">y_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span>
    <span class="n">z_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span>
    <span class="n">z_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polys</span><span class="p">):</span>
        <span class="n">x_min</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">x_max</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">y_min</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">y_max</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">z_min</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">z_max</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_identify_overlapping_intervals</span><span class="p">(</span><span class="n">left</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Based on a set of start and end coordinates for intervals, identify pairs of</span>
<span class="sd">    overlapping intervals.</span>

<span class="sd">    Note:</span>
<span class="sd">        For all corresponding entries in ``left`` and ``right``, ``left &lt;= right``</span>
<span class="sd">        is required, but equality is allowed.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        left: ``shape=(num_intervals,)``</span>

<span class="sd">            Minimum coordinates of the intervals.</span>
<span class="sd">        right: ``shape=(num_intervals,)``</span>

<span class="sd">            Maximum coordinates of the intervals.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Array with shape ``(2, num_overlaps)`` with each column containing a pair of</span>
<span class="sd">        overlapping intervals, refering to their placement in left and right.</span>
<span class="sd">        The pairs are sorted so that the lowest index is in the first column.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># There can be no overlaps if there is less than two intervals</span>
    <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Sort the coordinates</span>
    <span class="n">sort_ind_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
    <span class="n">sort_ind_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

    <span class="c1"># pointers to the next start and end point of an interval</span>
    <span class="n">next_right</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">next_left</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># List of pairs we have found</span>
    <span class="n">pairs</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># List of intervals we are currently in. All intervals will join and leave this set.</span>
    <span class="n">active</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">num_lines</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">size</span>

    <span class="c1"># Loop through the line, add and remove intervals as we come across them.</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Check if the next start (left) point is before the next endpoint, but only if</span>
        <span class="c1"># there are more left points available. Less or equal is critical here, or else</span>
        <span class="c1"># cases where a point interval is combined with the start of another interval</span>
        <span class="c1"># may not be discovered.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">next_left</span> <span class="o">&lt;</span> <span class="n">num_lines</span>
            <span class="ow">and</span> <span class="n">left</span><span class="p">[</span><span class="n">sort_ind_left</span><span class="p">[</span><span class="n">next_left</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">[</span><span class="n">sort_ind_right</span><span class="p">[</span><span class="n">next_right</span><span class="p">]]</span>
        <span class="p">):</span>
            <span class="c1"># We have started a new interval. This will be paired with all active</span>
            <span class="c1"># intervals</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">active</span><span class="p">:</span>
                <span class="n">pairs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">sort_ind_left</span><span class="p">[</span><span class="n">next_left</span><span class="p">]])</span>
            <span class="c1"># Also join the new intervals to the active set.</span>
            <span class="n">active</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_ind_left</span><span class="p">[</span><span class="n">next_left</span><span class="p">])</span>
            <span class="c1"># Increase the index</span>
            <span class="n">next_left</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We have reached the end of the interval - remove it from the active ones.</span>
            <span class="n">active</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sort_ind_right</span><span class="p">[</span><span class="n">next_right</span><span class="p">])</span>
            <span class="n">next_right</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Check if we have come to the end</span>
            <span class="k">if</span> <span class="n">next_right</span> <span class="o">==</span> <span class="n">num_lines</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">final_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># First sort the pairs themselves</span>
        <span class="n">final_pairs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Next, sort the columns so that the first row is non-decreasing</span>
        <span class="n">sort_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">final_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">final_pairs</span> <span class="o">=</span> <span class="n">final_pairs</span><span class="p">[:,</span> <span class="n">sort_ind</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">final_pairs</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_identify_overlapping_rectangles</span><span class="p">(</span>
    <span class="n">xmin</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">xmax</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ymin</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ymax</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Based on a set of start and end coordinates for bounding boxes, identify pairs</span>
<span class="sd">    of overlapping rectangles.</span>

<span class="sd">    Note:</span>
<span class="sd">        For all corresponding entries it has to hold ``xmin &lt;= xmax``, but equality</span>
<span class="sd">        is allowed. Analogously for the y-components.</span>

<span class="sd">    Note:</span>
<span class="sd">        The algorithm was found in &#39;A fast method for fracture intersection detection in</span>
<span class="sd">        discrete fracture networks&#39; by Dong et al, Computers and Geotechniques 2018.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        xmin: ``shape=(num_rectangles,)``</span>

<span class="sd">            Minimum coordinates of the rectangle on the</span>
<span class="sd">            first axis.</span>
<span class="sd">        xmax: ``shape=(num_rectangles,)``</span>

<span class="sd">            Maximum coordinates of the rectangle on the</span>
<span class="sd">            first axis.</span>
<span class="sd">        ymin: ``shape=(num_rectangles,)``</span>

<span class="sd">            Minimum coordinates of the rectangle on the</span>
<span class="sd">            second axis.</span>
<span class="sd">        ymax: ``shape=(num_rectangles,)``</span>

<span class="sd">            Maximum coordinates of the rectangle on the</span>
<span class="sd">            second axis.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Array with shape ``(2, num_overlaps)`` with each column containing a pair of</span>
<span class="sd">        overlapping intervals, refering to their placement in left and right. The pairs</span>
<span class="sd">        are sorted so that the lowest index is in the first column.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># There can be no overlaps if there is less than two rectangles</span>
    <span class="k">if</span> <span class="n">xmin</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Sort the coordinates</span>
    <span class="n">sort_ind_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span>
    <span class="n">sort_ind_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">xmax</span><span class="p">)</span>

    <span class="c1"># pointers to the next start and end point of an interval</span>
    <span class="n">next_min</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">next_max</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># List of pairs we have found</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># List of intervals we are currently in. All intervals will join and leave this</span>
    <span class="c1"># set.</span>
    <span class="n">active</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">num_lines</span> <span class="o">=</span> <span class="n">xmax</span><span class="o">.</span><span class="n">size</span>

    <span class="c1"># Pass along the x-axis, identify the start and end of rectangles as we go. The idea</span>
    <span class="c1"># is then for each new interval to check which of the active intervals also have</span>
    <span class="c1"># overlap along the y-axis. These will be identified as pairs.</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Check if the next start (xmin) point is before the next endpoint, but only if</span>
        <span class="c1"># there are more left points available. Less or equal is critical here, or else</span>
        <span class="c1"># cases where a point interval is combined with the start of another interval</span>
        <span class="c1"># may not be discovered.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">next_min</span> <span class="o">&lt;</span> <span class="n">num_lines</span>
            <span class="ow">and</span> <span class="n">xmin</span><span class="p">[</span><span class="n">sort_ind_min</span><span class="p">[</span><span class="n">next_min</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">[</span><span class="n">sort_ind_max</span><span class="p">[</span><span class="n">next_max</span><span class="p">]]</span>
        <span class="p">):</span>
            <span class="c1"># Find active rectangles where the y-interval is also overlapping</span>
            <span class="n">between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                    <span class="n">ymax</span><span class="p">[</span><span class="n">sort_ind_min</span><span class="p">[</span><span class="n">next_min</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="n">ymin</span><span class="p">[</span><span class="n">active</span><span class="p">],</span>
                    <span class="n">ymin</span><span class="p">[</span><span class="n">sort_ind_min</span><span class="p">[</span><span class="n">next_min</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">ymax</span><span class="p">[</span><span class="n">active</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># For all identified overlaps, add the new pairs</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">between</span><span class="p">:</span>
                <span class="n">pairs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">active</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">sort_ind_min</span><span class="p">[</span><span class="n">next_min</span><span class="p">]])</span>
            <span class="c1"># Add this to the active rectangles, and increase the index</span>
            <span class="n">active</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_ind_min</span><span class="p">[</span><span class="n">next_min</span><span class="p">])</span>
            <span class="n">next_min</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We are leaving a rectangle.</span>
            <span class="n">active</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sort_ind_max</span><span class="p">[</span><span class="n">next_max</span><span class="p">])</span>
            <span class="n">next_max</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Check if we have come to the end</span>
            <span class="k">if</span> <span class="n">next_max</span> <span class="o">==</span> <span class="n">num_lines</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">final_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># First sort the pairs themselves</span>
        <span class="n">final_pairs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Next, sort the columns so that the first row is non-decreasing</span>
        <span class="n">sort_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">final_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">final_pairs</span> <span class="o">=</span> <span class="n">final_pairs</span><span class="p">[:,</span> <span class="n">sort_ind</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">final_pairs</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_intersect_pairs</span><span class="p">(</span><span class="n">p1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">p2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For two lists containing pair of indices, find the intersection.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        p1: ``shape=(2, n)``</span>

<span class="sd">            Each column contains a pair of indices.</span>
<span class="sd">        p2: ``shape=(2, m)``</span>

<span class="sd">            Each column contains a pair of indices.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Array with shape ``(2, k)`` where ``k &lt;= min(n, m)`` with each column containing</span>
<span class="sd">        a pair of indices that are found in both ``p1`` and ``p2``. The array is sorted</span>
<span class="sd">        so that items in the first row is less or equal to the second row. The columns</span>
<span class="sd">        are sorted according to the numbers in the first row.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Special treatment of empty lists</span>
    <span class="k">if</span> <span class="n">p1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">p2</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Do the intersection</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">setmembership</span><span class="o">.</span><span class="n">ismember_rows</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">]</span>

        <span class="c1"># First sort the pairs themselves</span>
        <span class="n">pairs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Next, sort the columns so that the first row is non-decreasing</span>
        <span class="n">sort_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[:,</span> <span class="n">sort_ind</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">pairs</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022 UiB Center for Modeling of Coupled Subsurface Dynamics, GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007..</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>