<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>porepy.geometry.intersections &mdash; PorePy 1.5 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="canonical" href="https://pmgbergen.github.io/porepy/_modules/porepy/geometry/intersections.html" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >
            <a href="../../../index.html" class="icon icon-home"> PorePy
          </a>
              <div class="version">
                docs/alpha
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docsrc/howto/howto-docstring.html">1. How-To docstring</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docsrc/porepy/porepy.html">porepy package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.html">porepy.fracs package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture.html">porepy.fracs.fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_importer.html">porepy.fracs.fracture_importer module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_network_2d.html">porepy.fracs.fracture_network_2d module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html">porepy.fracs.fracture_network_3d module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.gmsh_interface.html">porepy.fracs.gmsh_interface module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.line_fracture.html">porepy.fracs.line_fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.meshing.html">porepy.fracs.meshing module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.msh_2_grid.html">porepy.fracs.msh_2_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.non_conforming.html">porepy.fracs.non_conforming module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.plane_fracture.html">porepy.fracs.plane_fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.simplex.html">porepy.fracs.simplex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.split_grid.html">porepy.fracs.split_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.structured.html">porepy.fracs.structured module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.tools.html">porepy.fracs.tools module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.utils.html">porepy.fracs.utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.fracs.wells_3d.html">porepy.fracs.wells_3d module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.html">porepy.geometry package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.bounding_box.html">porepy.geometry.bounding_box module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.constrain_geometry.html">porepy.geometry.constrain_geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.distances.html">porepy.geometry.distances module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.geometry_property_checks.html">porepy.geometry.geometry_property_checks module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.half_space.html">porepy.geometry.half_space module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.intersections.html">porepy.geometry.intersections module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.map_geometry.html">porepy.geometry.map_geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.geometry.point_in_polyhedron_test.html">porepy.geometry.point_in_polyhedron_test module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.html">porepy.grids package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.html">porepy.grids.standard_grids package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.md_grids_2d.html">porepy.grids.standard_grids.md_grids_2d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.md_grids_3d.html">porepy.grids.standard_grids.md_grids_3d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.standard_grids.utils.html">porepy.grids.standard_grids.utils module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.coarsening.html">porepy.grids.coarsening module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.grid.html">porepy.grids.grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.grid_extrusion.html">porepy.grids.grid_extrusion module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.match_grids.html">porepy.grids.match_grids module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.md_grid.html">porepy.grids.md_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.mortar_grid.html">porepy.grids.mortar_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.partition.html">porepy.grids.partition module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.point_grid.html">porepy.grids.point_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.refinement.html">porepy.grids.refinement module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.simplex.html">porepy.grids.simplex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.grids.structured.html">porepy.grids.structured module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.html">porepy.models package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.abstract_model.html">porepy.models.abstract_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.contact_mechanics_biot_model.html">porepy.models.contact_mechanics_biot_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.contact_mechanics_model.html">porepy.models.contact_mechanics_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.incompressible_flow_model.html">porepy.models.incompressible_flow_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.run_models.html">porepy.models.run_models module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.slightly_compressible_flow_model.html">porepy.models.slightly_compressible_flow_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.models.thm_model.html">porepy.models.thm_model module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.html">porepy.numerics package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.html">porepy.numerics.ad package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.discretizations.html">porepy.numerics.ad.discretizations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.equation_manager.html">porepy.numerics.ad.equation_manager module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.forward_mode.html">porepy.numerics.ad.forward_mode module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.functions.html">porepy.numerics.ad.functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.grid_operators.html">porepy.numerics.ad.grid_operators module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.operator_functions.html">porepy.numerics.ad.operator_functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.operators.html">porepy.numerics.ad.operators module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.ad.time_derivatives.html">porepy.numerics.ad.time_derivatives module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fem.html">porepy.numerics.fem package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fem.rt0.html">porepy.numerics.fem.rt0 module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.html">porepy.numerics.fracture_deformation package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.conforming_propagation.html">porepy.numerics.fracture_deformation.conforming_propagation module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.contact_conditions.html">porepy.numerics.fracture_deformation.contact_conditions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.propagate_fracture.html">porepy.numerics.fracture_deformation.propagate_fracture module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fracture_deformation.propagation_model.html">porepy.numerics.fracture_deformation.propagation_model module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.html">porepy.numerics.fv package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.biot.html">porepy.numerics.fv.biot module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.fv_elliptic.html">porepy.numerics.fv.fv_elliptic module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.fvutils.html">porepy.numerics.fv.fvutils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.mass_matrix.html">porepy.numerics.fv.mass_matrix module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.mpfa.html">porepy.numerics.fv.mpfa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.mpsa.html">porepy.numerics.fv.mpsa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.source.html">porepy.numerics.fv.source module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.tpfa.html">porepy.numerics.fv.tpfa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.fv.upwind.html">porepy.numerics.fv.upwind module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.html">porepy.numerics.interface_laws package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.abstract_interface_law.html">porepy.numerics.interface_laws.abstract_interface_law module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.cell_dof_face_dof_map.html">porepy.numerics.interface_laws.cell_dof_face_dof_map module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.contact_mechanics_interface_laws.html">porepy.numerics.interface_laws.contact_mechanics_interface_laws module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.elliptic_discretization.html">porepy.numerics.interface_laws.elliptic_discretization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.elliptic_interface_laws.html">porepy.numerics.interface_laws.elliptic_interface_laws module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.interface_laws.hyperbolic_interface_laws.html">porepy.numerics.interface_laws.hyperbolic_interface_laws module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linalg.html">porepy.numerics.linalg package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linalg.matrix_operations.html">porepy.numerics.linalg.matrix_operations module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.html">porepy.numerics.mixed_dim package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler.html">porepy.numerics.mixed_dim.assembler module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler_filters.html">porepy.numerics.mixed_dim.assembler_filters module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.mixed_dim.dof_manager.html">porepy.numerics.mixed_dim.dof_manager module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.nonlinear.html">porepy.numerics.nonlinear package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.nonlinear.nonlinear_solvers.html">porepy.numerics.nonlinear.nonlinear_solvers module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.solvers.html">porepy.numerics.solvers package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.solvers.andersonacceleration.html">porepy.numerics.solvers.andersonacceleration module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.html">porepy.numerics.vem package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.dual_elliptic.html">porepy.numerics.vem.dual_elliptic module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.hybrid.html">porepy.numerics.vem.hybrid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.mass_matrix.html">porepy.numerics.vem.mass_matrix module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.mvem.html">porepy.numerics.vem.mvem module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.vem.vem_source.html">porepy.numerics.vem.vem_source module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.discretization.html">porepy.numerics.discretization module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.displacement_correlation.html">porepy.numerics.displacement_correlation module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.linear_solvers.html">porepy.numerics.linear_solvers module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.numerics.time_step_control.html">porepy.numerics.time_step_control module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.html">porepy.params package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.bc.html">porepy.params.bc module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.data.html">porepy.params.data module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.fluid.html">porepy.params.fluid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.parameter_dictionaries.html">porepy.params.parameter_dictionaries module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.rock.html">porepy.params.rock module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.params.tensor.html">porepy.params.tensor module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.html">porepy.utils package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.derived_discretizations.html">porepy.utils.derived_discretizations package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.derived_discretizations.implicit_euler.html">porepy.utils.derived_discretizations.implicit_euler module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.accumarray.html">porepy.utils.accumarray module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.adtree.html">porepy.utils.adtree module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.array_operations.html">porepy.utils.array_operations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.common_constants.html">porepy.utils.common_constants module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.default_domains.html">porepy.utils.default_domains module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.error.html">porepy.utils.error module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.graph.html">porepy.utils.graph module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.grid_utils.html">porepy.utils.grid_utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.interpolation_tables.html">porepy.utils.interpolation_tables module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.mcolon.html">porepy.utils.mcolon module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.permutations.html">porepy.utils.permutations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.setmembership.html">porepy.utils.setmembership module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.sort_points.html">porepy.utils.sort_points module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.tags.html">porepy.utils.tags module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.utils.tangential_normal_projection.html">porepy.utils.tangential_normal_projection module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.html">porepy.viz package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.exporter.html">porepy.viz.exporter module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.fracture_visualization.html">porepy.viz.fracture_visualization module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../docsrc/porepy/porepy.viz.plot_grid.html">porepy.viz.plot_grid module</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PorePy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">porepy.geometry.intersections</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for porepy.geometry.intersections</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module with functions for computing intersections between geometric objects.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sps</span>

<span class="kn">import</span> <span class="nn">porepy</span> <span class="k">as</span> <span class="nn">pp</span>

<span class="c1"># Module level logger</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="segments_2d"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.geometry.intersections.html#porepy.geometry.intersections.segments_2d">[docs]</a><span class="k">def</span> <span class="nf">segments_2d</span><span class="p">(</span>
    <span class="n">start_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">end_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">start_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">end_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if two line segments defined by their start end endpoints, intersect.</span>

<span class="sd">    The lines are assumed to be in 2D.</span>

<span class="sd">    Note that, oposed to other functions related to grid generation such as</span>
<span class="sd">    remove_edge_crossings, this function does not use the concept of</span>
<span class="sd">    snap_to_grid. This may cause problems at some point, although no issues</span>
<span class="sd">    have been discovered so far.</span>

<span class="sd">    Implementation note:</span>
<span class="sd">        This function can be replaced by a call to segments_3d. Todo.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; lines_intersect([0, 0], [1, 1], [0, 1], [1, 0])</span>
<span class="sd">        array([[ 0.5],</span>
<span class="sd">           [ 0.5]])</span>

<span class="sd">        &gt;&gt;&gt; lines_intersect([0, 0], [1, 0], [0, 1], [1, 1])</span>

<span class="sd">    Parameters:</span>
<span class="sd">        start_1 (np.ndarray or list): coordinates of start point for first</span>
<span class="sd">            line.</span>
<span class="sd">        end_1 (np.ndarray or list): coordinates of end point for first line.</span>
<span class="sd">        start_2 (np.ndarray or list): coordinates of start point for first</span>
<span class="sd">            line.</span>
<span class="sd">        end_2 (np.ndarray or list): coordinates of end point for first line.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray (2 x num_pts): coordinates of intersection point, or the</span>
<span class="sd">            endpoints of the intersection segments if relevant. In the case of</span>
<span class="sd">            a segment, the first point (column) will be closest to start_1.  If</span>
<span class="sd">            the lines do not intersect, None is returned.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError if the start and endpoints of a line are the same.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">start_1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">end_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">end_1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">start_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">start_2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">end_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">end_2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Vectors along first and second line</span>
    <span class="n">d_1</span> <span class="o">=</span> <span class="n">end_1</span> <span class="o">-</span> <span class="n">start_1</span>
    <span class="n">d_2</span> <span class="o">=</span> <span class="n">end_2</span> <span class="o">-</span> <span class="n">start_2</span>

    <span class="n">length_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d_1</span> <span class="o">*</span> <span class="n">d_1</span><span class="p">))</span>
    <span class="n">length_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d_2</span> <span class="o">*</span> <span class="n">d_2</span><span class="p">))</span>

    <span class="c1"># Vector between the start points</span>
    <span class="n">d_s</span> <span class="o">=</span> <span class="n">start_2</span> <span class="o">-</span> <span class="n">start_1</span>

    <span class="c1"># An intersection point is characterized by</span>
    <span class="c1">#   start_1 + d_1 * t_1 = start_2 + d_2 * t_2</span>
    <span class="c1">#</span>
    <span class="c1"># which on component form becomes</span>
    <span class="c1">#</span>
    <span class="c1">#   d_1[0] * t_1 - d_2[0] * t_2 = d_s[0]</span>
    <span class="c1">#   d_1[1] * t_1 - d_2[1] * t_2 = d_s[1]</span>
    <span class="c1">#</span>
    <span class="c1"># First check for solvability of the system (e.g. parallel lines) by the</span>
    <span class="c1"># determinant of the matrix.</span>

    <span class="n">discr</span> <span class="o">=</span> <span class="n">d_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">d_2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">d_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">d_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Check if lines are parallel.</span>
    <span class="c1"># The tolerance should be relative to the length of d_1 and d_2</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">discr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">length_1</span> <span class="o">*</span> <span class="n">length_2</span><span class="p">:</span>
        <span class="c1"># The lines are parallel, and will only cross if they are also colinear</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;The segments are parallel&quot;</span><span class="p">)</span>
        <span class="c1"># Cross product between line 1 and line between start points on line</span>
        <span class="n">start_cross_line</span> <span class="o">=</span> <span class="n">d_s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d_s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">start_cross_line</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">length_1</span><span class="p">,</span> <span class="n">length_2</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Lines are colinear&quot;</span><span class="p">)</span>
            <span class="c1"># The lines are co-linear</span>

            <span class="c1"># Write l1 on the form start_1 + t * d_1, find the parameter value</span>
            <span class="c1"># needed for equality with start_2 and end_2</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">length_1</span><span class="p">:</span>
                <span class="n">t_start_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">d_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">t_end_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">d_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d_1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">length_2</span><span class="p">:</span>
                <span class="n">t_start_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">d_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">t_end_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">d_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># d_1 is zero</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Found what must be a point-edge&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Start and endpoint of line should be</span><span class="se">\</span>
<span class="s2">                                 different&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">t_start_2</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">t_end_2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Lines are not overlapping&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">t_start_2</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">t_end_2</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Lines are not overlapping&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="c1"># We have an overlap, find its parameter values</span>
            <span class="n">t_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">t_start_2</span><span class="p">,</span> <span class="n">t_end_2</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">t_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">t_start_2</span><span class="p">,</span> <span class="n">t_end_2</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">t_max</span> <span class="o">-</span> <span class="n">t_min</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="c1"># It seems this can only happen if they are also equal to 0 or</span>
                <span class="c1"># 1, that is, the lines share a single point</span>
                <span class="n">p_1</span> <span class="o">=</span> <span class="n">start_1</span> <span class="o">+</span> <span class="n">d_1</span> <span class="o">*</span> <span class="n">t_min</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Colinear lines share a single point&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">p_1</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Colinear lines intersect along segment&quot;</span><span class="p">)</span>
            <span class="n">p_1</span> <span class="o">=</span> <span class="n">start_1</span> <span class="o">+</span> <span class="n">d_1</span> <span class="o">*</span> <span class="n">t_min</span>
            <span class="n">p_2</span> <span class="o">=</span> <span class="n">start_1</span> <span class="o">+</span> <span class="n">d_1</span> <span class="o">*</span> <span class="n">t_max</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">p_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">p_1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Lines are not colinear&quot;</span><span class="p">)</span>
            <span class="c1"># Lines are parallel, but not colinear</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Solve linear system using Cramer&#39;s rule</span>
        <span class="n">t_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">d_s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">d_2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">d_s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">d_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">/</span> <span class="n">discr</span>
        <span class="n">t_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">d_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">discr</span>

        <span class="n">isect_1</span> <span class="o">=</span> <span class="n">start_1</span> <span class="o">+</span> <span class="n">t_1</span> <span class="o">*</span> <span class="n">d_1</span>
        <span class="n">isect_2</span> <span class="o">=</span> <span class="n">start_2</span> <span class="o">+</span> <span class="n">t_2</span> <span class="o">*</span> <span class="n">d_2</span>
        <span class="c1"># Safeguarding</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">isect_1</span><span class="p">,</span> <span class="n">isect_2</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

        <span class="c1"># The intersection lies on both segments if both t_1 and t_2 are on the</span>
        <span class="c1"># unit interval.</span>
        <span class="c1"># Use tol to allow some approximations</span>
        <span class="k">if</span> <span class="n">t_1</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">tol</span> <span class="ow">and</span> <span class="n">t_1</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">tol</span><span class="p">)</span> <span class="ow">and</span> <span class="n">t_2</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">tol</span> <span class="ow">and</span> <span class="n">t_2</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">tol</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Segment intersection found in one point&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">isect_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">isect_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>

        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="segments_3d"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.geometry.intersections.html#porepy.geometry.intersections.segments_3d">[docs]</a><span class="k">def</span> <span class="nf">segments_3d</span><span class="p">(</span>
    <span class="n">start_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">end_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">start_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">end_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find intersection points (or segments) of two 3d lines.</span>

<span class="sd">    Note that, opposed to other functions related to grid generation such as</span>
<span class="sd">    remove_edge_crossings, this function does not use the concept of</span>
<span class="sd">    snap_to_grid. This may cause problems at some point, although no issues</span>
<span class="sd">    have been discovered so far.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        start_1 (np.ndarray): coordinates of start point for first</span>
<span class="sd">            line.</span>
<span class="sd">        end_1 (np.ndarray): coordinates of end point for first line.</span>
<span class="sd">        start_2 (np.ndarray): coordinates of start point for first</span>
<span class="sd">            line.</span>
<span class="sd">        end_2 (np.ndarray): coordinates of end point for first line.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray, dimension 3 x n_pts: coordinates of intersection points</span>
<span class="sd">            (number of columns will be either 1 for a point intersection, or 2</span>
<span class="sd">            for a segment intersection). If the lines do not intersect, None is</span>
<span class="sd">            returned.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Shorthand for component of start and end points, as well as vectors</span>
    <span class="c1"># along lines.</span>
    <span class="n">xs_1</span> <span class="o">=</span> <span class="n">start_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ys_1</span> <span class="o">=</span> <span class="n">start_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">zs_1</span> <span class="o">=</span> <span class="n">start_1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">xe_1</span> <span class="o">=</span> <span class="n">end_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ye_1</span> <span class="o">=</span> <span class="n">end_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ze_1</span> <span class="o">=</span> <span class="n">end_1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">dx_1</span> <span class="o">=</span> <span class="n">xe_1</span> <span class="o">-</span> <span class="n">xs_1</span>
    <span class="n">dy_1</span> <span class="o">=</span> <span class="n">ye_1</span> <span class="o">-</span> <span class="n">ys_1</span>
    <span class="n">dz_1</span> <span class="o">=</span> <span class="n">ze_1</span> <span class="o">-</span> <span class="n">zs_1</span>

    <span class="n">xs_2</span> <span class="o">=</span> <span class="n">start_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ys_2</span> <span class="o">=</span> <span class="n">start_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">zs_2</span> <span class="o">=</span> <span class="n">start_2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">xe_2</span> <span class="o">=</span> <span class="n">end_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ye_2</span> <span class="o">=</span> <span class="n">end_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ze_2</span> <span class="o">=</span> <span class="n">end_2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">dx_2</span> <span class="o">=</span> <span class="n">xe_2</span> <span class="o">-</span> <span class="n">xs_2</span>
    <span class="n">dy_2</span> <span class="o">=</span> <span class="n">ye_2</span> <span class="o">-</span> <span class="n">ys_2</span>
    <span class="n">dz_2</span> <span class="o">=</span> <span class="n">ze_2</span> <span class="o">-</span> <span class="n">zs_2</span>

    <span class="c1"># The lines are parallel in the x-y plane, but we don&#39;t know about the</span>
    <span class="c1"># z-direction. CHeck this</span>
    <span class="n">deltas_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dx_1</span><span class="p">,</span> <span class="n">dy_1</span><span class="p">,</span> <span class="n">dz_1</span><span class="p">])</span>
    <span class="n">deltas_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dx_2</span><span class="p">,</span> <span class="n">dy_2</span><span class="p">,</span> <span class="n">dz_2</span><span class="p">])</span>

    <span class="c1"># Find non-zero elements</span>
    <span class="n">mask_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">deltas_1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span>
    <span class="n">mask_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">deltas_2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span>

    <span class="c1"># Check for two dimensions that are not parallel with at least one line</span>
    <span class="n">mask_sum</span> <span class="o">=</span> <span class="n">mask_1</span> <span class="o">+</span> <span class="n">mask_2</span>

    <span class="k">if</span> <span class="n">mask_sum</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mask_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">mask_sum</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">in_discr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">not_in_discr</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="n">mask_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">mask_sum</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">in_discr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">not_in_discr</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">in_discr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">not_in_discr</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># We&#39;re going to have a zero discriminant anyhow, just pick some dimensions.</span>
        <span class="n">in_discr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">not_in_discr</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="n">discr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">deltas_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">deltas_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="o">-</span> <span class="n">deltas_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="n">deltas_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="p">)</span>

    <span class="c1"># An intersection will be a solution of the linear system</span>
    <span class="c1">#   xs_1 + dx_1 * t_1 = xs_2 + dx_2 * t_2 (1)</span>
    <span class="c1">#   ys_1 + dy_1 * t_1 = ys_2 + dy_2 * t_2 (2)</span>
    <span class="c1">#</span>
    <span class="c1"># In addition, the solution should satisfy</span>
    <span class="c1">#   zs_1 + dz_1 * t_1 = zs_2 + dz_2 * t_2 (3)</span>
    <span class="c1">#</span>
    <span class="c1"># The intersection is on the line segments if 0 &lt;= (t_1, t_2) &lt;= 1</span>

    <span class="c1"># Either the lines are parallel in two directions</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">discr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
        <span class="c1"># If the lines are (almost) parallel, there is no single intersection,</span>
        <span class="c1"># but it may be a segment</span>

        <span class="c1"># First check if the third dimension is also parallel, if not, no</span>
        <span class="c1"># intersection</span>

        <span class="c1"># A first, simple test</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask_1</span> <span class="o">!=</span> <span class="n">mask_2</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">deltas_1</span><span class="p">[</span><span class="n">mask_1</span><span class="p">]</span> <span class="o">/</span> <span class="n">deltas_2</span><span class="p">[</span><span class="n">mask_2</span><span class="p">]</span>

        <span class="c1"># Second, test for alignment in all directions</span>
        <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">tol</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># If we have made it this far, the lines are indeed parallel. Next,</span>
        <span class="c1"># check that they lay along the same line.</span>
        <span class="n">diff_start</span> <span class="o">=</span> <span class="n">start_2</span> <span class="o">-</span> <span class="n">start_1</span>

        <span class="n">dstart_x_delta_x</span> <span class="o">=</span> <span class="n">diff_start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">deltas_1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">diff_start</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">deltas_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dstart_x_delta_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">dstart_x_delta_y</span> <span class="o">=</span> <span class="n">diff_start</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">deltas_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">diff_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">deltas_1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dstart_x_delta_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">dstart_x_delta_z</span> <span class="o">=</span> <span class="n">diff_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">deltas_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">diff_start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">deltas_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dstart_x_delta_z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># For dimensions with an incline, the vector between segment start</span>
        <span class="c1"># points should be parallel to the segments.</span>
        <span class="c1"># Since the masks are equal, we can use any of them.</span>
        <span class="c1"># For dimensions with no incline, the start coordinates should be the same</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">start_1</span><span class="p">[</span><span class="o">~</span><span class="n">mask_1</span><span class="p">],</span> <span class="n">start_2</span><span class="p">[</span><span class="o">~</span><span class="n">mask_1</span><span class="p">],</span> <span class="n">tol</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># We have overlapping lines! finally check if segments are overlapping.</span>

        <span class="c1"># Since everything is parallel, it suffices to work with a single coordinate</span>
        <span class="n">s_1</span> <span class="o">=</span> <span class="n">start_1</span><span class="p">[</span><span class="n">mask_1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">e_1</span> <span class="o">=</span> <span class="n">end_1</span><span class="p">[</span><span class="n">mask_1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">s_2</span> <span class="o">=</span> <span class="n">start_2</span><span class="p">[</span><span class="n">mask_1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">e_2</span> <span class="o">=</span> <span class="n">end_2</span><span class="p">[</span><span class="n">mask_1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">max_1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">s_1</span><span class="p">,</span> <span class="n">e_1</span><span class="p">)</span>
        <span class="n">min_1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">s_1</span><span class="p">,</span> <span class="n">e_1</span><span class="p">)</span>
        <span class="n">max_2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">s_2</span><span class="p">,</span> <span class="n">e_2</span><span class="p">)</span>
        <span class="n">min_2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">s_2</span><span class="p">,</span> <span class="n">e_2</span><span class="p">)</span>

        <span class="c1"># Rule out case with non-overlapping segments</span>
        <span class="k">if</span> <span class="n">max_1</span> <span class="o">&lt;</span> <span class="n">min_2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">max_2</span> <span class="o">&lt;</span> <span class="n">min_1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># The lines are overlapping, we need to find their common line</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s_1</span><span class="p">,</span> <span class="n">e_1</span><span class="p">,</span> <span class="n">s_2</span><span class="p">,</span> <span class="n">e_2</span><span class="p">])</span>
        <span class="n">sort_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

        <span class="c1"># The overlap will be between the middle two points in the sorted list</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">sort_ind</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

        <span class="c1"># Array of the full coordinates - same order as lines</span>
        <span class="n">lines_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">start_1</span><span class="p">,</span> <span class="n">end_1</span><span class="p">,</span> <span class="n">start_2</span><span class="p">,</span> <span class="n">end_2</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="c1"># Our segment consists of the second and third column. We&#39;re done!</span>
        <span class="k">return</span> <span class="n">lines_full</span><span class="p">[:,</span> <span class="n">target</span><span class="p">]</span>

    <span class="c1"># or we are looking for a point intersection</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Solve 2x2 system by Cramer&#39;s rule</span>

        <span class="n">discr</span> <span class="o">=</span> <span class="n">deltas_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">deltas_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">-</span> <span class="n">deltas_1</span><span class="p">[</span>
            <span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">deltas_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">t_1</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">start_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">start_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">deltas_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="o">-</span> <span class="p">(</span><span class="n">start_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">start_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">deltas_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="p">)</span> <span class="o">/</span> <span class="n">discr</span>

        <span class="n">t_2</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">deltas_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="p">(</span><span class="n">start_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">start_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="o">-</span> <span class="n">deltas_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="p">(</span><span class="n">start_2</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">start_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="p">)</span> <span class="o">/</span> <span class="n">discr</span>

        <span class="c1"># Check that we are on line segment</span>
        <span class="k">if</span> <span class="n">t_1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">t_1</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">t_2</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">t_2</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Compute the z-coordinates of the intersection points</span>
        <span class="n">z_1_isect</span> <span class="o">=</span> <span class="n">start_1</span><span class="p">[</span><span class="n">not_in_discr</span><span class="p">]</span> <span class="o">+</span> <span class="n">t_1</span> <span class="o">*</span> <span class="n">deltas_1</span><span class="p">[</span><span class="n">not_in_discr</span><span class="p">]</span>
        <span class="n">z_2_isect</span> <span class="o">=</span> <span class="n">start_2</span><span class="p">[</span><span class="n">not_in_discr</span><span class="p">]</span> <span class="o">+</span> <span class="n">t_2</span> <span class="o">*</span> <span class="n">deltas_2</span><span class="p">[</span><span class="n">not_in_discr</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z_1_isect</span> <span class="o">-</span> <span class="n">z_2_isect</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">vec</span><span class="p">[</span><span class="n">in_discr</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">]</span> <span class="o">+</span> <span class="n">t_1</span> <span class="o">*</span> <span class="n">deltas_1</span><span class="p">[</span><span class="n">in_discr</span><span class="p">]</span>
            <span class="n">vec</span><span class="p">[</span><span class="n">not_in_discr</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_1_isect</span>
            <span class="k">return</span> <span class="n">vec</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="polygons_3d"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.geometry.intersections.html#porepy.geometry.intersections.polygons_3d">[docs]</a><span class="k">def</span> <span class="nf">polygons_3d</span><span class="p">(</span>
    <span class="n">polys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">target_poly</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
    <span class="n">include_point_contact</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Compute the intersection between polygons embedded in 3d.</span>

<span class="sd">    In addition to intersection points, the function also decides:</span>
<span class="sd">        1) Whether intersection points lie in the interior, on a segment or a vertex.</span>
<span class="sd">           If segment or vertex, the index of the segment or vertex is returned.</span>
<span class="sd">        2) Whether a pair of intersection points lie on the same boundary segment of a</span>
<span class="sd">           polygon, that is, if the polygon has a T or L-type intersection with another</span>
<span class="sd">           polygon.</span>

<span class="sd">    Assumptions:</span>
<span class="sd">        * All polygons are convex. Non-convex polygons will simply be treated</span>
<span class="sd">            in a wrong way. To circumvent this, split the non-convex polygon into convex</span>
<span class="sd">            parts.</span>
<span class="sd">        * No polygon contains three points on a line, that is, an angle of pi. This can</span>
<span class="sd">            be included, possibly by temporarily stripping the hanging node from the</span>
<span class="sd">            polygon definition.</span>
<span class="sd">        * If two polygons meet in a vertex, this is not considered an intersection.</span>
<span class="sd">        * If two polygons lie in the same plane, intersection types (vertex, segment,</span>
<span class="sd">            interior) are not classified. This will be clear from the returned values.</span>
<span class="sd">            Inclusion of this should be possible, but it has not been a priority.</span>
<span class="sd">        * Contact between polygons in a single point may not be accurately calculated.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        polys (list of np.array): Each list item represents a polygon, specified</span>
<span class="sd">            by its vertexes as a numpy array, of dimension 3 x num_pts. There</span>
<span class="sd">            should be at least three vertexes in the polygon.</span>
<span class="sd">        target_poly (int or np.array, optional): Index in poly of the polygons that</span>
<span class="sd">            should be targeted for intersection findings. These will be compared with the</span>
<span class="sd">            whole set in poly. If not provided, all polygons are compared with</span>
<span class="sd">            each other.</span>
<span class="sd">        tol (double, optional): Geometric tolerance for the computations.</span>
<span class="sd">        include_point_contact (bool, optional): If True (default) point contacts will be</span>
<span class="sd">            considered an intersection. This is an experimental feature, use with care.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array: 3 x num_pt, intersection coordinates.</span>
<span class="sd">        np.array of lists: For each of the polygons, give the index of the intersection</span>
<span class="sd">            points, referring to the columns of the intersection coordinates.</span>
<span class="sd">        np.array of list: For each polygon, a list telling whether each of the intersections</span>
<span class="sd">            is on the boundary of the polygon or not. For polygon i, the first</span>
<span class="sd">            element in this list tells whether the point formed by point-indices</span>
<span class="sd">            0 and 1 in the previous return argument is on the boundary.</span>
<span class="sd">        list of tuples: Each list element is a 2-tuple with the indices of</span>
<span class="sd">            intersecting polygons.</span>
<span class="sd">        list of list of tuples: For each polygon, for all intersection points (same</span>
<span class="sd">            order as the second return value), a 2-tuple, where the first value</span>
<span class="sd">            gives an index, the second is a Boolean, True if the intersection is on a</span>
<span class="sd">            segment, False if vertex. The index identifies the vertex, or the first</span>
<span class="sd">            vertex of the segment. If the intersection is in the interior of a polygon,</span>
<span class="sd">            the tuple is replaced by an empty list.</span>
<span class="sd">        np.ndarray of list of bool: For each polygon, for all intersection points,</span>
<span class="sd">            True if this intersection is formed by a single point.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">target_poly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">target_poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_poly</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">target_poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">target_poly</span><span class="p">)</span>

    <span class="c1"># Obtain bounding boxes for the polygons</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span> <span class="o">=</span> <span class="n">_axis_aligned_bounding_box_3d</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>

    <span class="c1"># If a polygon is perfectly aligned with a coordinate axis, and another polygon</span>
    <span class="c1"># terminates in the first one, rounding errors in the coordinates may lead to</span>
    <span class="c1"># the intersection not being picked up. To circumvent the issue, detect such</span>
    <span class="c1"># situations and give ourselves a bit wiggle room.</span>
    <span class="c1"># It seems that this will not give problems in other cases.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">cmin</span><span class="p">,</span> <span class="n">cmax</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">),</span> <span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">),</span> <span class="p">(</span><span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span><span class="p">)]:</span>
        <span class="n">hit</span> <span class="o">=</span> <span class="n">cmax</span> <span class="o">-</span> <span class="n">cmin</span> <span class="o">&lt;</span> <span class="n">tol</span>
        <span class="n">cmin</span><span class="p">[</span><span class="n">hit</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">tol</span>
        <span class="n">cmax</span><span class="p">[</span><span class="n">hit</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">tol</span>

    <span class="c1"># Identify overlapping bounding boxes: First, use a fast method to find</span>
    <span class="c1"># overlapping rectangles in the xy-plane.</span>
    <span class="n">pairs_xy</span> <span class="o">=</span> <span class="n">_identify_overlapping_rectangles</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span>
    <span class="c1"># Next, find overlapping intervals in the z-directien</span>
    <span class="n">pairs_z</span> <span class="o">=</span> <span class="n">_identify_overlapping_intervals</span><span class="p">(</span><span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span><span class="p">)</span>

    <span class="c1"># Finally, do the intersection</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="n">_intersect_pairs</span><span class="p">(</span><span class="n">pairs_xy</span><span class="p">,</span> <span class="n">pairs_z</span><span class="p">)</span>

    <span class="c1"># Various utility functions</span>
    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="c1"># Compute the mean coordinate of a set of points</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
        <span class="c1"># Normalize a vector</span>
        <span class="n">nrm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">v</span> <span class="o">/</span> <span class="n">nrm</span>

    <span class="k">def</span> <span class="nf">mod_sign</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="c1"># Modified signum function: The value is 0 if it is very close to zero.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">sgn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">sgn</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">sgn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">center</span><span class="p">):</span>
        <span class="c1"># Find a point p on the segment between start and end, so that the vector</span>
        <span class="c1"># p - center is perpendicular to normal</span>

        <span class="c1"># Vector along the segment</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
        <span class="n">dot_prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">normal</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dot_prod</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-6</span>
        <span class="n">t</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">start</span> <span class="o">-</span> <span class="n">center</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span> <span class="o">*</span> <span class="n">normal</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span> <span class="o">/</span> <span class="n">dot_prod</span>

        <span class="k">assert</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">start</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">dx</span>

    <span class="k">def</span> <span class="nf">vector_pointset_point</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
        <span class="c1"># Create a set of non-zero vectors from a point in the plane spanned by</span>
        <span class="c1"># a, to all points in b</span>
        <span class="c1"># Loop over all points in a, search for a point that is sufficiently</span>
        <span class="c1"># far away from b. Mainly this involves finding a point in a which is</span>
        <span class="c1"># not in b</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">dist</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tol</span>
        <span class="k">return</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">num_polys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>

    <span class="c1"># Storage array for storing the index of the intersection points for each polygon</span>
    <span class="n">isect_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">num_polys</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="c1"># Storage for whether an intersection is on the boundary of a polygon</span>
    <span class="n">is_bound_isect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">isect_pt</span><span class="p">)</span>
    <span class="c1"># Storage for which segment or vertex of a polygon is intersected</span>
    <span class="n">segment_vertex_intersection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">isect_pt</span><span class="p">)</span>
    <span class="n">is_point_contact</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">num_polys</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

    <span class="c1"># Initialization</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">isect_pt</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="n">isect_pt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">is_point_contact</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Array for storing the newly found points</span>
    <span class="n">new_pt</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_pt_ind</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Index of the main fractures, to which the other ones will be compared.</span>
    <span class="c1"># Filter out all that are not among the targets.</span>
    <span class="n">start_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">target_poly</span><span class="p">,</span> <span class="n">pairs</span><span class="p">)</span>

    <span class="c1"># Store index of pairs of intersecting polygons</span>
    <span class="n">polygon_pairs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Pre-compute polygon normals to save computational time</span>
    <span class="n">polygon_normals</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">map_geometry</span><span class="o">.</span><span class="n">compute_normal</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polys</span>
    <span class="p">]</span>

    <span class="c1"># Loop over all fracture pairs (taking more than one simultaneously if an index</span>
    <span class="c1"># occurs several times in pairs[0]), and look for intersections</span>
    <span class="k">for</span> <span class="n">di</span><span class="p">,</span> <span class="n">line_ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">start_inds</span><span class="p">):</span>
        <span class="c1"># The algorithm first does a coarse filtering, to check if the candidate</span>
        <span class="c1"># pairs both crosses each others plane. For those pairs that passes</span>
        <span class="c1"># this test, we next compute the intersection points, and check if</span>
        <span class="c1"># they are contained within the fractures.</span>

        <span class="c1"># The main fracture, from the first row in pairs</span>
        <span class="n">main</span> <span class="o">=</span> <span class="n">line_ind</span>

        <span class="c1"># Find the other fracture of all pairs starting with the main one</span>
        <span class="n">hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">main</span><span class="p">)</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">hit</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Center point and normal vector of the main fracture</span>
        <span class="n">main_center</span> <span class="o">=</span> <span class="n">center</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">main</span><span class="p">])</span>
        <span class="n">main_normal</span> <span class="o">=</span> <span class="n">polygon_normals</span><span class="p">[</span><span class="n">main</span><span class="p">]</span>

        <span class="c1"># Create an expanded version of the main points, so that the start</span>
        <span class="c1"># and end points are the same. Thus the segments can be formed by</span>
        <span class="c1"># merging main_p_expanded[:-1] with main_p_expanded[1:]</span>
        <span class="n">num_main</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ind_main_cyclic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_main</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">num_main</span>
        <span class="n">main_p_expanded</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[</span><span class="n">main</span><span class="p">][:,</span> <span class="n">ind_main_cyclic</span><span class="p">]</span>

        <span class="c1"># Declare types for the seg_vert information. The data structure is somewhat</span>
        <span class="c1"># awkward, but it is what it is.</span>
        <span class="n">seg_vert_main_0</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span>
        <span class="n">seg_vert_main_1</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span>
        <span class="n">seg_vert_other_0</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span>
        <span class="n">seg_vert_other_1</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span>

        <span class="c1"># Loop over the other polygon in the pairs, look for intersections</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
            <span class="c1"># Expanded version of the other polygon</span>
            <span class="n">num_other</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ind_other_cyclic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_other</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">num_other</span>
            <span class="n">other_p_expanded</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[</span><span class="n">o</span><span class="p">][:,</span> <span class="n">ind_other_cyclic</span><span class="p">]</span>

            <span class="c1"># Normal vector and cetner of the other polygon</span>
            <span class="n">other_normal</span> <span class="o">=</span> <span class="n">polygon_normals</span><span class="p">[</span><span class="n">o</span><span class="p">]</span>
            <span class="n">other_center</span> <span class="o">=</span> <span class="n">center</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">o</span><span class="p">])</span>

            <span class="c1"># Point a vector from the main center to the vertexes of the</span>
            <span class="c1"># other polygon. Then take the dot product with the normal vector</span>
            <span class="c1"># of the main fracture. If all dot products have the same sign,</span>
            <span class="c1"># the other fracture does not cross the plane of the main polygon.</span>
            <span class="c1"># Note that we use mod_sign to safeguard the computation - if</span>
            <span class="c1"># the vertexes are close, we will take a closer look at the combination</span>
            <span class="n">vec_from_main</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span>
                <span class="n">vector_pointset_point</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">main</span><span class="p">],</span> <span class="n">other_p_expanded</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">dot_prod_from_main</span> <span class="o">=</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">main_normal</span> <span class="o">*</span> <span class="n">vec_from_main</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

            <span class="c1"># Similar procedure: Vector from ohter center to the main polygon,</span>
            <span class="c1"># then dot product.</span>
            <span class="n">vec_from_other</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">vector_pointset_point</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">o</span><span class="p">],</span> <span class="n">main_p_expanded</span><span class="p">))</span>
            <span class="n">dot_prod_from_other</span> <span class="o">=</span> <span class="n">mod_sign</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">other_normal</span> <span class="o">*</span> <span class="n">vec_from_other</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># If one of the polygons lie completely on one side of the other,</span>
            <span class="c1"># there can be no intersection.</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dot_prod_from_main</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dot_prod_from_main</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dot_prod_from_other</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dot_prod_from_other</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># At this stage, we are fairly sure both polygons cross the plane of</span>
            <span class="c1"># the other polygon.</span>
            <span class="c1"># Identify the segments where the polygon crosses the plane</span>
            <span class="n">sign_change_main</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dot_prod_from_main</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sign_change_other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dot_prod_from_other</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># The default option is that the intersection is not on the boundary</span>
            <span class="c1"># of main or other, that is, the two intersection points are identical</span>
            <span class="c1"># to two vertexes of the polygon</span>
            <span class="n">isect_on_boundary_main</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">isect_on_boundary_other</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># We know that the polygons at least are very close to intersecting each-</span>
            <span class="c1"># others planes. There are four options, differing in whether the vertexes</span>
            <span class="c1"># are in the plane of the other polygon or not:</span>
            <span class="c1">#   1) The polygon has no vertex in the other plane. Intersection is found</span>
            <span class="c1">#      by computing intersection between polygon segments and the other</span>
            <span class="c1">#      plane.</span>
            <span class="c1">#   2) The polygon has one vertex in the other plane. This is one intersection</span>
            <span class="c1">#      point. The other one should be on a segment, that is, the polygon</span>
            <span class="c1">#      should have points on both sides of the plane.</span>
            <span class="c1">#   3) The polygon has two vertexes in the other plane. These will be the</span>
            <span class="c1">#      intersection points. The remaining vertexes should be on the same</span>
            <span class="c1">#      side of the plane.</span>
            <span class="c1">#   4) All vertexes lie in the plane. The intersection points will be found</span>
            <span class="c1">#      by what is essentially a 2d algorithm. Note that the current</span>
            <span class="c1">#      implementation if this case is a bit rudimentary.</span>
            <span class="c1">#</span>
            <span class="c1"># NOTE: This part of the code only considers intersection between polygon</span>
            <span class="c1"># and plane. The analysis whether the intersection points are within</span>
            <span class="c1"># each polygon is done below.</span>
            <span class="c1">#</span>
            <span class="c1"># We first compute the intersection of the other polygon with the plane of</span>
            <span class="c1"># the main one. The reverse operation is found below.</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dot_prod_from_main</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c1"># In the case where one polygon does not have a vertex in the plane of</span>
                <span class="c1"># the other polygon, there should be exactly two segments crossing the plane.</span>
                <span class="k">assert</span> <span class="n">sign_change_main</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="c1"># Compute the intersection points between the segments of the other polygon</span>
                <span class="c1"># and the plane of the main polygon.</span>
                <span class="n">other_intersects_main_0</span> <span class="o">=</span> <span class="n">intersection</span><span class="p">(</span>
                    <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_main</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_main</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">main_normal</span><span class="p">,</span>
                    <span class="n">main_center</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">other_intersects_main_1</span> <span class="o">=</span> <span class="n">intersection</span><span class="p">(</span>
                    <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_main</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                    <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_main</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">main_normal</span><span class="p">,</span>
                    <span class="n">main_center</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># First indices, next is whether this refers to segment. False means vertex.</span>
                <span class="n">seg_vert_other_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">sign_change_main</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">seg_vert_other_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">sign_change_main</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dot_prod_from_main</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># The first and last element represent the same point, thus include</span>
                <span class="c1"># only one of them when counting the number of points in the plane</span>
                <span class="c1"># of the other fracture.</span>
                <span class="n">hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dot_prod_from_main</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">other_intersects_main_0</span> <span class="o">=</span> <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">sign_change_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dot_prod_from_main</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">sign_change_full</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># This corresponds to a point contact between one polygon and the</span>
                    <span class="c1"># other (at least other plane, perhaps also other polygon)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">include_point_contact</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Point of the intersection - known to be on o.</span>
                    <span class="n">tmp_p</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[</span><span class="n">o</span><span class="p">][:,</span> <span class="n">hit</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

                    <span class="c1"># Check whether the point is inside, or on the boundary, of outside.</span>
                    <span class="c1"># in_or_on is 0 for outside, 1 for on boundary, 2 for internal.</span>
                    <span class="c1"># If the contact is on an index of other, vert_ind_on_other gives</span>
                    <span class="c1"># the index of this vertex, if not, it is False.</span>
                    <span class="n">in_or_on</span><span class="p">,</span> <span class="n">vert_ind_on_main</span> <span class="o">=</span> <span class="n">_point_in_or_on_polygon</span><span class="p">(</span>
                        <span class="n">tmp_p</span><span class="p">,</span> <span class="n">polys</span><span class="p">[</span><span class="n">main</span><span class="p">],</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="n">in_or_on</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># The intersection is between the polygons proper.</span>
                        <span class="c1"># Store point, assign it to both polygons.</span>
                        <span class="n">new_pt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp_p</span><span class="p">)</span>
                        <span class="n">isect_pt</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                        <span class="n">isect_pt</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                        <span class="n">polygon_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">main</span><span class="p">,</span> <span class="n">o</span><span class="p">))</span>
                        <span class="n">new_pt_ind</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="c1"># This is certainly a point on the boundary on main.</span>
                        <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

                        <span class="c1"># Store index of the point contact vertex for main.</span>
                        <span class="n">is_point_contact</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                        <span class="c1"># Store vertex information for other.</span>
                        <span class="n">is_point_contact</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">])</span>

                        <span class="c1"># Store boundary information on other.</span>
                        <span class="k">if</span> <span class="n">in_or_on</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">vert_ind_on_main</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="c1"># This is a segment, but not a vertex intersection</span>
                                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">[</span><span class="n">vert_ind_on_main</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">]</span>
                                <span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># Intersection is on vertex of other as well</span>
                                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">[</span><span class="n">vert_ind_on_main</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">False</span><span class="p">]</span>
                                <span class="p">)</span>
                            <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                            <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

                    <span class="c1"># if in_or_or is 0, the intersection is external, and we do nothing.</span>
                    <span class="c1"># There is no need to do further processing of the combination of</span>
                    <span class="c1"># main and o.</span>
                    <span class="k">continue</span>

                <span class="n">other_intersects_main_1</span> <span class="o">=</span> <span class="n">intersection</span><span class="p">(</span>
                    <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_full</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_full</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">main_normal</span><span class="p">,</span>
                    <span class="n">main_center</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">seg_vert_other_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">seg_vert_other_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">sign_change_full</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dot_prod_from_main</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c1"># The two polygons lie in the same plane. The intersection points will</span>
                <span class="c1"># be found on the segments of the polygons</span>
                <span class="n">isect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="c1"># Loop over both set of polygon segments, look for intersections</span>
                <span class="k">for</span> <span class="n">sm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="c1"># Store the intersection points found for this segment of the main</span>
                    <span class="c1"># polygon. If there are more than one, we know that the intersection</span>
                    <span class="c1"># is on the boundary of that polygon.</span>
                    <span class="n">tmp_isect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">so</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">loc_isect</span> <span class="o">=</span> <span class="n">segments_3d</span><span class="p">(</span>
                            <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sm</span><span class="p">],</span>
                            <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sm</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                            <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">so</span><span class="p">],</span>
                            <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">so</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">loc_isect</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">isect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">isect</span><span class="p">,</span> <span class="n">loc_isect</span><span class="p">))</span>
                            <span class="n">tmp_isect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">tmp_isect</span><span class="p">,</span> <span class="n">loc_isect</span><span class="p">))</span>

                    <span class="c1"># Uniquify the intersection points found on this segment of main.</span>
                    <span class="c1"># If more than one, the intersection is on the boundary of main.</span>
                    <span class="n">tmp_unique_isect</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">setmembership</span><span class="o">.</span><span class="n">uniquify_point_set</span><span class="p">(</span>
                        <span class="n">tmp_isect</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">tmp_unique_isect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">isect_on_boundary_main</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="n">isect</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">setmembership</span><span class="o">.</span><span class="n">uniquify_point_set</span><span class="p">(</span><span class="n">isect</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">isect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># The polygons share a plane, but no intersections</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">isect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">include_point_contact</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Register point</span>
                    <span class="n">new_pt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>
                    <span class="n">isect_pt</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">isect_pt</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">polygon_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">main</span><span class="p">,</span> <span class="n">o</span><span class="p">))</span>
                    <span class="n">new_pt_ind</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="c1"># This is certainly a point on the boundary on both</span>
                    <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="c1"># Store point index information</span>
                    <span class="n">is_point_contact</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">is_point_contact</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

                    <span class="c1"># For each of the polygons, check proximity of intersection first with</span>
                    <span class="c1"># vertexes, next segments.</span>
                    <span class="k">for</span> <span class="n">tmp_ind</span> <span class="ow">in</span> <span class="p">[</span><span class="n">main</span><span class="p">,</span> <span class="n">o</span><span class="p">]:</span>
                        <span class="n">dist_vert</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">point_pointset</span><span class="p">(</span><span class="n">isect</span><span class="p">,</span> <span class="n">polys</span><span class="p">[</span><span class="n">tmp_ind</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">dist_vert</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                            <span class="c1"># This is a point</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">tmp_ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_vert</span><span class="p">),</span> <span class="kc">False</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Point failed, look for closest segment.</span>
                            <span class="n">start</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[</span><span class="n">tmp_ind</span><span class="p">]</span>
                            <span class="n">end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                            <span class="n">dist_seg</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">points_segments</span><span class="p">(</span>
                                <span class="n">isect</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span>
                            <span class="p">)</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">tmp_ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_seg</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="kc">True</span><span class="p">]</span>
                            <span class="p">)</span>
                    <span class="c1"># Intersection information is complete, move on.</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">isect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">other_intersects_main_0</span> <span class="o">=</span> <span class="n">isect</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">other_intersects_main_1</span> <span class="o">=</span> <span class="n">isect</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There should be at most two intersections&quot;</span><span class="p">)</span>

                <span class="n">seg_vert_other_0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;not implemented for shared planes&quot;</span><span class="p">)</span>
                <span class="n">seg_vert_other_1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;not implemented for shared planes&quot;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Both of the intersection points are vertexes.</span>
                <span class="c1"># Check that there are only two points - if this assertion fails,</span>
                <span class="c1"># there is a hanging node of the other polygon, which is in the</span>
                <span class="c1"># plane of the other polygon. Extending to cover this case should</span>
                <span class="c1"># be possible, but further treatment is unclear at the moment.</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dot_prod_from_main</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="n">hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dot_prod_from_main</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">other_intersects_main_0</span> <span class="o">=</span> <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="c1"># Pick the last of the intersection points. This is valid also for</span>
                <span class="c1"># multiple (&gt;2) intersection points, but we keep the assertion for now.</span>
                <span class="n">other_intersects_main_1</span> <span class="o">=</span> <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">hit</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

                <span class="n">seg_vert_other_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">seg_vert_other_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">hit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>

                <span class="c1"># The other polygon has an edge laying in the plane of the main polygon.</span>
                <span class="c1"># This will be registered as a boundary intersection, but only if</span>
                <span class="c1"># the polygons (not only plane) intersect.</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">hit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="ow">or</span> <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="ow">and</span> <span class="n">hit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">dot_prod_from_main</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">isect_on_boundary_other</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Next, analyze intersection between main polygon and the plane of the other</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dot_prod_from_other</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c1"># In the case where one polygon does not have a vertex in the plane of</span>
                <span class="c1"># the other polygon, there should be exactly two segments crossing the plane.</span>
                <span class="k">assert</span> <span class="n">sign_change_other</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="c1"># Compute the intersection points between the segments of the main polygon</span>
                <span class="c1"># and the plane of the other polygon.</span>
                <span class="n">main_intersects_other_0</span> <span class="o">=</span> <span class="n">intersection</span><span class="p">(</span>
                    <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_other</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">other_normal</span><span class="p">,</span>
                    <span class="n">other_center</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">main_intersects_other_1</span> <span class="o">=</span> <span class="n">intersection</span><span class="p">(</span>
                    <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_other</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                    <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_other</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">other_normal</span><span class="p">,</span>
                    <span class="n">other_center</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">seg_vert_main_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">sign_change_other</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">seg_vert_main_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">sign_change_other</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dot_prod_from_other</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># The first and last element represent the same point, thus include</span>
                <span class="c1"># only one of them when counting the number of points in the plane</span>
                <span class="c1"># of the other fracture.</span>
                <span class="n">hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dot_prod_from_other</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">main_intersects_other_0</span> <span class="o">=</span> <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">sign_change_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dot_prod_from_other</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">sign_change_full</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># This corresponds to a point contact between one polygon and the</span>
                    <span class="c1"># other (at least other plane, perhaps also other polygon)</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">include_point_contact</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Point of the intersection - known to be on main.</span>
                    <span class="n">tmp_p</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[</span><span class="n">main</span><span class="p">][:,</span> <span class="n">hit</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

                    <span class="c1"># Check whether the point is inside, or on the boundary, of outside.</span>
                    <span class="c1"># in_or_on is 0 for outside, 1 for on boundary, 2 for internal.</span>
                    <span class="c1"># If the contact is on an index of other, vert_ind_on_other gives</span>
                    <span class="c1"># the index of this vertex, if not, it is False.</span>
                    <span class="n">in_or_on</span><span class="p">,</span> <span class="n">vert_ind_on_other</span> <span class="o">=</span> <span class="n">_point_in_or_on_polygon</span><span class="p">(</span>
                        <span class="n">tmp_p</span><span class="p">,</span> <span class="n">polys</span><span class="p">[</span><span class="n">o</span><span class="p">],</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="n">in_or_on</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># The intersection is between the polygons proper.</span>
                        <span class="c1"># Store point, assign it to both polygons.</span>
                        <span class="n">new_pt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp_p</span><span class="p">)</span>
                        <span class="n">isect_pt</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                        <span class="n">isect_pt</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                        <span class="n">polygon_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">main</span><span class="p">,</span> <span class="n">o</span><span class="p">))</span>
                        <span class="n">new_pt_ind</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="c1"># This is certainly a point on the boundary on main.</span>
                        <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

                        <span class="c1"># Store index of the point contact vertex for main.</span>
                        <span class="n">is_point_contact</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                        <span class="c1"># Store vertex information for other.</span>
                        <span class="n">is_point_contact</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">])</span>

                        <span class="c1"># Store boundary information on other.</span>
                        <span class="k">if</span> <span class="n">in_or_on</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">vert_ind_on_other</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="c1"># This is a segment, but not a vertex intersection</span>
                                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">[</span><span class="n">vert_ind_on_other</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">]</span>
                                <span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># Intersection is on vertex of other as well</span>
                                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="p">[</span><span class="n">vert_ind_on_other</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">False</span><span class="p">]</span>
                                <span class="p">)</span>
                            <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                            <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

                    <span class="c1"># if in_or_or is 0, the intersection is external, and we do nothing.</span>
                    <span class="c1"># There is no need to do further processing of the combination of</span>
                    <span class="c1"># main and o.</span>
                    <span class="k">continue</span>

                <span class="n">main_intersects_other_1</span> <span class="o">=</span> <span class="n">intersection</span><span class="p">(</span>
                    <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_full</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sign_change_full</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">other_normal</span><span class="p">,</span>
                    <span class="n">other_center</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">seg_vert_main_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">seg_vert_main_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">sign_change_full</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dot_prod_from_other</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>

                <span class="n">isect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">so</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">tmp_isect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">sm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">loc_isect</span> <span class="o">=</span> <span class="n">segments_3d</span><span class="p">(</span>
                            <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sm</span><span class="p">],</span>
                            <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">sm</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                            <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">so</span><span class="p">],</span>
                            <span class="n">other_p_expanded</span><span class="p">[:,</span> <span class="n">so</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">loc_isect</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">isect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">isect</span><span class="p">,</span> <span class="n">loc_isect</span><span class="p">))</span>
                            <span class="n">tmp_isect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">tmp_isect</span><span class="p">,</span> <span class="n">loc_isect</span><span class="p">))</span>

                    <span class="n">tmp_unique_isect</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">setmembership</span><span class="o">.</span><span class="n">uniquify_point_set</span><span class="p">(</span>
                        <span class="n">tmp_isect</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="n">tmp_unique_isect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">isect_on_boundary_other</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="n">isect</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">setmembership</span><span class="o">.</span><span class="n">uniquify_point_set</span><span class="p">(</span><span class="n">isect</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>

                <span class="n">seg_vert_main_0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;not implemented for shared planes&quot;</span><span class="p">)</span>
                <span class="n">seg_vert_main_1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;not implemented for shared planes&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">isect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># The polygons share a plane, but no intersections</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">isect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Point contact. Must be on the boundary of both, but not clear whether</span>
                    <span class="c1"># it is on vertex of both (must be at least on one).</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">include_point_contact</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Register point</span>
                    <span class="n">new_pt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>
                    <span class="n">isect_pt</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">isect_pt</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">polygon_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">main</span><span class="p">,</span> <span class="n">o</span><span class="p">))</span>
                    <span class="n">new_pt_ind</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="c1"># This is certainly a point on the boundary on both</span>
                    <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="c1"># Store point index information</span>
                    <span class="n">is_point_contact</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">is_point_contact</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

                    <span class="c1"># For each of the polygons, check proximity of intersection first with</span>
                    <span class="c1"># vertexes, next segments.</span>
                    <span class="k">for</span> <span class="n">tmp_ind</span> <span class="ow">in</span> <span class="p">[</span><span class="n">main</span><span class="p">,</span> <span class="n">o</span><span class="p">]:</span>
                        <span class="n">dist_vert</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">point_pointset</span><span class="p">(</span><span class="n">isect</span><span class="p">,</span> <span class="n">polys</span><span class="p">[</span><span class="n">tmp_ind</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">dist_vert</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                            <span class="c1"># This is a point</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">tmp_ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_vert</span><span class="p">),</span> <span class="kc">True</span><span class="p">]</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Point failed, look for closest segment.</span>
                            <span class="n">start</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[</span><span class="n">tmp_ind</span><span class="p">]</span>
                            <span class="n">end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                            <span class="n">dist_seg</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">points_segments</span><span class="p">(</span>
                                <span class="n">isect</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span>
                            <span class="p">)</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">tmp_ind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_seg</span><span class="p">),</span> <span class="kc">False</span><span class="p">]</span>
                            <span class="p">)</span>

                    <span class="c1"># Intersection information is complete, move on.</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">isect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">main_intersects_other_0</span> <span class="o">=</span> <span class="n">isect</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">main_intersects_other_1</span> <span class="o">=</span> <span class="n">isect</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There should be at most two intersections&quot;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Both of the intersection points are vertexes.</span>
                <span class="c1"># Check that there are only two points - if this assertion fails,</span>
                <span class="c1"># there is a hanging node of the main polygon, which is in the</span>
                <span class="c1"># plane of the other polygon. Extending to cover this case should</span>
                <span class="c1"># be possible, but further treatment is unclear at the moment.</span>
                <span class="c1"># Do not count the last point here, this is identical to the</span>
                <span class="c1"># first one.</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dot_prod_from_other</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="n">hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dot_prod_from_other</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">main_intersects_other_0</span> <span class="o">=</span> <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="c1"># Pick the last of the intersection points. This is valid also for</span>
                <span class="c1"># multiple (&gt;2) intersection points, but we keep the assertion for now.</span>
                <span class="n">main_intersects_other_1</span> <span class="o">=</span> <span class="n">main_p_expanded</span><span class="p">[:,</span> <span class="n">hit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

                <span class="n">seg_vert_main_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">seg_vert_main_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">hit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>

                <span class="c1"># The main polygon has an edge laying in the plane of the other polygon.</span>
                <span class="c1"># If the two intersection points form a segment</span>
                <span class="c1"># This will be registered as a boundary intersection, but only if</span>
                <span class="c1"># the polygons (not only plane) intersect.</span>
                <span class="c1"># The two points can either be one apart in the main polygon,</span>
                <span class="c1"># or it can be the first and the penultimate point</span>
                <span class="c1"># (in the latter case, the final point, which is identical to the</span>
                <span class="c1"># first one, will also be in the plane, but this is disregarded</span>
                <span class="c1"># by the [:-1] above)</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">hit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="ow">or</span> <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="ow">and</span> <span class="n">hit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">dot_prod_from_other</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">isect_on_boundary_main</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1">###</span>
            <span class="c1"># We now have the intersections between polygons and planes.</span>
            <span class="c1"># To finalize the computation, we need to sort out how the intersection</span>
            <span class="c1"># points are located relative to each other. Only if there is an overlap</span>
            <span class="c1"># between the intersection points of the main and the other polygon</span>
            <span class="c1"># is there a real intersection (contained within the polygons, not only)</span>
            <span class="c1"># in their planes, but outside the features themselves.</span>

            <span class="c1"># Vectors from the intersection points in the main fracture to the</span>
            <span class="c1"># intersection point in the other fracture</span>
            <span class="n">main_0_other_0</span> <span class="o">=</span> <span class="n">other_intersects_main_0</span> <span class="o">-</span> <span class="n">main_intersects_other_0</span>
            <span class="n">main_0_other_1</span> <span class="o">=</span> <span class="n">other_intersects_main_1</span> <span class="o">-</span> <span class="n">main_intersects_other_0</span>
            <span class="n">main_1_other_0</span> <span class="o">=</span> <span class="n">other_intersects_main_0</span> <span class="o">-</span> <span class="n">main_intersects_other_1</span>
            <span class="n">main_1_other_1</span> <span class="o">=</span> <span class="n">other_intersects_main_1</span> <span class="o">-</span> <span class="n">main_intersects_other_1</span>

            <span class="c1"># e_1 is positive if both points of the other fracture lie on the same side of the</span>
            <span class="c1"># first intersection point of the main one</span>
            <span class="c1"># e_1 negative means the first intersection point of main with the plane of</span>
            <span class="c1"># the others is surrounded by the intersection points of the other polygon</span>
            <span class="c1"># with the main plane.</span>
            <span class="c1"># Use a mod_sign here to avoid issues related to rounding errors</span>
            <span class="n">e_1</span> <span class="o">=</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">main_0_other_0</span> <span class="o">*</span> <span class="n">main_0_other_1</span><span class="p">))</span>
            <span class="c1"># e_2 is positive if both points of the other fracture lie on the same side of the</span>
            <span class="c1"># second intersection point of the main one</span>
            <span class="n">e_2</span> <span class="o">=</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">main_1_other_0</span> <span class="o">*</span> <span class="n">main_1_other_1</span><span class="p">))</span>
            <span class="c1"># e_3 is positive if both points of the main fracture lie on the same side of the</span>
            <span class="c1"># first intersection point of the other one</span>
            <span class="n">e_3</span> <span class="o">=</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="o">-</span><span class="n">main_0_other_0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">main_1_other_0</span><span class="p">)))</span>
            <span class="c1"># e_4 is positive if both points of the main fracture lie on the same side of the</span>
            <span class="c1"># second intersection point of the other one</span>
            <span class="n">e_4</span> <span class="o">=</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="o">-</span><span class="n">main_0_other_1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">main_1_other_1</span><span class="p">)))</span>

            <span class="c1"># This is in essence an implementation of the flow chart in Figure 9 in Dong et al,</span>
            <span class="c1"># However the inequality signs are changed a bit to make the logic clearer</span>
            <span class="k">if</span> <span class="n">e_1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">e_2</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">e_3</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">e_4</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># The intersection points for the two fractures are separated.</span>
                <span class="c1"># There is no intersection</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">sum</span><span class="p">([</span><span class="n">e_1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e_2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="nb">sum</span><span class="p">([</span><span class="n">e_1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e_2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="nb">sum</span><span class="p">([</span><span class="n">e_3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e_4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="nb">sum</span><span class="p">([</span><span class="n">e_3</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e_4</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="p">):</span>
                <span class="c1"># Contact in a single point</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">e_1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># The first point on the main fracture is at most marginally involved in</span>
                <span class="c1"># the intersection (if e_1 == 0, two segments intersect)</span>
                <span class="k">if</span> <span class="n">e_2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># The second point on the main fracture is at most marginally involved</span>
                    <span class="c1"># We know that e_3 and e_4 are non-positive (positive is covered above</span>
                    <span class="c1"># and a combination is not possible)</span>

                    <span class="c1"># The intersection points are defined by the intersection of other</span>
                    <span class="c1"># with the plane of main</span>
                    <span class="n">isect_pt_loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">other_intersects_main_0</span><span class="p">,</span> <span class="n">other_intersects_main_1</span><span class="p">]</span>

                    <span class="c1"># Next, we need to classify the intersection types (segments or not)</span>
                    <span class="c1"># For the other polygon, we know both intersections are on the</span>
                    <span class="c1"># segments</span>
                    <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_other_0</span><span class="p">)</span>
                    <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_other_1</span><span class="p">)</span>

                    <span class="c1"># For the main segment, the intersection most likely hits in the</span>
                    <span class="c1"># interior, however, there is still the chance that the intersection</span>
                    <span class="c1"># is on the segment (if e_1 == 0 and / or e__2 == 0)</span>

                    <span class="c1"># Check if the first intersection point is on the boundary of main</span>
                    <span class="k">if</span> <span class="n">e_3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># e_3 = main_0_other_0.dot(main_1_other_0) == 0</span>
                        <span class="c1"># We know all of e_i are parallel, thus orthogonality is not</span>
                        <span class="c1"># an option. Thus, at least of the components of e_3 is 0.</span>

                        <span class="c1"># main_0_other_0 is involved in e_1, check if this is zero</span>
                        <span class="k">if</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">main_0_other_0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># other_intersects_main_0 == main_intersects_other_0</span>
                            <span class="c1"># The first intersection point, seen from main, should have</span>
                            <span class="c1"># seg_vert info 0.</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_0</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># other_intersects_main_0 == main_intersects_other_1</span>
                            <span class="c1"># The first intersection point, seen from main, should have</span>
                            <span class="c1"># seg_vert info 1.</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">isect_on_boundary_main</span><span class="p">:</span>
                            <span class="c1"># The first intersection coincides with a segment of main</span>
                            <span class="n">ind</span> <span class="o">=</span> <span class="n">seg_vert_main_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ind</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># The first intersection is in the interior of main</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

                    <span class="c1"># Next, treat the second intersection point</span>
                    <span class="c1"># Check if other_intersects_main_1 equalls either</span>
                    <span class="c1"># main_intersects_other_0 or main_intersects_other_1</span>
                    <span class="k">if</span> <span class="n">e_4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># e_4 = main_0_other_1.dot(main_1_other_1) == 0</span>
                        <span class="k">if</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">main_1_other_1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># other_intersects_main_1 == main_intersects_other_0</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_1</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># other_intersects_main_1 == main_intersects_other_1</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_0</span><span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">isect_on_boundary_main</span><span class="p">:</span>
                            <span class="n">ind</span> <span class="o">=</span> <span class="n">seg_vert_main_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="n">num_main</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">seg_vert_main_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                                <span class="n">ind</span> <span class="o">-=</span> <span class="mi">1</span>

                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ind</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

                <span class="k">else</span><span class="p">:</span>  <span class="c1"># e_2 &lt; 0</span>
                    <span class="c1"># The second point on the main fracture is surrounded by points on</span>
                    <span class="c1"># the other fracture. One of them will in turn be surrounded by the</span>
                    <span class="c1"># points on the main fracture, this is the intersecting one.</span>
                    <span class="k">if</span> <span class="n">e_3</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Intersection consists of second point from main, then first</span>
                        <span class="c1"># from other</span>
                        <span class="n">isect_pt_loc</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">main_intersects_other_1</span><span class="p">,</span>
                            <span class="n">other_intersects_main_0</span><span class="p">,</span>
                        <span class="p">]</span>

                        <span class="c1"># seg-vert information for the first point is simple for main</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_1</span><span class="p">)</span>

                        <span class="c1"># Second point for main is more difficult</span>
                        <span class="k">if</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">main_0_other_0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># e_1 == 0 gives main_intersects_other_0 equals either</span>
                            <span class="c1">#  other_intersects_main_0 or other_intersects_main_1</span>
                            <span class="c1"># e_3 == 0 confirms</span>
                            <span class="c1">#  main_intersects_other_0 == other_intersects_main_0</span>
                            <span class="c1"># (otherwise e_2 would also have been zero)</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_0</span><span class="p">)</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">isect_on_boundary_main</span><span class="p">:</span>
                                <span class="c1"># No intersection for the first point of main</span>
                                <span class="n">ind</span> <span class="o">=</span> <span class="n">seg_vert_main_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ind</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

                        <span class="c1"># seg-vert information for first point, seen from other</span>
                        <span class="c1"># We know that e_2 &lt; 0, thus main_intersects_other_1 cannot</span>
                        <span class="c1"># equal other_intersects_main_0 or other_intersects_main_1</span>
                        <span class="k">if</span> <span class="n">e_4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_other_1</span><span class="p">)</span>
                            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;this should not happen&quot;</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">isect_on_boundary_other</span><span class="p">:</span>
                                <span class="n">ind</span> <span class="o">=</span> <span class="n">seg_vert_other_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                                    <span class="n">ind</span> <span class="o">==</span> <span class="n">num_other</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">seg_vert_other_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                                <span class="p">):</span>
                                    <span class="n">ind</span> <span class="o">-=</span> <span class="mi">1</span>
                                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ind</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

                        <span class="c1"># seg-vert information for the second point is simple for other</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_other_0</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">e_4</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">isect_pt_loc</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">main_intersects_other_1</span><span class="p">,</span>
                            <span class="n">other_intersects_main_1</span><span class="p">,</span>
                        <span class="p">]</span>
                        <span class="c1"># seg-vert information for the first point is simple for main</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_1</span><span class="p">)</span>

                        <span class="c1"># For the second point, we need to check if</span>
                        <span class="c1">#  other_intersects_main_1 == main_intersects_other_0</span>
                        <span class="c1"># this will imply</span>
                        <span class="k">if</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">main_0_other_1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># The first point on the main fracture barely hits the other</span>
                            <span class="c1"># fracture</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_0</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># No intersection for the first point of main</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

                        <span class="c1"># Check if main_intersects_other_1 == other_intersects_main_0</span>
                        <span class="k">if</span> <span class="n">e_3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;this should not happen for e_2 &lt; 0&quot;</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_other_0</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

                        <span class="c1"># seg-vert information for the second point is simple for other</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_other_1</span><span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># We may eventually end up here for overlapping fractures</span>
                        <span class="k">assert</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">e_2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Since e_1 is known to be negative, we know that main_intersects_other</span>
                <span class="c1"># is one intersection point.</span>
                <span class="k">if</span> <span class="n">e_1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Equality is covered above</span>
                    <span class="c1"># The first point on the main fracture is surrounded by points on</span>
                    <span class="c1"># the other fracture. One of them will in turn be surrounded by the</span>
                    <span class="c1"># points on the main fracture, this is the intersecting one.</span>
                    <span class="k">if</span> <span class="n">e_3</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">isect_pt_loc</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">main_intersects_other_0</span><span class="p">,</span>
                            <span class="n">other_intersects_main_0</span><span class="p">,</span>
                        <span class="p">]</span>
                        <span class="c1"># seg-vert information for the first point is simple for main</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">e_3</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># The second intersection point is interior to main</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                        <span class="k">else</span><span class="p">:</span>  <span class="c1"># On the boundary of main</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_1</span><span class="p">)</span>

                        <span class="c1"># For other, the first intersection point is known to be</span>
                        <span class="c1"># interior, or else e_1 would have been 0</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_other_0</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">e_4</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">isect_pt_loc</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">main_intersects_other_0</span><span class="p">,</span>
                            <span class="n">other_intersects_main_1</span><span class="p">,</span>
                        <span class="p">]</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">mod_sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">main_1_other_1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_1</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_other_1</span><span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># We may eventually end up here for overlapping fractures</span>
                        <span class="k">assert</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">e_1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">e_2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># The points in on the main fracture are the intersection points</span>
                <span class="n">isect_pt_loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">main_intersects_other_0</span><span class="p">,</span> <span class="n">main_intersects_other_1</span><span class="p">]</span>
                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_0</span><span class="p">)</span>
                <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_vert_main_1</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">isect_on_boundary_other</span><span class="p">:</span>
                    <span class="n">ind_0</span> <span class="o">=</span> <span class="n">seg_vert_other_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">ind_1</span> <span class="o">=</span> <span class="n">seg_vert_other_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ind_0</span> <span class="o">-</span> <span class="n">ind_1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">ind_0</span><span class="p">,</span> <span class="n">ind_1</span><span class="p">),</span> <span class="kc">True</span><span class="p">))</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">ind_0</span><span class="p">,</span> <span class="n">ind_1</span><span class="p">),</span> <span class="kc">True</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">num_other</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
                        <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">num_other</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                    <span class="n">segment_vertex_intersection</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This should never happen</span>
                <span class="k">assert</span> <span class="kc">False</span>

            <span class="c1"># Append data for this combination of polygons.</span>
            <span class="n">new_pt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">isect_pt_loc</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">num_new</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">isect_pt_loc</span><span class="p">)</span>
            <span class="n">isect_pt</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_new</span><span class="p">))</span>
            <span class="n">isect_pt</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pt_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_new</span><span class="p">))</span>
            <span class="n">new_pt_ind</span> <span class="o">+=</span> <span class="n">num_new</span>
            <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">main</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isect_on_boundary_main</span><span class="p">)</span>
            <span class="n">is_bound_isect</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isect_on_boundary_other</span><span class="p">)</span>
            <span class="n">polygon_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">main</span><span class="p">,</span> <span class="n">o</span><span class="p">))</span>

            <span class="n">is_point_contact</span><span class="p">[</span><span class="n">main</span><span class="p">]</span> <span class="o">+=</span> <span class="n">num_new</span> <span class="o">*</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>
            <span class="n">is_point_contact</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">+=</span> <span class="n">num_new</span> <span class="o">*</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>

    <span class="c1"># Cleanup and return. Puh!</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_pt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_pt</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">isect_pt</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">isect_pt</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">isect_pt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">isect_pt</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">isect_pt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">isect_pt</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">isect_pt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">new_points</span><span class="p">,</span>
        <span class="n">isect_pt</span><span class="p">,</span>
        <span class="n">is_bound_isect</span><span class="p">,</span>
        <span class="n">polygon_pairs</span><span class="p">,</span>
        <span class="n">segment_vertex_intersection</span><span class="p">,</span>
        <span class="n">is_point_contact</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="segments_polygon"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.geometry.intersections.html#porepy.geometry.intersections.segments_polygon">[docs]</a><span class="k">def</span> <span class="nf">segments_polygon</span><span class="p">(</span>
    <span class="n">start</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">poly</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Compute the internal intersection from line segments to a polygon in 3d.</span>
<span class="sd">    Intersections with the boundary of the polygon are not computed.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        start (np.ndarray, nd x num_segments): One endpoint of segments</span>
<span class="sd">        end (np.ndarray, nd x num_segments): Other endpoint of segments</span>
<span class="sd">        poly (np.ndarray, nd x n_vert): Vertexes of polygon.</span>
<span class="sd">        tol (optional): Tolerance for the geometric computations.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray, bool: Identify if a segment has intersection with the polygon</span>
<span class="sd">            useful to filter the second return parameter.</span>
<span class="sd">        np.ndarray, nd x num_segments: Intersection point.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Reshape if only one point is given</span>
    <span class="k">if</span> <span class="n">start</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">end</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">num_p</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nd</span><span class="p">,</span> <span class="n">num_p</span><span class="p">))</span>

    <span class="c1"># First translate the points so that the first plane is located at the origin</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">poly</span> <span class="o">=</span> <span class="n">poly</span> <span class="o">-</span> <span class="n">center</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">center</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">center</span>

    <span class="c1"># Obtain the rotation matrix that projects p1 to the xy-plane</span>
    <span class="n">rot_p</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">map_geometry</span><span class="o">.</span><span class="n">project_plane_matrix</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
    <span class="n">irot</span> <span class="o">=</span> <span class="n">rot_p</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">poly_rot</span> <span class="o">=</span> <span class="n">rot_p</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>

    <span class="c1"># Sanity check: The points should lay on a plane</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">poly_rot</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>

    <span class="n">poly_xy</span> <span class="o">=</span> <span class="n">poly_rot</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># Rotate the point set, using the same coordinate system.</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">rot_p</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">rot_p</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>

    <span class="n">dz</span> <span class="o">=</span> <span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">start</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">non_zero_incline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span>

    <span class="c1"># Parametrization along line of intersection point</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">dz</span>

    <span class="c1"># Intersection point for segments with non-zero incline</span>
    <span class="n">t</span><span class="p">[</span><span class="n">non_zero_incline</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">start</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">non_zero_incline</span><span class="p">]</span> <span class="o">/</span> <span class="n">dz</span><span class="p">[</span><span class="n">non_zero_incline</span><span class="p">]</span>
    <span class="c1"># Segments with z=0 along the segment</span>
    <span class="n">zero_along_segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
        <span class="n">non_zero_incline</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">tol</span><span class="p">,</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span>
    <span class="c1"># Check if zero point is inside the polygon</span>
    <span class="n">inside</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">geometry_property_checks</span><span class="o">.</span><span class="n">point_in_polygon</span><span class="p">(</span><span class="n">poly_xy</span><span class="p">,</span> <span class="n">x0</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">crosses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">inside</span><span class="p">,</span> <span class="n">zero_along_segment</span><span class="p">)</span>

    <span class="c1"># Verify that the computed points are in the interior of the associated segments</span>
    <span class="n">dot_product</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,ij-&gt;j&quot;</span><span class="p">,</span> <span class="n">x0</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
    <span class="n">sq_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,ij-&gt;j&quot;</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>

    <span class="n">crosses</span><span class="p">[</span><span class="n">dot_product</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">crosses</span><span class="p">[</span><span class="n">dot_product</span> <span class="o">&gt;</span> <span class="n">sq_length</span> <span class="o">+</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># Rotate back the points</span>
    <span class="n">x0</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">crosses</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cp</span><span class="p">[:,</span> <span class="n">crosses</span><span class="p">]</span> <span class="o">=</span> <span class="n">center</span> <span class="o">+</span> <span class="n">irot</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x0</span><span class="p">[:,</span> <span class="n">crosses</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">crosses</span><span class="p">,</span> <span class="n">cp</span></div>


<div class="viewcode-block" id="segments_polyhedron"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.geometry.intersections.html#porepy.geometry.intersections.segments_polyhedron">[docs]</a><span class="k">def</span> <span class="nf">segments_polyhedron</span><span class="p">(</span>
    <span class="n">start</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">poly</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Compute the intersection from line segments to the interior of a convex polyhedron.</span>
<span class="sd">    Intersections with the boundary of the polyhedron are not computed.</span>

<span class="sd">    There are four possibilities for each segment</span>
<span class="sd">        1 - the segment is completely inside the polyhedron, meaning that its vertices</span>
<span class="sd">            are both inside the polyhedron</span>
<span class="sd">        2 - the segment has only one vertex in the polyhedron</span>
<span class="sd">        3 - the segment is completely outside the polyhedron</span>
<span class="sd">        4 - the segment has in intersection but both vertices are outside the polyhedron.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        start (np.ndarray, nd x num_segments): One endpoint of segments</span>
<span class="sd">        end (np.ndarray, nd x num_segments): Other endpoint of segments</span>
<span class="sd">        poly (np.ndarray, nd x n_vert): Vertexes of polygon organised face by face</span>
<span class="sd">        tol (optional): Tolerance for the geometric computations</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray, num_segment: For each segment intersection points with the polyhedron,</span>
<span class="sd">            start and end points are not included in this list</span>
<span class="sd">        np.ndarray, num_segments: Vector of boolean that indicate if the start of a segment</span>
<span class="sd">            is inside the polyhedron</span>
<span class="sd">        np.ndarray, num_segments: Vector of boolean that indicate if the end of a segment</span>
<span class="sd">            is inside the polyhedron</span>
<span class="sd">        np.ndarray, num_segments: Length percentage of a segment inside the polyhedron</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># For a single point make its shape consistent</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">start</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">end</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Check if the vertices are inside or outside the polyhedron</span>
    <span class="n">is_in_start</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">geometry_property_checks</span><span class="o">.</span><span class="n">point_in_polyhedron</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
    <span class="n">is_in_end</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">geometry_property_checks</span><span class="o">.</span><span class="n">point_in_polyhedron</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

    <span class="c1"># Check how many intersections a segment has with the faces of the polyhedron</span>
    <span class="n">extra_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">start</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">extra_pts</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">poly</span><span class="p">:</span>
        <span class="c1"># the face vertices need to be sorted</span>
        <span class="n">sort_ind</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">sort_points</span><span class="o">.</span><span class="n">sort_point_plane</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="c1"># compute if the current face intersect the segments</span>
        <span class="n">is_inside</span><span class="p">,</span> <span class="n">pts</span> <span class="o">=</span> <span class="n">segments_polygon</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">face</span><span class="p">[:,</span> <span class="n">sort_ind</span><span class="p">],</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">is_inside</span><span class="p">):</span>
            <span class="n">extra_pts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">extra_pts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pts</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]]</span>

    <span class="c1"># Loop on the segments and compute the length in the polyhedron</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">start</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="c1"># The segment is all inside</span>
        <span class="k">if</span> <span class="n">is_in_start</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="ow">and</span> <span class="n">is_in_end</span><span class="p">[</span><span class="n">seg</span><span class="p">]:</span>
            <span class="n">length</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">end</span><span class="p">[:,</span> <span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">start</span><span class="p">[:,</span> <span class="n">seg</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">is_in_start</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="ow">and</span> <span class="n">extra_pts</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">length</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">start</span><span class="p">[:,</span> <span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">extra_pts</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">is_in_end</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="ow">and</span> <span class="n">extra_pts</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">length</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">end</span><span class="p">[:,</span> <span class="n">seg</span><span class="p">]</span> <span class="o">-</span> <span class="n">extra_pts</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">extra_pts</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">length</span><span class="p">[</span><span class="n">seg</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">extra_pts</span><span class="p">[</span><span class="n">seg</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">extra_pts</span><span class="p">[</span><span class="n">seg</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Compute the percentage of segment in the polyhedron</span>
    <span class="n">ratio</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ij,ij-&gt;j&quot;</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">extra_pts</span><span class="p">,</span> <span class="n">is_in_start</span><span class="p">,</span> <span class="n">is_in_end</span><span class="p">,</span> <span class="n">ratio</span></div>


<span class="k">def</span> <span class="nf">_point_in_or_on_polygon</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">poly</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function to get intersection information between a point and a polygon.</span>

<span class="sd">    The polygon is classified as being outside, on the boundary or in the interior of</span>
<span class="sd">    the polygon. If on the boundary, the intersection is further classified according to</span>
<span class="sd">    whether it is on a segment or vertex.</span>

<span class="sd">    Interpretation of return values:</span>
<span class="sd">        First values is an int, 0 for outside, 1 for on boundary, 2 in interior.</span>
<span class="sd">        If the first value is 0 or 2, the second is None.</span>
<span class="sd">        If the first value is 1, the second is a tuple. First item is the segment index</span>
<span class="sd">            in the polygon if intersection is on segment, None if on vertex. Second item</span>
<span class="sd">            is vertex index if intersection on vertex, None if not.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Rotate polygon to its natural plane, also map point.</span>
    <span class="n">cp</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">map_geometry</span><span class="o">.</span><span class="n">project_plane_matrix</span><span class="p">(</span><span class="n">poly</span> <span class="o">-</span> <span class="n">cp</span><span class="p">)</span>
    <span class="n">rot_poly</span> <span class="o">=</span> <span class="n">rot</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">poly</span> <span class="o">-</span> <span class="n">cp</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">rot_p</span> <span class="o">=</span> <span class="n">rot</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">cp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rot_p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
        <span class="c1"># Point not even in the plane of the polygon.</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">pp</span><span class="o">.</span><span class="n">geometry_property_checks</span><span class="o">.</span><span class="n">point_in_polygon</span><span class="p">(</span><span class="n">rot_poly</span><span class="p">,</span> <span class="n">rot_p</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># Point outside the polygon</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span>

    <span class="n">dist</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">points_segments</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">dist</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
        <span class="c1"># Intersection on boundary. Either vertex of segment.</span>
        <span class="n">vert_dist</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">distances</span><span class="o">.</span><span class="n">point_pointset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">poly</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vert_dist</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">vert_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">vert_dist</span><span class="p">)</span>
            <span class="n">seg_ind</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vert_ind</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: ignore</span>
            <span class="n">seg_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">seg_ind</span><span class="p">,</span> <span class="n">vert_ind</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Point inside</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span>


<div class="viewcode-block" id="triangulations"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.geometry.intersections.html#porepy.geometry.intersections.triangulations">[docs]</a><span class="k">def</span> <span class="nf">triangulations</span><span class="p">(</span>
    <span class="n">p_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">p_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">t_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">t_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Compute intersection of two triangle tessellations of a surface.</span>

<span class="sd">    The function will identify partly overlapping triangles between t_1 and</span>
<span class="sd">    t_2, and compute their common area. If parts of domain 1 or 2 is covered by</span>
<span class="sd">    one tessellation only, this will simply be ignored by the function.</span>

<span class="sd">    Implementation note: The function relies on the intersection algorithm in</span>
<span class="sd">    shapely.geometry.Polygon. It may be possible to extend the functionality</span>
<span class="sd">    to other cell shapes. This would require more general data structures, but</span>
<span class="sd">    should not be too much of an effort.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        p_1 (np.array, 2 x n_p1): Points in first tessellation.</span>
<span class="sd">        p_2 (np.array, 2 x n_p2): Points in second tessellation.</span>
<span class="sd">        t_1 (np.array, 3 x n_tri_1): Triangles in first tessellation, referring</span>
<span class="sd">            to indices in p_1.</span>
<span class="sd">        t_2 (np.array, 3 x n_tri_1): Triangles in second tessellation, referring</span>
<span class="sd">            to indices in p_2.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list of tuples: Each representing an overlap. The tuple contains index</span>
<span class="sd">            of the overlapping triangles in the first and second tessellation,</span>
<span class="sd">            and their common area.</span>

<span class="sd">    See also:</span>
<span class="sd">        surface_tessellations()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">shapely.geometry</span> <span class="k">as</span> <span class="nn">shapely_geometry</span>
    <span class="kn">import</span> <span class="nn">shapely.speedups</span> <span class="k">as</span> <span class="nn">shapely_speedups</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">shapely_speedups</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">n_1</span> <span class="o">=</span> <span class="n">t_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_2</span> <span class="o">=</span> <span class="n">t_2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">t_1</span> <span class="o">=</span> <span class="n">t_1</span><span class="o">.</span><span class="n">T</span>
    <span class="n">t_2</span> <span class="o">=</span> <span class="n">t_2</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Find x and y coordinates of the triangles of first tessellation</span>
    <span class="n">x_1</span> <span class="o">=</span> <span class="n">p_1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_1</span><span class="p">]</span>
    <span class="n">y_1</span> <span class="o">=</span> <span class="n">p_1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_1</span><span class="p">]</span>
    <span class="c1"># Same with second tessellation</span>
    <span class="n">x_2</span> <span class="o">=</span> <span class="n">p_2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_2</span><span class="p">]</span>
    <span class="n">y_2</span> <span class="o">=</span> <span class="n">p_2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t_2</span><span class="p">]</span>

    <span class="n">intersections</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Bounding box of each triangle for first and second tessellation</span>
    <span class="n">min_x_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">max_x_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">min_y_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">max_y_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y_1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">min_x_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">max_x_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">min_y_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">max_y_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y_2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Represent the second tessellation using a Polygon from the shapely package</span>
    <span class="n">poly_2</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">shapely_geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">x_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">y_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">x_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">x_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">y_2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="p">])]</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_2</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># Loop over all triangles in first tessellation, look for overlapping</span>
    <span class="c1"># members in second tessellation</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_1</span><span class="p">):</span>
        <span class="c1"># Polygon representation of the first triangle.</span>
        <span class="n">poly_1</span> <span class="o">=</span> <span class="n">shapely_geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">x_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">y_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">x_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">x_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">y_1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">])]</span>
        <span class="p">)</span>
        <span class="c1"># Find triangles in the second tessellation that are outside the</span>
        <span class="c1"># bounding box of this triangle.</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">min_x_2</span> <span class="o">&gt;</span> <span class="n">max_x_1</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">max_x_2</span> <span class="o">&lt;</span> <span class="n">min_x_1</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">above</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">min_y_2</span> <span class="o">&gt;</span> <span class="n">max_y_1</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">max_y_2</span> <span class="o">&lt;</span> <span class="n">min_y_1</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="c1"># Candidates for intersection are only elements not outside</span>
        <span class="n">outside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">above</span><span class="p">,</span> <span class="n">below</span><span class="p">)))</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_2</span><span class="p">),</span> <span class="n">outside</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Loop over remaining candidates, call upon shapely to find</span>
        <span class="c1"># intersection</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
            <span class="n">isect</span> <span class="o">=</span> <span class="n">poly_1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">poly_2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">isect</span><span class="p">,</span> <span class="n">shapely_geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">):</span>
                <span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">isect</span><span class="o">.</span><span class="n">area</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">intersections</span></div>


<div class="viewcode-block" id="line_tessellation"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.geometry.intersections.html#porepy.geometry.intersections.line_tessellation">[docs]</a><span class="k">def</span> <span class="nf">line_tessellation</span><span class="p">(</span>
    <span class="n">p1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">p2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">l1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">l2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Compute intersection of two line segment tessellations of a line.</span>

<span class="sd">    The function will identify partly overlapping line segments between l1 and</span>
<span class="sd">    l2, and compute their common length.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        p1 (np.array, 3 x n_p1): Points in first tessellation.</span>
<span class="sd">        p2 (np.array, 3 x n_p2): Points in second tessellation.</span>
<span class="sd">        l1 (np.array, 2 x n_tri_1): Line segments in first tessellation, referring</span>
<span class="sd">            to indices in p2.</span>
<span class="sd">        l2 (np.array, 2 x n_tri_1): Line segments in second tessellation, referring</span>
<span class="sd">            to indices in p2.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list of tuples: Each representing an overlap. The tuple contains index</span>
<span class="sd">            of the overlapping line segments in the first and second tessellation,</span>
<span class="sd">            and their common length.</span>

<span class="sd">    Raise:</span>
<span class="sd">        AssertionError(): if pp.segments_3d returns out an unknown shape</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Loop over both set of lines, use segment intersection method to compute</span>
    <span class="c1"># common segments, thus areas.</span>
    <span class="n">intersections</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">start_1</span> <span class="o">=</span> <span class="n">p1</span><span class="p">[:,</span> <span class="n">l1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]]</span>
        <span class="n">end_1</span> <span class="o">=</span> <span class="n">p1</span><span class="p">[:,</span> <span class="n">l1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">start_2</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[:,</span> <span class="n">l2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span>
            <span class="n">end_2</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[:,</span> <span class="n">l2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">segments_3d</span><span class="p">(</span><span class="n">start_1</span><span class="p">,</span> <span class="n">end_1</span><span class="p">,</span> <span class="n">start_2</span><span class="p">,</span> <span class="n">end_2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">X</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Point intersection (zero measure)</span>
                <span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">intersections</span></div>


<div class="viewcode-block" id="surface_tessellations"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.geometry.intersections.html#porepy.geometry.intersections.surface_tessellations">[docs]</a><span class="k">def</span> <span class="nf">surface_tessellations</span><span class="p">(</span>
    <span class="n">poly_sets</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="n">return_simplexes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Intersect a set of surface tessellations to find a finer subdivision that does</span>
<span class="sd">    not intersect with any of the input tessellations.</span>

<span class="sd">    It is assumed that the polygon sets are 2d.</span>

<span class="sd">    The implementation relies heavily on shapely&#39;s intersection finders.</span>

<span class="sd">    Args:</span>
<span class="sd">        poly_sets (List[List[np.ndarray]]): Sets of polygons to be intersected.</span>
<span class="sd">        return_simplexes (boolean, optional): If True, the subdivision is further split</span>
<span class="sd">            into a triangulation. The mappings from the original polygons is updated</span>
<span class="sd">            accordingly. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List[np.ndarray]: Each list element is a polygon so that the list together form</span>
<span class="sd">            a subdivision of the intersection of all polygons in the input sets.</span>
<span class="sd">        List[sps.csr_matrix]: Mappings from each of the input polygons to the</span>
<span class="sd">            intersected polygons. If the mapping&#39;s item[i][j, k] is non-zero, polygon k</span>
<span class="sd">             in set i has a (generally partial) overlap with polygon j in the</span>
<span class="sd">             intersected polygon set. Specifically the value will be 1.</span>

<span class="sd">    Raises:</span>
<span class="sd">        NotImplementedError: If a triangulation of a non-convex polygon is attempted.</span>
<span class="sd">            Can only happen if return_simplexes is True.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># local imports</span>
    <span class="kn">import</span> <span class="nn">shapely.geometry</span> <span class="k">as</span> <span class="nn">shapely_geometry</span>
    <span class="kn">import</span> <span class="nn">shapely.speedups</span> <span class="k">as</span> <span class="nn">shapely_speedups</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">shapely_speedups</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="c1"># Nothing to do here, but this may be slow.</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_min_max_coord</span><span class="p">(</span><span class="n">coord</span><span class="p">):</span>
        <span class="c1"># Convenience function to get max and minimum coordinates for a set of polygons</span>
        <span class="n">min_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coord</span><span class="p">])</span>
        <span class="n">max_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coord</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">min_coord</span><span class="p">,</span> <span class="n">max_coord</span>

    <span class="c1"># Convert polygons into a more convenient data structure</span>
    <span class="n">list_of_sets</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">poly_sets</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">poly</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">))]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">poly</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">))]</span>

        <span class="n">list_of_sets</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>  <span class="c1"># type: ignore</span>

    <span class="c1"># The below algorithm relies heavily on shapely&#39;s functionality for intersection of</span>
    <span class="c1"># polygons. The idea is to intersect represent each set of polygons in the shapely</span>
    <span class="c1"># format, do the intersections with a new set of polygons to find a finer</span>
    <span class="c1"># intersection, and move on.</span>
    <span class="c1"># Also keep track of the mapping from each of the sets of polygons to the</span>
    <span class="c1"># intersected mesh.</span>

    <span class="c1"># Initialize the intersection set as the first set of polygons</span>
    <span class="n">poly_x</span><span class="p">,</span> <span class="n">poly_y</span> <span class="o">=</span> <span class="n">list_of_sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">min_x_poly</span><span class="p">,</span> <span class="n">max_x_poly</span> <span class="o">=</span> <span class="n">_min_max_coord</span><span class="p">(</span><span class="n">poly_x</span><span class="p">)</span>
    <span class="n">min_y_poly</span><span class="p">,</span> <span class="n">max_y_poly</span> <span class="o">=</span> <span class="n">_min_max_coord</span><span class="p">(</span><span class="n">poly_y</span><span class="p">)</span>

    <span class="c1"># poly_shapely will at any time represent the intersected polygon in shapely format,</span>
    <span class="c1"># for the currently covered set of polygon sets.</span>
    <span class="n">poly_shapely</span><span class="p">:</span> <span class="n">shapely_geometry</span><span class="o">.</span><span class="n">Polygon</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">poly_x</span><span class="p">,</span> <span class="n">poly_y</span><span class="p">):</span>
        <span class="n">poly_shapely</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">shapely_geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([(</span><span class="n">px</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">py</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">px</span><span class="o">.</span><span class="n">size</span><span class="p">)])</span>
        <span class="p">)</span>

    <span class="c1"># Data structure for mappings from original polygon sets to the intersected one</span>
    <span class="c1"># As the partition is extended to cover more polygons, a new mapping will be added</span>
    <span class="c1"># and the previous mappings are updated to account for the new intersection level.</span>
    <span class="n">nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly_shapely</span><span class="p">)</span>
    <span class="n">mappings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">sps</span><span class="o">.</span><span class="n">dia_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
    <span class="p">]</span>

    <span class="c1"># Loop over all set of polygons, do intersection with existing</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_sets</span><span class="p">)):</span>

        <span class="c1"># Represent this polygon as in shapely format. Also find max and min coordinates</span>
        <span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span> <span class="o">=</span> <span class="n">list_of_sets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">min_x_new</span><span class="p">,</span> <span class="n">max_x_new</span> <span class="o">=</span> <span class="n">_min_max_coord</span><span class="p">(</span><span class="n">new_x</span><span class="p">)</span>
        <span class="n">min_y_new</span><span class="p">,</span> <span class="n">max_y_new</span> <span class="o">=</span> <span class="n">_min_max_coord</span><span class="p">(</span><span class="n">new_y</span><span class="p">)</span>
        <span class="n">new_shapely</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">):</span>
            <span class="n">new_shapely</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">shapely_geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([(</span><span class="n">px</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">py</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">px</span><span class="o">.</span><span class="n">size</span><span class="p">)])</span>
            <span class="p">)</span>
        <span class="n">num_new</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_shapely</span><span class="p">)</span>

        <span class="c1"># Data structure to store the new intersected polygon</span>
        <span class="n">isect_x</span><span class="p">,</span> <span class="n">isect_y</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="c1"># Data structure to construct mappings to the new intersection from both</span>
        <span class="c1"># this and the previously covered polygons</span>
        <span class="n">row_new</span><span class="p">,</span> <span class="n">row_poly</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">col_new</span><span class="p">,</span> <span class="n">col_poly</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="n">isect_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Loop over all elements in the intersected polygon</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly_shapely</span><span class="p">)):</span>

            <span class="c1"># Find cells in the new polygon that are clearly outside this polygon</span>
            <span class="c1"># This corresponds to creating a box around this intersected polygon, and</span>
            <span class="c1"># disregard all new polygons clearly outside this box</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">min_x_new</span> <span class="o">&gt;</span> <span class="n">max_x_poly</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">max_x_new</span> <span class="o">&lt;</span> <span class="n">min_x_poly</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="n">above</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">min_y_new</span> <span class="o">&gt;</span> <span class="n">max_y_poly</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="n">below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">max_y_new</span> <span class="o">&lt;</span> <span class="n">min_y_poly</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

            <span class="n">outside</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">above</span><span class="p">,</span> <span class="n">below</span><span class="p">)))</span>
            <span class="c1"># Candidates are near this box</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_new</span><span class="p">),</span> <span class="n">outside</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Loop over remaining candidates, call upon shapely to find</span>
            <span class="c1"># intersection</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
                <span class="n">isect</span> <span class="o">=</span> <span class="n">poly_shapely</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">new_shapely</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">isect</span><span class="p">,</span> <span class="n">shapely_geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">):</span>
                    <span class="c1"># This is what must be done to get the coordinates from shapely</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">isect</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
                    <span class="c1"># The shapely Polygon has the start/endpoint represented twice.</span>
                    <span class="c1"># Disregard the end.</span>
                    <span class="n">isect_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="n">ci</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]))</span>
                    <span class="n">isect_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="n">ci</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]))</span>

                    <span class="c1"># Build up the mapping to the new intersected polygon</span>
                    <span class="n">col_new</span> <span class="o">+=</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">col_poly</span> <span class="o">+=</span> <span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">row_new</span> <span class="o">+=</span> <span class="p">[</span><span class="n">isect_counter</span><span class="p">]</span>
                    <span class="n">row_poly</span> <span class="o">+=</span> <span class="p">[</span><span class="n">isect_counter</span><span class="p">]</span>
                    <span class="n">isect_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Mapping from the previously considered polygon to the newly found dissection.</span>
        <span class="c1"># This will be applied to update all previous mappings.</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">isect_counter</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="n">row_poly</span><span class="p">,</span> <span class="n">col_poly</span><span class="p">)),</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">isect_counter</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly_shapely</span><span class="p">)),</span>
        <span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mappings</span><span class="p">)):</span>
            <span class="n">mappings</span><span class="p">[</span><span class="n">mi</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span> <span class="o">*</span> <span class="n">mappings</span><span class="p">[</span><span class="n">mi</span><span class="p">]</span>

        <span class="c1"># Add a mapping between the current polygon and the newly found intersection.</span>
        <span class="n">mappings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">sps</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">isect_counter</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="n">row_new</span><span class="p">,</span> <span class="n">col_new</span><span class="p">)),</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">isect_counter</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_shapely</span><span class="p">)),</span>
            <span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># Define the new set of intersected polygons</span>
        <span class="n">min_x_poly</span><span class="p">,</span> <span class="n">max_x_poly</span> <span class="o">=</span> <span class="n">_min_max_coord</span><span class="p">(</span><span class="n">isect_x</span><span class="p">)</span>
        <span class="n">min_y_poly</span><span class="p">,</span> <span class="n">max_y_poly</span> <span class="o">=</span> <span class="n">_min_max_coord</span><span class="p">(</span><span class="n">isect_y</span><span class="p">)</span>
        <span class="n">poly_shapely</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">isect_x</span><span class="p">,</span> <span class="n">isect_y</span><span class="p">):</span>
            <span class="n">poly_shapely</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">shapely_geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([(</span><span class="n">px</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">py</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">px</span><span class="o">.</span><span class="n">size</span><span class="p">)])</span>
            <span class="p">)</span>

    <span class="c1"># Finally, translate the intersected polygons back to a list of np.ndarrays</span>
    <span class="n">isect_polys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">))</span> <span class="k">for</span> <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">isect_x</span><span class="p">,</span> <span class="n">isect_y</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="n">return_simplexes</span><span class="p">:</span>
        <span class="c1"># Finally, if requested, convert the subdivision into a triangulation.</span>
        <span class="c1"># This option is primarily intended for easy quadrature on the subdivision.</span>
        <span class="c1"># Note that no guarantees are given on the quality of the triangulation.</span>

        <span class="c1"># IMPLEMENTATION NOTE: This could have been turned into a separate function.</span>
        <span class="c1"># However, the code is only tested for a limited set of cases (specifically,</span>
        <span class="c1"># we have considered intersection of non-matching grids on surfaces), so it</span>
        <span class="c1"># seems premature to promote it to a general-purpose function.</span>

        <span class="c1"># We will need a triangulation below</span>
        <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">Delaunay</span>

        <span class="c1"># Data structure for the mapping from isect_polys to the triangulation</span>
        <span class="n">rows</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cols</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tri_counter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Data structure for the triangulation</span>
        <span class="n">tri</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Loop over all isect_polys, split those with more than three vertexes</span>
        <span class="c1"># EK: Somehow, mypy does not understand poly will be an np.ndarray, thus all ignores</span>
        <span class="k">for</span> <span class="n">pi</span><span class="p">,</span> <span class="n">poly</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">isect_polys</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
            <span class="k">if</span> <span class="n">poly</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
                <span class="c1"># Triangles can be used as they are</span>
                <span class="n">tri</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tri_counter</span><span class="p">)</span>
                <span class="n">tri_counter</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Check if the polygon is convex. Loop over the polygon vertexes, and</span>
                <span class="c1"># check if they form a CW or CCW part of the polygon. If they all</span>
                <span class="c1"># have the same configuration, the polygon is convex</span>

                <span class="c1"># Three representation of the polygon vertexes, by shifting their order</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">poly</span>
                <span class="c1"># This is the vertex we test</span>
                <span class="n">middle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                <span class="c1"># Use ccw test on all vertexes in the polygon</span>
                <span class="n">is_ccw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">pp</span><span class="o">.</span><span class="n">geometry_property_checks</span><span class="o">.</span><span class="n">is_ccw_polyline</span><span class="p">(</span>
                            <span class="n">start</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">middle</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">end</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>  <span class="c1"># type:ignore</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># type:ignore</span>
                    <span class="p">]</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">is_ccw</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">is_ccw</span><span class="p">)):</span>
                    <span class="c1"># This is a convex polygon. The triangulation can be formed by a</span>
                    <span class="c1"># Delaunay tessellation of the polygon. In an attempt to improve the</span>
                    <span class="c1"># quality of the simplexes, we add the center of the polygon</span>
                    <span class="c1"># (defined as the mean coordinate, should be fine since the polygon</span>
                    <span class="c1"># is convex) to the points to be triangulated. This may not be</span>
                    <span class="c1"># necessary, and should be up for revision. If the polygon has a bad</span>
                    <span class="c1"># shape, the triangulation will also have bad triangles - to improve</span>
                    <span class="c1"># we would need to do a more careful triangulation, adding more</span>
                    <span class="c1"># points</span>
                    <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
                    <span class="n">ext_poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">poly</span><span class="p">,</span> <span class="n">center</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># type: ignore</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">ext_poly</span><span class="p">)</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span>
                        <span class="n">tri</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ext_poly</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                        <span class="c1">#</span>
                        <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
                        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tri_counter</span><span class="p">)</span>
                        <span class="n">tri_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># For non-convex polygons, the Delaunay triangulation will generate</span>
                    <span class="c1"># simplexes not inside the polygon; specifically the triangulation</span>
                    <span class="c1"># will cover the convex hull of the polygon. These can likely be</span>
                    <span class="c1"># pruned by excluding triangles with a center not inside the</span>
                    <span class="c1"># polygon (would need a point-in-polygon test for non-convex</span>
                    <span class="c1"># polygons), but that would be for another day.</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Non-convex polygons not covered&quot;</span><span class="p">)</span>

        <span class="c1"># Also update the mapping.</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)),</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">isect_polys</span><span class="p">)),</span>
        <span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mappings</span><span class="p">)):</span>
            <span class="n">mappings</span><span class="p">[</span><span class="n">mi</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span> <span class="o">*</span> <span class="n">mappings</span><span class="p">[</span><span class="n">mi</span><span class="p">]</span>

        <span class="n">isect_polys</span> <span class="o">=</span> <span class="n">tri</span>

    <span class="k">return</span> <span class="n">isect_polys</span><span class="p">,</span> <span class="n">mappings</span></div>


<div class="viewcode-block" id="split_intersecting_segments_2d"><a class="viewcode-back" href="../../../docsrc/porepy/porepy.geometry.intersections.html#porepy.geometry.intersections.split_intersecting_segments_2d">[docs]</a><span class="k">def</span> <span class="nf">split_intersecting_segments_2d</span><span class="p">(</span>
    <span class="n">p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="n">return_argsort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Process a set of points and connections between them so that the result</span>
<span class="sd">    is an extended point set and new connections that do not intersect.</span>

<span class="sd">    The function is written for gridding of fractured domains, but may be</span>
<span class="sd">    of use in other cases as well. The geometry is assumed to be 2D.</span>

<span class="sd">    The connections are defined by their start and endpoints, and can also</span>
<span class="sd">    have tags assigned. If so, the tags are preserved as connections are split.</span>
<span class="sd">    The connections are uniquified, so that no combination of point indices</span>
<span class="sd">    occurs more than once.</span>
<span class="sd">    NOTE: For (partly) overlapping segments, only one of the tags will survive the</span>
<span class="sd">    uniquification. The other can be reconstructed by using the third output.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        p (np.ndarray, 2 x n_pt): Coordinates of points to be processed</span>
<span class="sd">        e (np.ndarray, n x n_con): Connections between lines. n &gt;= 2, row</span>
<span class="sd">            0 and 1 are index of start and endpoints, additional rows are tags</span>
<span class="sd">        tol (double, optional, default=1e-8): Tolerance used for comparing</span>
<span class="sd">            equal points.</span>
<span class="sd">        return_argsort (bool, optional, default=False): Return the mapping</span>
<span class="sd">            between the input segments and the output segments.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray, (2 x n_pt), array of points, possibly expanded.</span>
<span class="sd">        np.ndarray, (n x n_edges), array of new edges. Non-intersecting.</span>
<span class="sd">        tuple of 2 arrays, both n_con: First item is a set of tags, before</span>
<span class="sd">            uniquification of the edges. The second is a column mapping from the</span>
<span class="sd">            unique edges to all edges. To recover lost tags associated with the</span>
<span class="sd">            points in column i, first find all original columns which maps to</span>
<span class="sd">            i (tuple[1] == i), then recover the tags by the hits.</span>
<span class="sd">        np.array, (n_edges), array to map the new edges with the input edges.</span>
<span class="sd">            Returned if return_argsort is True.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Find the bounding box</span>
    <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">_axis_aligned_bounding_box_2d</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>

    <span class="c1"># If a polygon is perfectly aligned with a coordinate axis, and another polygon</span>
    <span class="c1"># terminates in the first one, rounding errors in the coordinates may lead to</span>
    <span class="c1"># the intersection not being picked up. To circumvent the issue, detect such</span>
    <span class="c1"># situations and give ourselves a bit wiggle room.</span>
    <span class="c1"># It seems that this will not give problems in other cases.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">cmin</span><span class="p">,</span> <span class="n">cmax</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">),</span> <span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)]:</span>
        <span class="n">hit</span> <span class="o">=</span> <span class="n">cmax</span> <span class="o">-</span> <span class="n">cmin</span> <span class="o">&lt;</span> <span class="n">tol</span>
        <span class="n">cmin</span><span class="p">[</span><span class="n">hit</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">tol</span>
        <span class="n">cmax</span><span class="p">[</span><span class="n">hit</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">tol</span>

    <span class="c1"># Identify fractures with overlapping bounding boxes</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="n">_identify_overlapping_rectangles</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span>

    <span class="c1"># Identify all fractures that are the first (by index) of a potentially</span>
    <span class="c1"># crossing pair. A better way to group the fractures may be feasible,</span>
    <span class="c1"># but this has not been investigated.</span>
    <span class="n">start_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">num_lines</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Data structure for storage of intersection points. For each fracture,</span>
    <span class="c1"># we have an array that will contain the index of the intersections.</span>
    <span class="n">isect_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">num_lines</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">isect_pt</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="n">isect_pt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Array of new points, found in the intersection of old ones.</span>
    <span class="n">new_pts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># The new points will be appended to the old ones, thus their index</span>
    <span class="c1"># must be adjusted.</span>
    <span class="n">new_ind</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Loop through all candidate pairs of intersecting fractures, check if</span>
    <span class="c1"># they do intersect. If so, store the point, and for each crossing fracture</span>
    <span class="c1"># take note of the index of the cross point.</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">line_ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">start_inds</span><span class="p">):</span>
        <span class="c1"># First fracture in the candidate pair</span>
        <span class="n">main</span> <span class="o">=</span> <span class="n">line_ind</span>
        <span class="c1"># Find all other fractures that is in a pair with the main as the first one.</span>
        <span class="n">hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">main</span><span class="p">)</span>
        <span class="c1"># Sort the other points; this makes debugging simpler if nothing else.</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">hit</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># We will first do a coarse sorting, to rule out fractures that are clearly</span>
        <span class="c1"># not intersecting, and then do a finer search for an intersection below.</span>

        <span class="c1"># Utility function to pull out one or several points from an array based</span>
        <span class="c1"># on index</span>
        <span class="k">def</span> <span class="nf">pt</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ind</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span>

        <span class="c1"># Obtain start and endpoint of the main and other fractures</span>
        <span class="n">start_main</span> <span class="o">=</span> <span class="n">pt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">main</span><span class="p">])</span>
        <span class="n">end_main</span> <span class="o">=</span> <span class="n">pt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">main</span><span class="p">])</span>
        <span class="n">start_other</span> <span class="o">=</span> <span class="n">pt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>
        <span class="n">end_other</span> <span class="o">=</span> <span class="n">pt</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>

        <span class="c1"># Utility function to normalize the fracture length</span>
        <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="n">nrm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

            <span class="c1"># If the norm of the vector is essentially zero, do not normalize the vector</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="n">nrm</span> <span class="o">&lt;</span> <span class="n">tol</span>
            <span class="n">nrm</span><span class="p">[</span><span class="n">hit</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">v</span> <span class="o">/</span> <span class="n">nrm</span>

        <span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Vectors along the main fracture, and from the start of the main</span>
        <span class="c1"># to the start and end of the other fractures. All normalized.</span>
        <span class="c1"># If the other edges share start or endpoint with the main one, normalization</span>
        <span class="c1"># of the distance vector will make the vector nans. In this case, we</span>
        <span class="c1"># use another point along the other line, this works equally well for the</span>
        <span class="c1"># coarse identification (based on cross products).</span>
        <span class="c1"># If the segments are overlapping, there will still be issues with nans,</span>
        <span class="c1"># but these are dealt with below.</span>
        <span class="n">main_vec</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">end_main</span> <span class="o">-</span> <span class="n">start_main</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dist</span><span class="p">(</span><span class="n">start_other</span><span class="p">,</span> <span class="n">start_main</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">main_other_start</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">start_other</span> <span class="o">-</span> <span class="n">start_main</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">main_other_start</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">start_other</span> <span class="o">+</span> <span class="n">end_other</span><span class="p">)</span> <span class="o">-</span> <span class="n">start_main</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dist</span><span class="p">(</span><span class="n">end_other</span><span class="p">,</span> <span class="n">start_main</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">main_other_end</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">end_other</span> <span class="o">-</span> <span class="n">start_main</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Values 0.3 and 0.7 are quite random here.</span>
            <span class="n">main_other_end</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="mf">0.3</span> <span class="o">*</span> <span class="n">start_other</span> <span class="o">+</span> <span class="mf">0.7</span> <span class="o">*</span> <span class="n">end_other</span> <span class="o">-</span> <span class="n">start_main</span><span class="p">)</span>

        <span class="c1"># Modified signum function: The value is 0 if it is very close to zero.</span>
        <span class="k">def</span> <span class="nf">mod_sign</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
            <span class="n">sgn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">sgn</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">sgn</span>

        <span class="c1"># Take the cross product between the vector along the main line, and the</span>
        <span class="c1"># vectors to the start and end of the other lines, respectively.</span>
        <span class="n">start_cross</span> <span class="o">=</span> <span class="n">mod_sign</span><span class="p">(</span>
            <span class="n">main_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">main_other_start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">main_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">main_other_start</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tol</span>
        <span class="p">)</span>
        <span class="n">end_cross</span> <span class="o">=</span> <span class="n">mod_sign</span><span class="p">(</span>
            <span class="n">main_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">main_other_end</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">main_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">main_other_end</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tol</span>
        <span class="p">)</span>

        <span class="c1"># If the start and endpoint of the other fracture are clearly on the</span>
        <span class="c1"># same side of the main one, these are not crossing.</span>
        <span class="c1"># For completely ovrelapping edges, the normalization will leave the</span>
        <span class="c1"># vectors nan. There may be better ways of dealing with this, but we simply</span>
        <span class="c1"># run the intersection finder in this case.</span>
        <span class="n">relevant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                <span class="p">(</span><span class="n">start_cross</span> <span class="o">*</span> <span class="n">end_cross</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">main_other_start</span> <span class="o">+</span> <span class="n">main_other_end</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Loop over all relevant (possibly crossing) fractures, look closer</span>
        <span class="c1"># for an intersection.</span>
        <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">relevant</span><span class="p">:</span>
            <span class="n">ipt</span> <span class="o">=</span> <span class="n">segments_2d</span><span class="p">(</span>
                <span class="n">start_main</span><span class="p">,</span> <span class="n">end_main</span><span class="p">,</span> <span class="n">pt</span><span class="p">(</span><span class="n">start_other</span><span class="p">,</span> <span class="n">ri</span><span class="p">),</span> <span class="n">pt</span><span class="p">(</span><span class="n">end_other</span><span class="p">,</span> <span class="n">ri</span><span class="p">),</span> <span class="n">tol</span>
            <span class="p">)</span>
            <span class="c1"># Add the intersection point, if any.</span>
            <span class="c1"># If two intersection points are found, that is the edges are overlapping</span>
            <span class="c1"># both points are added.</span>
            <span class="k">if</span> <span class="n">ipt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">num_isect</span> <span class="o">=</span> <span class="n">ipt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># Add indices of the new points to the main and other edge</span>
                <span class="n">isect_pt</span><span class="p">[</span><span class="n">main</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">isect_pt</span><span class="p">[</span><span class="n">main</span><span class="p">],</span> <span class="n">new_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_isect</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">isect_pt</span><span class="p">[</span><span class="n">other</span><span class="p">[</span><span class="n">ri</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">isect_pt</span><span class="p">[</span><span class="n">other</span><span class="p">[</span><span class="n">ri</span><span class="p">]],</span> <span class="n">new_ind</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_isect</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">new_ind</span> <span class="o">+=</span> <span class="n">num_isect</span>

                <span class="c1"># Add the one or two intertion points</span>
                <span class="k">if</span> <span class="n">num_isect</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">new_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ipt</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># It turned out the transport was needed to get the code to work</span>
                    <span class="n">new_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ipt</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="c1"># If we have found no intersection points, we can safely return the incoming</span>
    <span class="c1"># points and edges.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_pts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Tag information is trivial in this case</span>
        <span class="n">tags</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">tag_info</span> <span class="o">=</span> <span class="p">(</span><span class="n">tags</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_argsort</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">tag_info</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">tag_info</span>

    <span class="c1"># If intersection points are found, the intersecting lines must be split into</span>
    <span class="c1"># shorter segments.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># The full set of points, both original and newly found intersection points</span>
        <span class="n">all_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new_pts</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
        <span class="c1"># Remove duplicates in the point set.</span>
        <span class="c1"># NOTE: The tolerance used here is a bit sensitive, if set too loose, this</span>
        <span class="c1"># may merge non-intersecting fractures.</span>

        <span class="n">unique_all_pt</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">ib</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">setmembership</span><span class="o">.</span><span class="n">uniquify_point_set</span><span class="p">(</span><span class="n">all_pt</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

        <span class="c1"># Data structure for storing the split edges.</span>
        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">e</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">argsort</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Loop over all lines, split it into non-overlapping segments.</span>
        <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_lines</span><span class="p">):</span>
            <span class="c1"># Find indices of all points involved in this fracture.</span>
            <span class="c1"># Map them to the unique point set, and uniquify</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ib</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">e</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="n">ei</span><span class="p">],</span> <span class="n">isect_pt</span><span class="p">[</span><span class="n">ei</span><span class="p">]))])</span>
            <span class="n">num_branches</span> <span class="o">=</span> <span class="n">inds</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># Get the coordinates themselves.</span>
            <span class="n">loc_pts</span> <span class="o">=</span> <span class="n">pt</span><span class="p">(</span><span class="n">unique_all_pt</span><span class="p">,</span> <span class="n">inds</span><span class="p">)</span>
            <span class="c1"># Specifically get the start point: Pick one of the points of the</span>
            <span class="c1"># original edge, e[0, ei], which is known to be at an end of the edge.</span>
            <span class="c1"># map to the unique indices</span>
            <span class="n">loc_start</span> <span class="o">=</span> <span class="n">pt</span><span class="p">(</span><span class="n">unique_all_pt</span><span class="p">,</span> <span class="n">ib</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ei</span><span class="p">]])</span>
            <span class="c1"># Measure the distance of the points from the start. This can be used</span>
            <span class="c1"># to sort the points along the line</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">loc_pts</span> <span class="o">-</span> <span class="n">loc_start</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>  <span class="c1"># Needed to appease mypy</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
            <span class="n">new_inds</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
            <span class="c1"># All new segments share the tags of the old one.</span>
            <span class="n">loc_tags</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span> <span class="n">ei</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_branches</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="c1"># Define the new segments, in terms of the unique points</span>
            <span class="n">loc_edge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">new_inds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">new_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">loc_tags</span><span class="p">))</span>

            <span class="c1"># Add to the global list of segments</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">loc_edge</span><span class="p">))</span>
            <span class="n">argsort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">argsort</span><span class="p">,</span> <span class="p">[</span><span class="n">ei</span><span class="p">]</span> <span class="o">*</span> <span class="n">loc_edge</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># Finally, uniquify edges. This operation is necessary for overlapping edges.</span>
        <span class="c1"># Operate on sorted point indices per edge</span>
        <span class="n">new_edge</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">new_edge</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Keep the old tags before uniquifying</span>
        <span class="n">tags</span> <span class="o">=</span> <span class="n">new_edge</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="c1"># Uniquify.</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">edge_map</span><span class="p">,</span> <span class="n">all_2_unique</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">setmembership</span><span class="o">.</span><span class="n">unique_columns_tol</span><span class="p">(</span>
            <span class="n">new_edge</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">tol</span>
        <span class="p">)</span>
        <span class="n">tag_info</span> <span class="o">=</span> <span class="p">(</span><span class="n">tags</span><span class="p">,</span> <span class="n">all_2_unique</span><span class="p">)</span>

        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">new_edge</span><span class="p">[:,</span> <span class="n">edge_map</span><span class="p">]</span>
        <span class="n">argsort</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">[</span><span class="n">edge_map</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">return_argsort</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">unique_all_pt</span><span class="p">,</span> <span class="n">new_edge</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">tag_info</span><span class="p">,</span> <span class="n">argsort</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">unique_all_pt</span><span class="p">,</span> <span class="n">new_edge</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">tag_info</span></div>


<span class="k">def</span> <span class="nf">_axis_aligned_bounding_box_2d</span><span class="p">(</span>
    <span class="n">p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;For a set of lines in 2d, obtain the bounding box for each line.</span>

<span class="sd">    The lines are specified as a list of points, together with connections between</span>
<span class="sd">    the points.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        p (np.ndarray, 2 x n_pt): Coordinates of points to be processed</span>
<span class="sd">        e (np.ndarray, n x n_con): Connections between lines. n &gt;= 2, row</span>
<span class="sd">            0 and 1 are index of start and endpoints, additional rows are tags</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array (n_pt): Minimum x-coordinate for all lines.</span>
<span class="sd">        np.array (n_pt): Maximum x-coordinate for all lines.</span>
<span class="sd">        np.array (n_pt): Minimum y-coordinate for all lines.</span>
<span class="sd">        np.array (n_pt): Maximum y-coordinate for all lines.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">x_0</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">x_1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">y_0</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">y_1</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="n">x_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x_0</span><span class="p">,</span> <span class="n">x_1</span><span class="p">)</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x_0</span><span class="p">,</span> <span class="n">x_1</span><span class="p">)</span>
    <span class="n">y_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">y_0</span><span class="p">,</span> <span class="n">y_1</span><span class="p">)</span>
    <span class="n">y_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">y_0</span><span class="p">,</span> <span class="n">y_1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span>


<span class="k">def</span> <span class="nf">_axis_aligned_bounding_box_3d</span><span class="p">(</span>
    <span class="n">polys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;For a set of polygons embedded in 3d, obtain the bounding box for each object.</span>

<span class="sd">    The polygons are specified as a list of numpy arrays.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        p (list of np.ndarray, 3 x n_pt): Each list element specifies a</span>
<span class="sd">            polygon, described by its vertexes in a 3 x num_points np.array.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array (n_pt): Minimum x-coordinate for all lines.</span>
<span class="sd">        np.array (n_pt): Maximum x-coordinate for all lines.</span>
<span class="sd">        np.array (n_pt): Minimum y-coordinate for all lines.</span>
<span class="sd">        np.array (n_pt): Maximum y-coordinate for all lines.</span>
<span class="sd">        np.array (n_pt): Minimum z-coordinate for all lines.</span>
<span class="sd">        np.array (n_pt): Maximum z-coordinate for all lines.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">polys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>

    <span class="n">num_poly</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>

    <span class="n">x_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">num_poly</span><span class="p">)</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span>
    <span class="n">y_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span>
    <span class="n">y_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span>
    <span class="n">z_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span>
    <span class="n">z_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polys</span><span class="p">):</span>
        <span class="n">x_min</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">x_max</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">y_min</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">y_max</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">z_min</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">z_max</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">z_min</span><span class="p">,</span> <span class="n">z_max</span>


<span class="k">def</span> <span class="nf">_identify_overlapping_intervals</span><span class="p">(</span><span class="n">left</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Based on a set of start and end coordinates for intervals, identify pairs of</span>
<span class="sd">    overlapping intervals.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        left (np.array): Minimum coordinates of the intervals.</span>
<span class="sd">        right (np.array): Maximum coordinates of the intervals.</span>

<span class="sd">        For all items, left &lt;= right (but equality is allowed).</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array, 2 x num_overlaps: Each column contains a pair of overlapping</span>
<span class="sd">            intervals, refering to their placement in left and right. The pairs</span>
<span class="sd">            are sorted so that the lowest index is in the first column.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># There can be no overlaps if there is less than two intervals</span>
    <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Sort the coordinates</span>
    <span class="n">sort_ind_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
    <span class="n">sort_ind_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

    <span class="c1"># pointers to the next start and end point of an interval</span>
    <span class="n">next_right</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">next_left</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># List of pairs we have found</span>
    <span class="n">pairs</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># List of intervals we are currently in. All intervals will join and leave this set.</span>
    <span class="n">active</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">num_lines</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">size</span>

    <span class="c1"># Loop through the line, add and remove intervals as we come across them.</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Check if the next start (left) point is before the next endpoint,</span>
        <span class="c1"># But only if there are more left points available.</span>
        <span class="c1"># Less or equal is critical here, or else cases where a point interval</span>
        <span class="c1"># is combined with the start of another interval may not be discovered.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">next_left</span> <span class="o">&lt;</span> <span class="n">num_lines</span>
            <span class="ow">and</span> <span class="n">left</span><span class="p">[</span><span class="n">sort_ind_left</span><span class="p">[</span><span class="n">next_left</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">[</span><span class="n">sort_ind_right</span><span class="p">[</span><span class="n">next_right</span><span class="p">]]</span>
        <span class="p">):</span>
            <span class="c1"># We have started a new interval. This will be paired with</span>
            <span class="c1"># all active intervals</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">active</span><span class="p">:</span>
                <span class="n">pairs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">sort_ind_left</span><span class="p">[</span><span class="n">next_left</span><span class="p">]])</span>
            <span class="c1"># Also join the new intervals to the active set.</span>
            <span class="n">active</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_ind_left</span><span class="p">[</span><span class="n">next_left</span><span class="p">])</span>
            <span class="c1"># Increase the index</span>
            <span class="n">next_left</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We have reached the end of the interval - remove it from the</span>
            <span class="c1"># active ones.</span>
            <span class="n">active</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sort_ind_right</span><span class="p">[</span><span class="n">next_right</span><span class="p">])</span>
            <span class="n">next_right</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Check if we have come to the end</span>
            <span class="k">if</span> <span class="n">next_right</span> <span class="o">==</span> <span class="n">num_lines</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">final_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># First sort the pairs themselves</span>
        <span class="n">final_pairs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Next, sort the columns so that the first row is non-decreasing</span>
        <span class="n">sort_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">final_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">final_pairs</span> <span class="o">=</span> <span class="n">final_pairs</span><span class="p">[:,</span> <span class="n">sort_ind</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">final_pairs</span>


<span class="k">def</span> <span class="nf">_identify_overlapping_rectangles</span><span class="p">(</span>
    <span class="n">xmin</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">xmax</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ymin</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ymax</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Based on a set of start and end coordinates for bounding boxes, identify pairs of</span>
<span class="sd">    overlapping rectangles.</span>

<span class="sd">    The algorithm was found in &#39;A fast method for fracture intersection detection</span>
<span class="sd">    in discrete fracture networks&#39; by Dong et al, omputers and Geotechniques 2018.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        xmin (np.array): Minimum coordinates of the rectangle on the first axis.</span>
<span class="sd">        xmax (np.array): Maximum coordinates of the rectangle on the first axis.</span>
<span class="sd">        ymin (np.array): Minimum coordinates of the rectangle on the second axis.</span>
<span class="sd">        ymax (np.array): Maximum coordinates of the rectangle on the second axis.</span>

<span class="sd">        For all items, xmin &lt;= xmax (but equality is allowed), correspondingly for</span>
<span class="sd">        the y-coordinates</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array, 2 x num_overlaps: Each column contains a pair of overlapping</span>
<span class="sd">            intervals, refering to their placement in left and right. The pairs</span>
<span class="sd">            are sorted so that the lowest index is in the first column.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># There can be no overlaps if there is less than two rectangles</span>
    <span class="k">if</span> <span class="n">xmin</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Sort the coordinates</span>
    <span class="n">sort_ind_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span>
    <span class="n">sort_ind_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">xmax</span><span class="p">)</span>

    <span class="c1"># pointers to the next start and end point of an interval</span>
    <span class="n">next_min</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">next_max</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># List of pairs we have found</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># List of intervals we are currently in. All intervals will join and leave this set.</span>
    <span class="n">active</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">num_lines</span> <span class="o">=</span> <span class="n">xmax</span><span class="o">.</span><span class="n">size</span>

    <span class="c1"># Pass along the x-axis, identify the start and end of rectangles as we go.</span>
    <span class="c1"># The idea is then for each new interval to check which of the active intervals</span>
    <span class="c1"># also have overlap along the y-axis. These will be identified as pairs.</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Check if the next start (xmin) point is before the next endpoint,</span>
        <span class="c1"># but only if there are more left points available.</span>
        <span class="c1"># Less or equal is critical here, or else cases where a point interval</span>
        <span class="c1"># is combined with the start of another interval may not be discovered.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">next_min</span> <span class="o">&lt;</span> <span class="n">num_lines</span>
            <span class="ow">and</span> <span class="n">xmin</span><span class="p">[</span><span class="n">sort_ind_min</span><span class="p">[</span><span class="n">next_min</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">xmax</span><span class="p">[</span><span class="n">sort_ind_max</span><span class="p">[</span><span class="n">next_max</span><span class="p">]]</span>
        <span class="p">):</span>
            <span class="c1"># Find active rectangles where the y-interval is also overlapping</span>
            <span class="n">between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                    <span class="n">ymax</span><span class="p">[</span><span class="n">sort_ind_min</span><span class="p">[</span><span class="n">next_min</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="n">ymin</span><span class="p">[</span><span class="n">active</span><span class="p">],</span>
                    <span class="n">ymin</span><span class="p">[</span><span class="n">sort_ind_min</span><span class="p">[</span><span class="n">next_min</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">ymax</span><span class="p">[</span><span class="n">active</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># For all identified overlaps, add the new pairs</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">between</span><span class="p">:</span>
                <span class="n">pairs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">active</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">sort_ind_min</span><span class="p">[</span><span class="n">next_min</span><span class="p">]])</span>
            <span class="c1"># Add this to the active rectangles, and increase the index</span>
            <span class="n">active</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_ind_min</span><span class="p">[</span><span class="n">next_min</span><span class="p">])</span>
            <span class="n">next_min</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We are leaving a rectangle.</span>
            <span class="n">active</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sort_ind_max</span><span class="p">[</span><span class="n">next_max</span><span class="p">])</span>
            <span class="n">next_max</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Check if we have come to the end</span>
            <span class="k">if</span> <span class="n">next_max</span> <span class="o">==</span> <span class="n">num_lines</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">final_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># First sort the pairs themselves</span>
        <span class="n">final_pairs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Next, sort the columns so that the first row is non-decreasing</span>
        <span class="n">sort_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">final_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">final_pairs</span> <span class="o">=</span> <span class="n">final_pairs</span><span class="p">[:,</span> <span class="n">sort_ind</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">final_pairs</span>


<span class="k">def</span> <span class="nf">_intersect_pairs</span><span class="p">(</span><span class="n">p1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">p2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;For two lists containing pair of indices, find the intersection.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        p1 (np.array, 2 x n): Each column contains a pair of indices.</span>
<span class="sd">        p2 (np.array, 2 x m): Each column contains a pair of indices.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array, (2 x k, k &lt;= min(n, m)): Each column contains a pair of</span>
<span class="sd">            indices that are found in both p1 and p2. The array is sorted so</span>
<span class="sd">            that items in the first row is less or equal to the second row.</span>
<span class="sd">            The columns are sorted according to the numbers in the first row.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Special treatment of empty lists</span>
    <span class="k">if</span> <span class="n">p1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">p2</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Do the intersection</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">setmembership</span><span class="o">.</span><span class="n">ismember_rows</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">]</span>

        <span class="c1"># First sort the pairs themselves</span>
        <span class="n">pairs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Next, sort the columns so that the first row is non-decreasing</span>
        <span class="n">sort_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[:,</span> <span class="n">sort_ind</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">pairs</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022 UiB Center for Modeling of Coupled Subsurface Dynamics, GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007..</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>