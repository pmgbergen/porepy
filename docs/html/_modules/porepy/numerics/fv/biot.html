

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>porepy.numerics.fv.biot &mdash; PorePy 1.6.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />

  
    <link rel="canonical" href="https://pmgbergen.github.io/porepy/_modules/porepy/numerics/fv/biot.html" />
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=cfbabd6b"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            PorePy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../docsrc/porepy/porepy.html">porepy package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.html">porepy.fracs package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.fracture.html">porepy.fracs.fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.fracture_importer.html">porepy.fracs.fracture_importer module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.fracture_network_2d.html">porepy.fracs.fracture_network_2d module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html">porepy.fracs.fracture_network_3d module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.gmsh_interface.html">porepy.fracs.gmsh_interface module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.line_fracture.html">porepy.fracs.line_fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.meshing.html">porepy.fracs.meshing module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.msh_2_grid.html">porepy.fracs.msh_2_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.non_conforming.html">porepy.fracs.non_conforming module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.plane_fracture.html">porepy.fracs.plane_fracture module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.simplex.html">porepy.fracs.simplex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.split_grid.html">porepy.fracs.split_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.structured.html">porepy.fracs.structured module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.tools.html">porepy.fracs.tools module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.utils.html">porepy.fracs.utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.wells_3d.html">porepy.fracs.wells_3d module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.html">porepy.geometry package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.bounding_box.html">porepy.geometry.bounding_box module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.constrain_geometry.html">porepy.geometry.constrain_geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.distances.html">porepy.geometry.distances module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.geometry_property_checks.html">porepy.geometry.geometry_property_checks module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.half_space.html">porepy.geometry.half_space module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.intersections.html">porepy.geometry.intersections module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.map_geometry.html">porepy.geometry.map_geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.point_in_polyhedron_test.html">porepy.geometry.point_in_polyhedron_test module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.html">porepy.grids package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.standard_grids.html">porepy.grids.standard_grids package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.standard_grids.md_grids_2d.html">porepy.grids.standard_grids.md_grids_2d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.standard_grids.md_grids_3d.html">porepy.grids.standard_grids.md_grids_3d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.standard_grids.utils.html">porepy.grids.standard_grids.utils module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.boundary_grid.html">porepy.grids.boundary_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.coarsening.html">porepy.grids.coarsening module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.grid.html">porepy.grids.grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.grid_extrusion.html">porepy.grids.grid_extrusion module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.match_grids.html">porepy.grids.match_grids module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.md_grid.html">porepy.grids.md_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.mortar_grid.html">porepy.grids.mortar_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.partition.html">porepy.grids.partition module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.point_grid.html">porepy.grids.point_grid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.refinement.html">porepy.grids.refinement module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.simplex.html">porepy.grids.simplex module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.structured.html">porepy.grids.structured module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.html">porepy.models package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.verification_setups.html">porepy.models.verification_setups package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.verification_setups.manu_flow_comp_frac.html">porepy.models.verification_setups.manu_flow_comp_frac module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.verification_setups.manu_flow_incomp_frac.html">porepy.models.verification_setups.manu_flow_incomp_frac module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.verification_setups.manu_poromech_nofrac.html">porepy.models.verification_setups.manu_poromech_nofrac module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.verification_setups.verifications_utils.html">porepy.models.verification_setups.verifications_utils module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.abstract_equations.html">porepy.models.abstract_equations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.abstract_model.html">porepy.models.abstract_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.constitutive_laws.html">porepy.models.constitutive_laws module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.contact_mechanics_biot_model.html">porepy.models.contact_mechanics_biot_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.contact_mechanics_model.html">porepy.models.contact_mechanics_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.energy_balance.html">porepy.models.energy_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.fluid_mass_balance.html">porepy.models.fluid_mass_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.geometry.html">porepy.models.geometry module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.incompressible_flow_model.html">porepy.models.incompressible_flow_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.mass_and_energy_balance.html">porepy.models.mass_and_energy_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.material_constants.html">porepy.models.material_constants module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.momentum_balance.html">porepy.models.momentum_balance module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.poromechanics.html">porepy.models.poromechanics module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.run_models.html">porepy.models.run_models module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.slightly_compressible_flow_model.html">porepy.models.slightly_compressible_flow_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.solution_strategy.html">porepy.models.solution_strategy module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.thermoporomechanics.html">porepy.models.thermoporomechanics module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.thm_model.html">porepy.models.thm_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.units.html">porepy.models.units module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.html">porepy.numerics package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.ad.html">porepy.numerics.ad package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.ad.discretizations.html">porepy.numerics.ad.discretizations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_manager.html">porepy.numerics.ad.equation_manager module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html">porepy.numerics.ad.equation_system module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.ad.forward_mode.html">porepy.numerics.ad.forward_mode module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.ad.functions.html">porepy.numerics.ad.functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.ad.grid_operators.html">porepy.numerics.ad.grid_operators module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.ad.operator_functions.html">porepy.numerics.ad.operator_functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.ad.operators.html">porepy.numerics.ad.operators module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.ad.time_derivatives.html">porepy.numerics.ad.time_derivatives module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fem.html">porepy.numerics.fem package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fem.rt0.html">porepy.numerics.fem.rt0 module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fracture_deformation.html">porepy.numerics.fracture_deformation package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fracture_deformation.conforming_propagation.html">porepy.numerics.fracture_deformation.conforming_propagation module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fracture_deformation.contact_conditions.html">porepy.numerics.fracture_deformation.contact_conditions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fracture_deformation.propagate_fracture.html">porepy.numerics.fracture_deformation.propagate_fracture module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fracture_deformation.propagation_model.html">porepy.numerics.fracture_deformation.propagation_model module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fv.html">porepy.numerics.fv package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html">porepy.numerics.fv.biot module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fv.fv_elliptic.html">porepy.numerics.fv.fv_elliptic module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fv.fvutils.html">porepy.numerics.fv.fvutils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fv.mass_matrix.html">porepy.numerics.fv.mass_matrix module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fv.mpfa.html">porepy.numerics.fv.mpfa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fv.mpsa.html">porepy.numerics.fv.mpsa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fv.source.html">porepy.numerics.fv.source module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fv.tpfa.html">porepy.numerics.fv.tpfa module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fv.upwind.html">porepy.numerics.fv.upwind module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.interface_laws.html">porepy.numerics.interface_laws package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.interface_laws.abstract_interface_law.html">porepy.numerics.interface_laws.abstract_interface_law module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.interface_laws.cell_dof_face_dof_map.html">porepy.numerics.interface_laws.cell_dof_face_dof_map module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.interface_laws.contact_mechanics_interface_laws.html">porepy.numerics.interface_laws.contact_mechanics_interface_laws module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.interface_laws.elliptic_discretization.html">porepy.numerics.interface_laws.elliptic_discretization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.interface_laws.elliptic_interface_laws.html">porepy.numerics.interface_laws.elliptic_interface_laws module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.interface_laws.hyperbolic_interface_laws.html">porepy.numerics.interface_laws.hyperbolic_interface_laws module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.linalg.html">porepy.numerics.linalg package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.linalg.matrix_operations.html">porepy.numerics.linalg.matrix_operations module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.mixed_dim.html">porepy.numerics.mixed_dim package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler.html">porepy.numerics.mixed_dim.assembler module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler_filters.html">porepy.numerics.mixed_dim.assembler_filters module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.mixed_dim.dof_manager.html">porepy.numerics.mixed_dim.dof_manager module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.nonlinear.html">porepy.numerics.nonlinear package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.nonlinear.nonlinear_solvers.html">porepy.numerics.nonlinear.nonlinear_solvers module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.solvers.html">porepy.numerics.solvers package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.solvers.andersonacceleration.html">porepy.numerics.solvers.andersonacceleration module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.vem.html">porepy.numerics.vem package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.vem.dual_elliptic.html">porepy.numerics.vem.dual_elliptic module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.vem.hybrid.html">porepy.numerics.vem.hybrid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.vem.mass_matrix.html">porepy.numerics.vem.mass_matrix module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.vem.mvem.html">porepy.numerics.vem.mvem module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.vem.vem_source.html">porepy.numerics.vem.vem_source module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.discretization.html">porepy.numerics.discretization module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.displacement_correlation.html">porepy.numerics.displacement_correlation module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.linear_solvers.html">porepy.numerics.linear_solvers module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.time_step_control.html">porepy.numerics.time_step_control module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.html">porepy.params package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.bc.html">porepy.params.bc module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.data.html">porepy.params.data module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.fluid.html">porepy.params.fluid module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.parameter_dictionaries.html">porepy.params.parameter_dictionaries module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.rock.html">porepy.params.rock module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.tensor.html">porepy.params.tensor module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.html">porepy.utils package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.derived_discretizations.html">porepy.utils.derived_discretizations package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.derived_discretizations.implicit_euler.html">porepy.utils.derived_discretizations.implicit_euler module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.accumarray.html">porepy.utils.accumarray module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.adtree.html">porepy.utils.adtree module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.array_operations.html">porepy.utils.array_operations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.common_constants.html">porepy.utils.common_constants module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.default_domains.html">porepy.utils.default_domains module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.error.html">porepy.utils.error module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.graph.html">porepy.utils.graph module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.grid_utils.html">porepy.utils.grid_utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.interpolation_tables.html">porepy.utils.interpolation_tables module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.mcolon.html">porepy.utils.mcolon module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.permutations.html">porepy.utils.permutations module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.porepy_types.html">porepy.utils.porepy_types module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.setmembership.html">porepy.utils.setmembership module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.sort_points.html">porepy.utils.sort_points module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.tags.html">porepy.utils.tags module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.tangential_normal_projection.html">porepy.utils.tangential_normal_projection module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../docsrc/porepy/porepy.viz.html">porepy.viz package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.viz.data_saving_model_mixin.html">porepy.viz.data_saving_model_mixin module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.viz.exporter.html">porepy.viz.exporter module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.viz.fracture_visualization.html">porepy.viz.fracture_visualization module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.viz.plot_grid.html">porepy.viz.plot_grid module</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../docsrc/howto/howto-docstring.html">1. How to docstring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../docsrc/howto/howto-build-docs.html">2. How to build documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">PorePy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">porepy.numerics.fv.biot</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for porepy.numerics.fv.biot</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; Modules contains discretization of poro-elasticity by the multi-point stress</span>
<span class="sd">approximation.</span>

<span class="sd">The discretization scheme is described in</span>

<span class="sd">    J.M. Nordbotten (2016): STABLE CELL-CENTERED FINITE VOLUME DISCRETIZATION FOR BIOT</span>
<span class="sd">        EQUATIONS, SINUM.</span>

<span class="sd">The module contains four classes: Biot is the main class, responsible for discretization</span>
<span class="sd">of the poro-elastic system (relying heavily on its parent class pp.Mpsa). This is a</span>
<span class="sd">proper discretization class, in that it has discretize() and assemble_matrix_rhs()</span>
<span class="sd">methods.</span>

<span class="sd">The other classes, GradP, DivU and BiotStabilization, are containers for the other</span>
<span class="sd">terms in the poro-elasticity system. These have empty discretize() methods, and should</span>
<span class="sd">not be used directly.</span>

<span class="sd">Because of the number of variables and equations, and their somewhat difficult relation,</span>
<span class="sd">the most convenient way to set up a discretization for poro-elasticity is to use</span>
<span class="sd">pp.BiotContactMechanicsModel (designed for fractures and contact mechanics, but will</span>
<span class="sd">turn into a standard poro-elasticity equation for non-fractured domains).</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">time</span><span class="w"> </span><span class="kn">import</span> <span class="n">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.sparse</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sps</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">porepy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">porepy.numerics.discretization</span><span class="w"> </span><span class="kn">import</span> <span class="n">Discretization</span>

<span class="c1"># Module-wide logger</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="Biot">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.Biot">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Biot</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">Mpsa</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Discretization class for poro-elasticity, based on MPSA.</span>

<span class="sd">    This is a subclass of pp.Mpsa()</span>

<span class="sd">    Attributes:</span>
<span class="sd">        mechanics_keyword (str): Keyword used to identify the parameter dictionary</span>
<span class="sd">            associated with the mechanics subproblem. Defaults to &quot;mechanics&quot;.</span>
<span class="sd">        flow_keyword (str): Keyword used to identify the parameter dictionary</span>
<span class="sd">            associated with the flow subproblem. Defaults to &quot;flow&quot;.</span>
<span class="sd">        vector_variable (str): Name for the vector variable, used throughout the</span>
<span class="sd">            discretization and solution. Defaults to &quot;displacement&quot;.</span>
<span class="sd">        scalar_variable (str): Name for the vector variable, used throughout the</span>
<span class="sd">            discretization and solution. Defaults to &quot;pressure&quot;.</span>
<span class="sd">        div_u_matrix_key (str): Keyword used to identify the discretization matrix of</span>
<span class="sd">            the term div(u). Defaults to &quot;div_u&quot;.</span>
<span class="sd">        bound_div_u_matrix_key (str): Keyword used to identify the discretization matrix</span>
<span class="sd">            of the boundary condition for the term div(u). Defaults to &quot;bound_div_u&quot;.</span>
<span class="sd">        grad_p_matrix_key (str): Keyword used to identify the discretization matrix of</span>
<span class="sd">            the term grad(p). Defaults to &quot;grad_p&quot;.</span>
<span class="sd">        stabilization_matrix_key (str): Keyword used to identify the discretization</span>
<span class="sd">            matrix for the stabilization term. Defaults to &quot;biot_stabilization&quot;.</span>
<span class="sd">        bound_pressure_matrix_key (str): Keyword used to identify the discretization</span>
<span class="sd">            matrix for the pressure contribution to boundary displacement reconstruction.</span>
<span class="sd">            Defaults to &quot;bound_displacement_pressure&quot;.</span>

<span class="sd">    See also pp.Mpsa for further attributes.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mechanics_keyword</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mechanics&quot;</span><span class="p">,</span>
        <span class="n">flow_keyword</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;flow&quot;</span><span class="p">,</span>
        <span class="n">vector_variable</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;displacement&quot;</span><span class="p">,</span>
        <span class="n">scalar_variable</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pressure&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the two keywords.</span>

<span class="sd">        The keywords are used to access and store parameters and discretization</span>
<span class="sd">        matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_keyword</span> <span class="o">=</span> <span class="n">mechanics_keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_keyword</span> <span class="o">=</span> <span class="n">flow_keyword</span>
        <span class="c1"># Set variable names for the vector and scalar variable, used to access</span>
        <span class="c1"># solutions from previous time steps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vector_variable</span> <span class="o">=</span> <span class="n">vector_variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scalar_variable</span> <span class="o">=</span> <span class="n">scalar_variable</span>

        <span class="c1"># Strings used to identify discretization matrices for various terms constructed</span>
        <span class="c1"># by this class. Hardcoded here to enforce a common standard.</span>
        <span class="c1"># Since these keys are used also for discretizations of other terms in Biot</span>
        <span class="c1"># (GradP, DivU), the keys should perhaps have been module level constants,</span>
        <span class="c1"># but this would have broken with the system in other discretizaitons.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">div_u_matrix_key</span> <span class="o">=</span> <span class="s2">&quot;div_u&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bound_div_u_matrix_key</span> <span class="o">=</span> <span class="s2">&quot;bound_div_u&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grad_p_matrix_key</span> <span class="o">=</span> <span class="s2">&quot;grad_p&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stabilization_matrix_key</span> <span class="o">=</span> <span class="s2">&quot;biot_stabilization&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bound_pressure_matrix_key</span> <span class="o">=</span> <span class="s2">&quot;bound_displacement_pressure&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mass_matrix_key</span> <span class="o">=</span> <span class="s2">&quot;mass&quot;</span>

<div class="viewcode-block" id="Biot.ndof">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.Biot.ndof">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ndof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of degrees of freedom associated to the method.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): A grid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The number of degrees of freedom.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span></div>


<div class="viewcode-block" id="Biot.assemble_matrix_rhs">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.Biot.assemble_matrix_rhs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_matrix_rhs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method inherited from superclass should not be used.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): Grid to be discretized.</span>
<span class="sd">            sd_data (dict): Data dictionary for this grid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            scipy.sparse.csr_matrix: System matrix of this discretization. The size of</span>
<span class="sd">                the matrix will depend on the specific discretization.</span>
<span class="sd">            np.ndarray: Right-hand side vector with representation of boundary</span>
<span class="sd">                conditions. The size of the vector will depend on the discretization.</span>

<span class="sd">        Raises:</span>
<span class="sd">            NotImplementedError: If invoked. The method is included to be compatible</span>
<span class="sd">                with the wider discretization class, but assembly should be handled</span>
<span class="sd">                by the ContactMechanicsBiot class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;This class cannot be used for assembly.</span>
<span class="sd">    Use the ContactMechanicsBiot class instead.&quot;&quot;&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Biot.assemble_rhs">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.Biot.assemble_rhs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the right-hand side for a poro-elastic system.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): Grid to be discretized.</span>
<span class="sd">            sd_data (dict): Data dictionary for this grid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Right hand side vector with representation of boundary</span>
<span class="sd">                conditions. The size of the vector will depend on the discretization.</span>

<span class="sd">        Raises:</span>
<span class="sd">            NotImplementedError: If invoked. The method is included to be compatible</span>
<span class="sd">                with the wider discretization class, but assembly should be handled</span>
<span class="sd">                by the ContactMechanicsBiot class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;This class cannot be used for assembly.</span>
<span class="sd">    Use the ContactMechanicsBiot class instead.&quot;&quot;&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Biot.assemble_matrix">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.Biot.assemble_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assemble the poro-elastic system matrix.</span>

<span class="sd">        The discretization is presumed stored in the data dictionary.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): Grid for discretization</span>
<span class="sd">            sd_data (dictionary): Data for discretization, as well as matrices</span>
<span class="sd">                with discretization of the sub-parts of the system.</span>

<span class="sd">        Returns:</span>
<span class="sd">            scipy.sparse.bmat: Block matrix with the combined MPSA/MPFA</span>
<span class="sd">                discretization.</span>

<span class="sd">        Raises:</span>
<span class="sd">            NotImplementedError: If invoked. The method is included to be compatible</span>
<span class="sd">                with the wider discretization class, but assembly should be handled</span>
<span class="sd">                by the ContactMechanicsBiot class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;This class cannot be used for assembly.</span>
<span class="sd">    Use the ContactMechanicsBiot class instead.&quot;&quot;&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Biot.update_discretization">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.Biot.update_discretization">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_discretization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update discretization.</span>

<span class="sd">        The updates can generally come as a combination of two forms:</span>
<span class="sd">            1) The discretization on part of the grid should be recomputed.</span>
<span class="sd">            2) The old discretization can be used (in parts of the grid), but the</span>
<span class="sd">               numbering of unknowns has changed, and the discretization should be</span>
<span class="sd">               reordered accordingly.</span>

<span class="sd">        Information on the basis for the update should be stored in a field</span>

<span class="sd">            sd_data[&#39;update_discretization&#39;]</span>

<span class="sd">        This should be a dictionary which could contain keys:</span>

<span class="sd">            modified_cells, modified_faces</span>


<span class="sd">        define cells, faces and nodes that have been modified (either parameters,</span>
<span class="sd">        geometry or topology), and should be rediscretized. It is up to the</span>
<span class="sd">        discretization method to implement the change necessary by this modification.</span>
<span class="sd">        Note that depending on the computational stencil of the discretization method,</span>
<span class="sd">        a grid quantity may be rediscretized even if it is not marked as modified.</span>

<span class="sd">        The dictionary sd_data[&#39;update_discretization&#39;] should further have keys:</span>

<span class="sd">            cell_index_map, face_index_map</span>

<span class="sd">        these should specify sparse matrices that map old to new indices. If not</span>
<span class="sd">        provided, the cell and face bookkeeping will be assumed constant.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): Grid to be rediscretized.</span>
<span class="sd">            sd_data (dictionary): With discretization parameters.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If neither cells nor faces have been modified, we should not start the update</span>
        <span class="c1"># procedure (it will result in a key error towards the end of this function - it</span>
        <span class="c1"># is technical). If no updates, we shortcut the method</span>
        <span class="n">update_info</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="s2">&quot;update_discretization&quot;</span><span class="p">]</span>
        <span class="c1"># By default, neither cells nor faces have been updated</span>
        <span class="n">update_cells</span> <span class="o">=</span> <span class="n">update_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;modified_cells&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">update_faces</span> <span class="o">=</span> <span class="n">update_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;modified_faces&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">update_cells</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">update_faces</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># The implementation is quite a bit more involved than the corresponding methods</span>
        <span class="c1"># for mpfa and mpsa, due to the multi-physics structure of the discretization.</span>

        <span class="c1"># Matrices computed by self._discretized_mech, but associtated with self.flow_keyword.</span>
        <span class="c1"># These are moved to the self.mechanics_keyword matrix dictionary, and will then be</span>
        <span class="c1"># moved back again at the end of this function</span>
        <span class="n">mech_in_flow</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">div_u_matrix_key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bound_div_u_matrix_key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stabilization_matrix_key</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mech_in_flow</span><span class="p">:</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION_MATRICES</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_keyword</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION_MATRICES</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">mechanics_keyword</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span>

        <span class="c1"># Dump discretization of mass term - this will be fully rediscretized below</span>
        <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION_MATRICES</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_keyword</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mass_matrix_key</span><span class="p">,</span> <span class="kc">None</span>
        <span class="p">)</span>

        <span class="c1"># Define which of the matrices should be considered cell and face quantities,</span>
        <span class="c1"># vector and scalar.</span>
        <span class="n">scalar_cell_right</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grad_p_matrix_key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stabilization_matrix_key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bound_pressure_matrix_key</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">vector_cell_right</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stress_matrix_key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bound_displacment_cell_matrix_key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">div_u_matrix_key</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">vector_face_right</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bound_stress_matrix_key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bound_displacment_face_matrix_key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bound_div_u_matrix_key</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="n">scalar_cell_left</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">div_u_matrix_key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stabilization_matrix_key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bound_div_u_matrix_key</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="n">vector_face_left</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stress_matrix_key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grad_p_matrix_key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bound_stress_matrix_key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bound_displacment_cell_matrix_key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bound_displacment_face_matrix_key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bound_pressure_matrix_key</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="c1"># Update discretization. As part of the process, the mech_in_flow matrices</span>
        <span class="c1"># are moved back to the flow matrix dictionary.</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">partial_update_discretization</span><span class="p">(</span>
            <span class="n">sd</span><span class="p">,</span>
            <span class="n">sd_data</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_keyword</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">discretize</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="n">sd</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span>
            <span class="n">scalar_cell_right</span><span class="o">=</span><span class="n">scalar_cell_right</span><span class="p">,</span>
            <span class="n">vector_cell_right</span><span class="o">=</span><span class="n">vector_cell_right</span><span class="p">,</span>
            <span class="n">vector_face_right</span><span class="o">=</span><span class="n">vector_face_right</span><span class="p">,</span>
            <span class="n">vector_face_left</span><span class="o">=</span><span class="n">vector_face_left</span><span class="p">,</span>
            <span class="n">scalar_cell_left</span><span class="o">=</span><span class="n">scalar_cell_left</span><span class="p">,</span>
            <span class="n">second_keyword</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_keyword</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Remove the mech_in_flow matrices from the mechanics dictionary</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mech_in_flow</span><span class="p">:</span>
            <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION_MATRICES</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">mechanics_keyword</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="Biot.discretize">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.Biot.discretize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">discretize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Discretize the mechanics terms in a poromechanical system.</span>

<span class="sd">        NOTE: This function does *not* discretize purely flow-related terms (Darcy flow</span>
<span class="sd">        and compressibility).</span>

<span class="sd">        The parameters needed for the discretization are stored in the</span>
<span class="sd">        dictionary sd_data, which should contain the following mandatory keywords:</span>

<span class="sd">            Related to mechanics equation (in sd_data[pp.PARAMETERS][self.mechanics_keyword]):</span>
<span class="sd">                fourth_order_tensor: Fourth order tensor representing elastic moduli.</span>
<span class="sd">                bc: BoundaryCondition object for mechanics equation.</span>
<span class="sd">                    Used in mpsa.</span>

<span class="sd">        In addition, the following parameters are optional:</span>
<span class="sd">            Related to coupling terms:</span>
<span class="sd">                biot_alpha (double between 0 and 1): Biot&#39;s coefficient.</span>
<span class="sd">                    Defaults to 1.</span>

<span class="sd">            Related to numerics:</span>
<span class="sd">                inverter (str): Which method to use for block inversion. See</span>
<span class="sd">                    pp.fvutils.invert_diagonal_blocks for detail, and for default</span>
<span class="sd">                    options.</span>
<span class="sd">                mpfa_eta (double): Location of continuity point in MPSA.</span>
<span class="sd">                    Defaults to 1/3 for simplex grids, 0 otherwise.</span>

<span class="sd">        The discretization is stored in the data dictionary, in the form of</span>
<span class="sd">        several matrices representing different coupling terms. For details,</span>
<span class="sd">        and how to combine these, see self.assemble_matrix()</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): Grid to be discretized.</span>
<span class="sd">            sd_data (dictionary): Containing data for discretization. See above</span>
<span class="sd">                for specification.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parameter_dictionary</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PARAMETERS</span><span class="p">][</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_keyword</span>
        <span class="p">]</span>
        <span class="n">matrices_m</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">]</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION_MATRICES</span><span class="p">][</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_keyword</span>
        <span class="p">]</span>
        <span class="n">matrices_f</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">]</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION_MATRICES</span><span class="p">][</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flow_keyword</span>
        <span class="p">]</span>
        <span class="n">bound</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">BoundaryConditionVectorial</span> <span class="o">=</span> <span class="n">parameter_dictionary</span><span class="p">[</span><span class="s2">&quot;bc&quot;</span><span class="p">]</span>
        <span class="n">constit</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">FourthOrderTensor</span> <span class="o">=</span> <span class="n">parameter_dictionary</span><span class="p">[</span><span class="s2">&quot;fourth_order_tensor&quot;</span><span class="p">]</span>

        <span class="n">eta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">parameter_dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mpsa_eta&quot;</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">determine_eta</span><span class="p">(</span><span class="n">sd</span><span class="p">))</span>
        <span class="n">inverter</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;python&quot;</span><span class="p">,</span> <span class="s2">&quot;numba&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameter_dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;inverter&quot;</span><span class="p">,</span> <span class="s2">&quot;numba&quot;</span>
        <span class="p">)</span>

        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">parameter_dictionary</span><span class="p">[</span><span class="s2">&quot;biot_alpha&quot;</span><span class="p">]</span>

        <span class="n">max_memory</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">parameter_dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_memory&quot;</span><span class="p">,</span> <span class="mf">1e9</span><span class="p">)</span>

        <span class="c1"># Whether to update an existing discretization, or construct a new one.</span>
        <span class="c1"># If True, either specified_cells, _faces or _nodes should also be given, or</span>
        <span class="c1"># else a full new discretization will be computed</span>
        <span class="n">update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">parameter_dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;update_discretization&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># The discretization can be limited to a specified set of cells, faces or nodes</span>
        <span class="c1"># If none of these are specified, the entire grid will be discretized.</span>
        <span class="c1"># NOTE: active_faces are all faces to have their stencils updated, while</span>
        <span class="c1"># active_cells may form a larger set (to accurately update all faces on a</span>
        <span class="c1"># subgrid, it is necessary to assign some overlap in terms cells).</span>
        <span class="n">active_cells</span><span class="p">,</span> <span class="n">active_faces</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">find_active_indices</span><span class="p">(</span>
            <span class="n">parameter_dictionary</span><span class="p">,</span> <span class="n">sd</span>
        <span class="p">)</span>

        <span class="c1"># Extract a grid, and get global indices of its active faces and nodes</span>
        <span class="n">active_grid</span><span class="p">,</span> <span class="n">extracted_faces</span><span class="p">,</span> <span class="n">extracted_nodes</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">extract_subgrid</span><span class="p">(</span>
            <span class="n">sd</span><span class="p">,</span> <span class="n">active_cells</span>
        <span class="p">)</span>
        <span class="c1"># Constitutive law and boundary condition for the active grid</span>
        <span class="n">active_constit</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">FourthOrderTensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constit_for_subgrid</span><span class="p">(</span>
            <span class="n">constit</span><span class="p">,</span> <span class="n">active_cells</span>
        <span class="p">)</span>

        <span class="c1"># Extract the relevant part of the boundary condition</span>
        <span class="n">active_bound</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">BoundaryConditionVectorial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bc_for_subgrid</span><span class="p">(</span>
            <span class="n">bound</span><span class="p">,</span> <span class="n">active_grid</span><span class="p">,</span> <span class="n">extracted_faces</span>
        <span class="p">)</span>

        <span class="c1"># Initialize matrices to store discretization</span>
        <span class="n">nd</span> <span class="o">=</span> <span class="n">active_grid</span><span class="o">.</span><span class="n">dim</span>
        <span class="n">nf</span> <span class="o">=</span> <span class="n">active_grid</span><span class="o">.</span><span class="n">num_faces</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="n">active_grid</span><span class="o">.</span><span class="n">num_cells</span>

        <span class="c1"># There are quite a few items to keep track of, but then the discretization</span>
        <span class="c1"># does quite a few different things</span>
        <span class="n">active_stress</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">nf</span> <span class="o">*</span> <span class="n">nd</span><span class="p">,</span> <span class="n">nc</span> <span class="o">*</span> <span class="n">nd</span><span class="p">))</span>
        <span class="n">active_bound_stress</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">nf</span> <span class="o">*</span> <span class="n">nd</span><span class="p">,</span> <span class="n">nf</span> <span class="o">*</span> <span class="n">nd</span><span class="p">))</span>
        <span class="n">active_grad_p</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">nf</span> <span class="o">*</span> <span class="n">nd</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>
        <span class="n">active_div_u</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span> <span class="o">*</span> <span class="n">nd</span><span class="p">))</span>
        <span class="n">active_bound_div_u</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">nc</span><span class="p">,</span> <span class="n">nf</span> <span class="o">*</span> <span class="n">nd</span><span class="p">))</span>
        <span class="n">active_stabilization</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">nc</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>
        <span class="n">active_bound_displacement_cell</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">nf</span> <span class="o">*</span> <span class="n">nd</span><span class="p">,</span> <span class="n">nc</span> <span class="o">*</span> <span class="n">nd</span><span class="p">))</span>
        <span class="n">active_bound_displacement_face</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">nf</span> <span class="o">*</span> <span class="n">nd</span><span class="p">,</span> <span class="n">nf</span> <span class="o">*</span> <span class="n">nd</span><span class="p">))</span>
        <span class="n">active_bound_displacement_pressure</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">nf</span> <span class="o">*</span> <span class="n">nd</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>

        <span class="c1"># Find an estimate of the peak memory need</span>
        <span class="n">peak_memory_estimate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_peak_memory_mpsa</span><span class="p">(</span><span class="n">active_grid</span><span class="p">)</span>

        <span class="c1"># Loop over all partition regions, construct local problems, and transfer</span>
        <span class="c1"># discretization to the entire active grid</span>
        <span class="k">for</span> <span class="p">(</span>
            <span class="n">reg_i</span><span class="p">,</span>
            <span class="p">(</span><span class="n">sub_sd</span><span class="p">,</span> <span class="n">faces_in_subgrid</span><span class="p">,</span> <span class="n">cells_in_subgrid</span><span class="p">,</span> <span class="n">l2g_cells</span><span class="p">,</span> <span class="n">l2g_faces</span><span class="p">),</span>
        <span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">subproblems</span><span class="p">(</span><span class="n">active_grid</span><span class="p">,</span> <span class="n">max_memory</span><span class="p">,</span> <span class="n">peak_memory_estimate</span><span class="p">)</span>
        <span class="p">):</span>

            <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
            <span class="c1"># Copy stiffness tensor, and restrict to local cells</span>
            <span class="n">loc_c</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">FourthOrderTensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constit_for_subgrid</span><span class="p">(</span>
                <span class="n">active_constit</span><span class="p">,</span> <span class="n">l2g_cells</span>
            <span class="p">)</span>

            <span class="c1"># Boundary conditions are slightly more complex. Find local faces</span>
            <span class="c1"># that are on the global boundary.</span>
            <span class="c1"># Then transfer boundary condition on those faces.</span>
            <span class="n">loc_bnd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">BoundaryConditionVectorial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bc_for_subgrid</span><span class="p">(</span>
                <span class="n">active_bound</span><span class="p">,</span> <span class="n">sub_sd</span><span class="p">,</span> <span class="n">l2g_faces</span>
            <span class="p">)</span>

            <span class="c1"># Discretization of sub-problem</span>
            <span class="p">(</span>
                <span class="n">loc_stress</span><span class="p">,</span>
                <span class="n">loc_bound_stress</span><span class="p">,</span>
                <span class="n">loc_div_u</span><span class="p">,</span>
                <span class="n">loc_bound_div_u</span><span class="p">,</span>
                <span class="n">loc_grad_p</span><span class="p">,</span>
                <span class="n">loc_biot_stab</span><span class="p">,</span>
                <span class="n">loc_bound_displacement_cell</span><span class="p">,</span>
                <span class="n">loc_bound_displacement_face</span><span class="p">,</span>
                <span class="n">loc_bound_displacement_pressure</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_discretization</span><span class="p">(</span>
                <span class="n">sub_sd</span><span class="p">,</span> <span class="n">loc_c</span><span class="p">,</span> <span class="n">loc_bnd</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="n">eta</span><span class="p">,</span> <span class="n">inverter</span><span class="o">=</span><span class="n">inverter</span>
            <span class="p">)</span>

            <span class="c1"># Eliminate contribution from faces already discretized (the dual grids /</span>
            <span class="c1"># interaction regions may be structured so that some faces have previously</span>
            <span class="c1"># been partially discretized even if it has not been their turn until now)</span>
            <span class="n">eliminate_face</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">l2g_faces</span><span class="p">,</span> <span class="n">faces_in_subgrid</span><span class="p">))</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">remove_nonlocal_contribution</span><span class="p">(</span>
                <span class="n">eliminate_face</span><span class="p">,</span>
                <span class="n">sd</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span>
                <span class="n">loc_stress</span><span class="p">,</span>
                <span class="n">loc_bound_stress</span><span class="p">,</span>
                <span class="n">loc_bound_displacement_cell</span><span class="p">,</span>
                <span class="n">loc_bound_displacement_face</span><span class="p">,</span>
                <span class="n">loc_grad_p</span><span class="p">,</span>
                <span class="n">loc_bound_displacement_pressure</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">eliminate_cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">l2g_cells</span><span class="p">,</span> <span class="n">cells_in_subgrid</span><span class="p">))</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">remove_nonlocal_contribution</span><span class="p">(</span>
                <span class="n">eliminate_cell</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">loc_div_u</span><span class="p">,</span> <span class="n">loc_bound_div_u</span><span class="p">,</span> <span class="n">loc_biot_stab</span>
            <span class="p">)</span>

            <span class="c1"># Next, transfer discretization matrices from the local to the active grid</span>
            <span class="c1"># Get a mapping from the local to the active grid</span>
            <span class="n">face_map_vec</span><span class="p">,</span> <span class="n">cell_map_vec</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">map_subgrid_to_grid</span><span class="p">(</span>
                <span class="n">active_grid</span><span class="p">,</span> <span class="n">l2g_faces</span><span class="p">,</span> <span class="n">l2g_cells</span><span class="p">,</span> <span class="n">is_vector</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">face_map_scalar</span><span class="p">,</span> <span class="n">cell_map_scalar</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">map_subgrid_to_grid</span><span class="p">(</span>
                <span class="n">active_grid</span><span class="p">,</span> <span class="n">l2g_faces</span><span class="p">,</span> <span class="n">l2g_cells</span><span class="p">,</span> <span class="n">is_vector</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

            <span class="c1"># Update discretization on the active grid.</span>
            <span class="n">active_stress</span> <span class="o">+=</span> <span class="n">face_map_vec</span> <span class="o">*</span> <span class="n">loc_stress</span> <span class="o">*</span> <span class="n">cell_map_vec</span>
            <span class="n">active_bound_stress</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">face_map_vec</span> <span class="o">*</span> <span class="n">loc_bound_stress</span> <span class="o">*</span> <span class="n">face_map_vec</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="p">)</span>

            <span class="c1"># Update global face fields.</span>
            <span class="n">active_bound_displacement_cell</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">face_map_vec</span> <span class="o">*</span> <span class="n">loc_bound_displacement_cell</span> <span class="o">*</span> <span class="n">cell_map_vec</span>
            <span class="p">)</span>
            <span class="n">active_bound_displacement_face</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">face_map_vec</span> <span class="o">*</span> <span class="n">loc_bound_displacement_face</span> <span class="o">*</span> <span class="n">face_map_vec</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="p">)</span>

            <span class="n">active_stabilization</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">cell_map_scalar</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">loc_biot_stab</span> <span class="o">*</span> <span class="n">cell_map_scalar</span>
            <span class="p">)</span>

            <span class="n">active_grad_p</span> <span class="o">+=</span> <span class="n">face_map_vec</span> <span class="o">*</span> <span class="n">loc_grad_p</span> <span class="o">*</span> <span class="n">cell_map_scalar</span>
            <span class="n">active_div_u</span> <span class="o">+=</span> <span class="n">cell_map_scalar</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">loc_div_u</span> <span class="o">*</span> <span class="n">cell_map_vec</span>
            <span class="n">active_bound_div_u</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">cell_map_scalar</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">loc_bound_div_u</span> <span class="o">*</span> <span class="n">face_map_vec</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="p">)</span>

            <span class="n">active_bound_displacement_pressure</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">face_map_vec</span> <span class="o">*</span> <span class="n">loc_bound_displacement_pressure</span> <span class="o">*</span> <span class="n">cell_map_scalar</span>
            <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Done with subproblem </span><span class="si">{</span><span class="n">reg_i</span><span class="si">}</span><span class="s2">. Elapsed time </span><span class="si">{</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">tic</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Done with this subdomain, move on to the next one</span>

        <span class="c1"># We are done with the discretization. What remains is to map the computed</span>
        <span class="c1"># matrices back from the active grid to the full one.</span>
        <span class="n">face_map_vec</span><span class="p">,</span> <span class="n">cell_map_vec</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">map_subgrid_to_grid</span><span class="p">(</span>
            <span class="n">sd</span><span class="p">,</span> <span class="n">extracted_faces</span><span class="p">,</span> <span class="n">active_cells</span><span class="p">,</span> <span class="n">is_vector</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">face_map_scalar</span><span class="p">,</span> <span class="n">cell_map_scalar</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">map_subgrid_to_grid</span><span class="p">(</span>
            <span class="n">sd</span><span class="p">,</span> <span class="n">extracted_faces</span><span class="p">,</span> <span class="n">active_cells</span><span class="p">,</span> <span class="n">is_vector</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="n">stress</span> <span class="o">=</span> <span class="n">face_map_vec</span> <span class="o">*</span> <span class="n">active_stress</span> <span class="o">*</span> <span class="n">cell_map_vec</span>
        <span class="n">bound_stress</span> <span class="o">=</span> <span class="n">face_map_vec</span> <span class="o">*</span> <span class="n">active_bound_stress</span> <span class="o">*</span> <span class="n">face_map_vec</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="c1"># Update global face fields.</span>
        <span class="n">bound_displacement_cell</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">face_map_vec</span> <span class="o">*</span> <span class="n">active_bound_displacement_cell</span> <span class="o">*</span> <span class="n">cell_map_vec</span>
        <span class="p">)</span>
        <span class="n">bound_displacement_face</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">face_map_vec</span> <span class="o">*</span> <span class="n">active_bound_displacement_face</span> <span class="o">*</span> <span class="n">face_map_vec</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="n">stabilization</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">cell_map_scalar</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">active_stabilization</span> <span class="o">*</span> <span class="n">cell_map_scalar</span>
        <span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

        <span class="n">grad_p</span> <span class="o">=</span> <span class="n">face_map_vec</span> <span class="o">*</span> <span class="n">active_grad_p</span> <span class="o">*</span> <span class="n">cell_map_scalar</span>
        <span class="n">div_u</span> <span class="o">=</span> <span class="p">(</span><span class="n">cell_map_scalar</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">active_div_u</span> <span class="o">*</span> <span class="n">cell_map_vec</span><span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="n">bound_div_u</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">cell_map_scalar</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">active_bound_div_u</span> <span class="o">*</span> <span class="n">face_map_vec</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

        <span class="n">bound_displacement_pressure</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">face_map_vec</span> <span class="o">*</span> <span class="n">active_bound_displacement_pressure</span> <span class="o">*</span> <span class="n">cell_map_scalar</span>
        <span class="p">)</span>

        <span class="c1"># Eliminate any contributions not associated with the active grid</span>
        <span class="n">eliminate_faces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">num_faces</span><span class="p">),</span> <span class="n">active_faces</span><span class="p">)</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">remove_nonlocal_contribution</span><span class="p">(</span>
            <span class="n">eliminate_faces</span><span class="p">,</span>
            <span class="n">sd</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span>
            <span class="n">stress</span><span class="p">,</span>
            <span class="n">bound_stress</span><span class="p">,</span>
            <span class="n">bound_displacement_cell</span><span class="p">,</span>
            <span class="n">bound_displacement_face</span><span class="p">,</span>
            <span class="n">grad_p</span><span class="p">,</span>
            <span class="n">bound_displacement_pressure</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Cells to be updated is a bit more involved. Best guess now is to update</span>
        <span class="c1"># all cells that have had one of its faces updated. This may not be correct for</span>
        <span class="c1"># general combinations of specified cells, nodes and faces.</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">cell_faces</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">af_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">num_faces</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">af_vec</span><span class="p">[</span><span class="n">active_faces</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">update_cell_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tmp</span> <span class="o">*</span> <span class="n">af_vec</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">eliminate_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">),</span> <span class="n">update_cell_ind</span><span class="p">)</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">remove_nonlocal_contribution</span><span class="p">(</span>
            <span class="n">eliminate_cells</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">div_u</span><span class="p">,</span> <span class="n">bound_div_u</span><span class="p">,</span> <span class="n">stabilization</span>
        <span class="p">)</span>

        <span class="c1"># Either update the discretization scheme, or store the full one</span>
        <span class="k">if</span> <span class="n">update</span><span class="p">:</span>
            <span class="c1"># The faces to be updated are given by active_faces</span>
            <span class="n">update_face_ind</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">expand_indices_nd</span><span class="p">(</span><span class="n">active_faces</span><span class="p">,</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>

            <span class="n">matrices_m</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stress_matrix_key</span><span class="p">][</span><span class="n">update_face_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">stress</span><span class="p">[</span>
                <span class="n">update_face_ind</span>
            <span class="p">]</span>
            <span class="n">matrices_m</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bound_stress_matrix_key</span><span class="p">][</span><span class="n">update_face_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">bound_stress</span><span class="p">[</span>
                <span class="n">update_face_ind</span>
            <span class="p">]</span>
            <span class="n">matrices_f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">div_u_matrix_key</span><span class="p">][</span><span class="n">update_cell_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">div_u</span><span class="p">[</span><span class="n">update_cell_ind</span><span class="p">]</span>
            <span class="n">matrices_f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bound_div_u_matrix_key</span><span class="p">][</span><span class="n">update_cell_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">bound_div_u</span><span class="p">[</span>
                <span class="n">update_cell_ind</span>
            <span class="p">]</span>
            <span class="n">matrices_m</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">grad_p_matrix_key</span><span class="p">][</span><span class="n">update_face_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">grad_p</span><span class="p">[</span>
                <span class="n">update_face_ind</span>
            <span class="p">]</span>
            <span class="n">matrices_f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stabilization_matrix_key</span><span class="p">][</span><span class="n">update_cell_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">stabilization</span><span class="p">[</span>
                <span class="n">update_cell_ind</span>
            <span class="p">]</span>
            <span class="n">matrices_m</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bound_displacment_cell_matrix_key</span><span class="p">][</span>
                <span class="n">update_face_ind</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">bound_displacement_cell</span><span class="p">[</span><span class="n">update_face_ind</span><span class="p">]</span>
            <span class="n">matrices_m</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bound_displacment_face_matrix_key</span><span class="p">][</span>
                <span class="n">update_face_ind</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">bound_displacement_face</span><span class="p">[</span><span class="n">update_face_ind</span><span class="p">]</span>
            <span class="n">matrices_m</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bound_pressure_matrix_key</span><span class="p">][</span>
                <span class="n">update_face_ind</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">bound_displacement_pressure</span><span class="p">[</span><span class="n">update_face_ind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">matrices_m</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stress_matrix_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">stress</span>
            <span class="n">matrices_m</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bound_stress_matrix_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">bound_stress</span>
            <span class="n">matrices_m</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">grad_p_matrix_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">grad_p</span>
            <span class="n">matrices_m</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bound_displacment_cell_matrix_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">bound_displacement_cell</span>
            <span class="n">matrices_m</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bound_displacment_face_matrix_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">bound_displacement_face</span>
            <span class="n">matrices_m</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bound_pressure_matrix_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">bound_displacement_pressure</span>

            <span class="n">matrices_f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">div_u_matrix_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">div_u</span>
            <span class="n">matrices_f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bound_div_u_matrix_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">bound_div_u</span>
            <span class="n">matrices_f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stabilization_matrix_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">stabilization</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_local_discretization</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span>
        <span class="n">constit</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">FourthOrderTensor</span><span class="p">,</span>
        <span class="n">bound_mech</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">BoundaryConditionVectorial</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">eta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">inverter</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;python&quot;</span><span class="p">,</span> <span class="s2">&quot;numba&quot;</span><span class="p">],</span>
        <span class="n">hf_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span>
        <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span>
        <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span>
        <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span>
        <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span>
        <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span>
        <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span>
        <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span>
        <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Discretization of poro-elastic system.&quot;&quot;&quot;</span>

        <span class="c1"># The grid coordinates are always three-dimensional, even if the grid</span>
        <span class="c1"># is really 2D. This means that there is not a 1-1 relation between the</span>
        <span class="c1"># number of coordinates of a point / vector and the real dimension.</span>
        <span class="c1"># This again violates some assumptions tacitly made in the</span>
        <span class="c1"># discretization (in particular that the number of faces of a cell that</span>
        <span class="c1"># meets in a vertex equals the grid dimension, and that this can be</span>
        <span class="c1"># used to construct an index of local variables in the discretization).</span>
        <span class="c1"># These issues should be possible to overcome, but for the moment, we</span>
        <span class="c1"># simply force 2D grids to be proper 2D.</span>
        <span class="k">if</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">sd</span><span class="p">,</span> <span class="n">constit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_grid_constit_2d</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">constit</span><span class="p">)</span>

        <span class="n">nd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span>

        <span class="c1"># Define subcell topology</span>
        <span class="n">subcell_topology</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">SubcellTopology</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span>
        <span class="c1"># The boundary conditions must be given on the subfaces</span>
        <span class="k">if</span> <span class="n">bound_mech</span><span class="o">.</span><span class="n">num_faces</span> <span class="o">==</span> <span class="n">subcell_topology</span><span class="o">.</span><span class="n">num_subfno_unique</span><span class="p">:</span>
            <span class="n">subface_rhs</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If they are given on the faces, expand the boundary conditions</span>
            <span class="n">bound_mech</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">boundary_to_sub_boundary</span><span class="p">(</span>
                <span class="n">bound_mech</span><span class="p">,</span> <span class="n">subcell_topology</span>
            <span class="p">)</span>
            <span class="n">subface_rhs</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Obtain mappings to exclude boundary faces for mechanics</span>
        <span class="n">bound_exclusion_mech</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">ExcludeBoundaries</span><span class="p">(</span>
            <span class="n">subcell_topology</span><span class="p">,</span> <span class="n">bound_mech</span><span class="p">,</span> <span class="n">nd</span>
        <span class="p">)</span>

        <span class="c1"># Call core part of MPSA</span>
        <span class="n">hook</span><span class="p">,</span> <span class="n">igrad</span><span class="p">,</span> <span class="n">cell_node_blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_inverse_gradient_matrix</span><span class="p">(</span>
            <span class="n">sd</span><span class="p">,</span> <span class="n">constit</span><span class="p">,</span> <span class="n">subcell_topology</span><span class="p">,</span> <span class="n">bound_exclusion_mech</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">inverter</span>
        <span class="p">)</span>
        <span class="n">num_sub_cells</span> <span class="o">=</span> <span class="n">cell_node_blocks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Right-hand side terms for the stress discretization</span>
        <span class="n">rhs_cells</span><span class="p">:</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_rhs_cell_center</span><span class="p">(</span>
            <span class="n">sd</span><span class="p">,</span> <span class="n">subcell_topology</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">num_sub_cells</span><span class="p">,</span> <span class="n">bound_exclusion_mech</span>
        <span class="p">)</span>

        <span class="c1"># Stress discretization</span>
        <span class="n">stress</span> <span class="o">=</span> <span class="n">hook</span> <span class="o">*</span> <span class="n">igrad</span> <span class="o">*</span> <span class="n">rhs_cells</span>

        <span class="c1"># Right-hand side for boundary discretization</span>
        <span class="n">rhs_bound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_bound_rhs</span><span class="p">(</span>
            <span class="n">bound_mech</span><span class="p">,</span> <span class="n">bound_exclusion_mech</span><span class="p">,</span> <span class="n">subcell_topology</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">subface_rhs</span>
        <span class="p">)</span>
        <span class="c1"># Discretization of boundary values</span>
        <span class="n">bound_stress</span> <span class="o">=</span> <span class="n">hook</span> <span class="o">*</span> <span class="n">igrad</span> <span class="o">*</span> <span class="n">rhs_bound</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">hf_output</span><span class="p">:</span>
            <span class="c1"># If the boundary condition is given for faces we return the discretization</span>
            <span class="c1"># on for the face values. Otherwise, it is defined for the subfaces.</span>
            <span class="n">hf2f</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">map_hf_2_f</span><span class="p">(</span>
                <span class="n">subcell_topology</span><span class="o">.</span><span class="n">fno_unique</span><span class="p">,</span> <span class="n">subcell_topology</span><span class="o">.</span><span class="n">subfno_unique</span><span class="p">,</span> <span class="n">nd</span>
            <span class="p">)</span>
            <span class="n">bound_stress</span> <span class="o">=</span> <span class="n">hf2f</span> <span class="o">*</span> <span class="n">bound_stress</span> <span class="o">*</span> <span class="n">hf2f</span><span class="o">.</span><span class="n">T</span>
            <span class="n">stress</span> <span class="o">=</span> <span class="n">hf2f</span> <span class="o">*</span> <span class="n">stress</span>
            <span class="n">rhs_bound</span> <span class="o">=</span> <span class="n">rhs_bound</span> <span class="o">*</span> <span class="n">hf2f</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># trace of strain matrix</span>
        <span class="n">div</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subcell_gradient_to_cell_scalar</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">cell_node_blocks</span><span class="p">)</span>
        <span class="n">div_u</span> <span class="o">=</span> <span class="n">div</span> <span class="o">*</span> <span class="n">igrad</span> <span class="o">*</span> <span class="n">rhs_cells</span>

        <span class="c1"># The boundary discretization of the div_u term is represented directly</span>
        <span class="c1"># on the cells, instead of going via the faces.</span>
        <span class="n">bound_div_u</span> <span class="o">=</span> <span class="n">div</span> <span class="o">*</span> <span class="n">igrad</span> <span class="o">*</span> <span class="n">rhs_bound</span>

        <span class="c1"># Call discretization of grad_p-term</span>
        <span class="n">rhs_jumps</span><span class="p">,</span> <span class="n">grad_p_face</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_rhs_grad_p</span><span class="p">(</span>
            <span class="n">sd</span><span class="p">,</span> <span class="n">subcell_topology</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">bound_exclusion_mech</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">hf_output</span><span class="p">:</span>
            <span class="c1"># If boundary conditions are given on subfaces we keep the subface</span>
            <span class="c1"># discretization</span>
            <span class="n">grad_p</span> <span class="o">=</span> <span class="n">hook</span> <span class="o">*</span> <span class="n">igrad</span> <span class="o">*</span> <span class="n">rhs_jumps</span> <span class="o">+</span> <span class="n">grad_p_face</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># otherwise, we map it to faces</span>
            <span class="n">grad_p</span> <span class="o">=</span> <span class="n">hf2f</span> <span class="o">*</span> <span class="p">(</span><span class="n">hook</span> <span class="o">*</span> <span class="n">igrad</span> <span class="o">*</span> <span class="n">rhs_jumps</span> <span class="o">+</span> <span class="n">grad_p_face</span><span class="p">)</span>

        <span class="c1"># consistency term for the flow equation</span>
        <span class="n">stabilization</span> <span class="o">=</span> <span class="n">div</span> <span class="o">*</span> <span class="n">igrad</span> <span class="o">*</span> <span class="n">rhs_jumps</span>

        <span class="c1"># We obtain the reconstruction of displacements. This is equivalent as for</span>
        <span class="c1"># mpsa, but we get a contribution from the pressures.</span>
        <span class="n">dist_grad</span><span class="p">,</span> <span class="n">cell_centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reconstruct_displacement</span><span class="p">(</span>
            <span class="n">sd</span><span class="p">,</span> <span class="n">subcell_topology</span><span class="p">,</span> <span class="n">eta</span>
        <span class="p">)</span>

        <span class="n">disp_cell</span> <span class="o">=</span> <span class="n">dist_grad</span> <span class="o">*</span> <span class="n">igrad</span> <span class="o">*</span> <span class="n">rhs_cells</span> <span class="o">+</span> <span class="n">cell_centers</span>
        <span class="n">disp_bound</span> <span class="o">=</span> <span class="n">dist_grad</span> <span class="o">*</span> <span class="n">igrad</span> <span class="o">*</span> <span class="n">rhs_bound</span>
        <span class="n">disp_pressure</span> <span class="o">=</span> <span class="n">dist_grad</span> <span class="o">*</span> <span class="n">igrad</span> <span class="o">*</span> <span class="n">rhs_jumps</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">hf_output</span><span class="p">:</span>
            <span class="c1"># hf2f sums the values, but here we need an average.</span>
            <span class="c1"># For now, use simple average, although area weighted values may be more accurate</span>
            <span class="n">num_subfaces</span> <span class="o">=</span> <span class="n">hf2f</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">dia_matrix</span><span class="p">(</span>
                <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">num_subfaces</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">hf2f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hf2f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>

            <span class="n">disp_cell</span> <span class="o">=</span> <span class="n">scaling</span> <span class="o">*</span> <span class="n">hf2f</span> <span class="o">*</span> <span class="n">disp_cell</span>
            <span class="n">disp_bound</span> <span class="o">=</span> <span class="n">scaling</span> <span class="o">*</span> <span class="n">hf2f</span> <span class="o">*</span> <span class="n">disp_bound</span>
            <span class="n">disp_pressure</span> <span class="o">=</span> <span class="n">scaling</span> <span class="o">*</span> <span class="n">hf2f</span> <span class="o">*</span> <span class="n">disp_pressure</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">stress</span><span class="p">,</span>
            <span class="n">bound_stress</span><span class="p">,</span>
            <span class="n">div_u</span><span class="p">,</span>
            <span class="n">bound_div_u</span><span class="p">,</span>
            <span class="n">grad_p</span><span class="p">,</span>
            <span class="n">stabilization</span><span class="p">,</span>
            <span class="n">disp_cell</span><span class="p">,</span>
            <span class="n">disp_bound</span><span class="p">,</span>
            <span class="n">disp_pressure</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Add discretizations to data</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_rhs_grad_p</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span>
        <span class="n">subcell_topology</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">SubcellTopology</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">bound_exclusion</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">ExcludeBoundaries</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Consistent discretization of grad_p-term in MPSA-W method.</span>

<span class="sd">        Args:</span>
<span class="sd">            g (core.grids.grid): grid to be discretized</span>
<span class="sd">            subcell_topology: Wrapper class for numbering of subcell faces, cells</span>
<span class="sd">                etc.</span>
<span class="sd">            alpha: Biot&#39;s coupling coefficient, given as a scalar in input</span>
<span class="sd">            bound_exclusion: Object that can eliminate faces related to boundary</span>
<span class="sd">                conditions.</span>

<span class="sd">        Returns:</span>
<span class="sd">            scipy.sparse.csr_matrix (shape num_subcells * dim, num_cells):</span>
<span class="sd">            discretization of the jumps in [n alpha p] term,</span>
<span class="sd">            ready to be multiplied with inverse gradient</span>
<span class="sd">            scipy.sparse.csr_matrix (shape num_subfaces * dim, num_cells):</span>
<span class="sd">                discretization of the force on the face due to cell-centre</span>
<span class="sd">                pressure from a unique side.</span>

<span class="sd">        &quot;&quot;&quot;</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method properties and implementation details.</span>
<span class="sd">        Basis functions, namely &#39;stress&#39; and &#39;bound_stress&#39;, for the displacement</span>
<span class="sd">        discretization are obtained as in standard MPSA-W method.</span>
<span class="sd">        Pressure is represented as forces in the cells.</span>
<span class="sd">        However, jumps in pressure forces over a cell face act as force</span>
<span class="sd">        imbalance, and thus induce additional displacement gradients in the sub-cells.</span>
<span class="sd">        An additional system is set up, which applies non-zero conditions to the</span>
<span class="sd">        traction continuity equation. This can be expressed as a linear system on the form</span>

<span class="sd">            (i)   A * grad_u            = I</span>
<span class="sd">            (ii)  B * grad_u + C * u_cc = 0</span>
<span class="sd">            (iii) 0            D * u_cc = 0</span>

<span class="sd">        Thus (i)-(iii) can be inverted to express the additional displacement gradients</span>
<span class="sd">        due to imbalance in pressure forces as in terms of the cell center variables.</span>
<span class="sd">        Thus we can compute the basis functions &#39;grad_p_jumps&#39; on the sub-cells.</span>
<span class="sd">        To ensure traction continuity, as soon as a convention is chosen for what side</span>
<span class="sd">        the force evaluation should be considered on, an additional term, called</span>
<span class="sd">        &#39;grad_p_face&#39;, is added to the full force. This latter term represents the force</span>
<span class="sd">        due to cell-center pressure acting on the face from the chosen side.</span>
<span class="sd">        The pair subfno_unique-unique_subfno gives the side convention.</span>
<span class="sd">        The full force on the face is therefore given by</span>

<span class="sd">        t = stress * u + bound_stress * u_b + alpha * (grad_p_jumps + grad_p_face) * p</span>

<span class="sd">        The strategy is as follows.</span>
<span class="sd">        1. compute product normal_vector * alpha and get a map for vector problems</span>
<span class="sd">        2. assemble r.h.s. for the new linear system, needed for the term &#39;grad_p_jumps&#39;</span>
<span class="sd">        3. compute term &#39;grad_p_face&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span>

        <span class="n">num_subhfno</span> <span class="o">=</span> <span class="n">subcell_topology</span><span class="o">.</span><span class="n">subhfno</span><span class="o">.</span><span class="n">size</span>
        <span class="n">num_subfno_unique</span> <span class="o">=</span> <span class="n">subcell_topology</span><span class="o">.</span><span class="n">num_subfno_unique</span>
        <span class="n">num_subfno</span> <span class="o">=</span> <span class="n">subcell_topology</span><span class="o">.</span><span class="n">num_subfno</span>

        <span class="c1"># Step 1</span>

        <span class="c1"># The implementation is valid for tensor Biot coefficients, but for the</span>
        <span class="c1"># moment, we only allow for scalar inputs.</span>
        <span class="c1"># Take Biot&#39;s alpha as a tensor</span>
        <span class="n">alpha_tensor</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">SecondOrderTensor</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">nd</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">alpha_tensor</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">alpha_tensor</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">alpha_tensor</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">alpha_tensor</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Obtain normal_vector * alpha, pairings of cells and nodes (which together</span>
        <span class="c1"># uniquely define sub-cells, and thus index for gradients)</span>
        <span class="p">(</span>
            <span class="n">nAlpha_grad</span><span class="p">,</span>
            <span class="n">cell_node_blocks</span><span class="p">,</span>
            <span class="n">sub_cell_index</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">scalar_tensor_vector_prod</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">alpha_tensor</span><span class="p">,</span> <span class="n">subcell_topology</span><span class="p">)</span>
        <span class="c1"># transfer nAlpha to a subface-based quantity by pairing expressions on the</span>
        <span class="c1"># two sides of the subface</span>
        <span class="n">unique_nAlpha_grad</span> <span class="o">=</span> <span class="n">subcell_topology</span><span class="o">.</span><span class="n">pair_over_subfaces</span><span class="p">(</span><span class="n">nAlpha_grad</span><span class="p">)</span>

        <span class="c1"># convenience method for reshaping nAlpha from face-based</span>
        <span class="c1"># to component-based. This is to build a block diagonal sparse matrix</span>
        <span class="c1"># compatible with igrad * rhs_units, that is first all x-component, then y, and z</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">map_tensor</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
            <span class="n">newmat</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nd</span><span class="p">):</span>
                <span class="n">this_dim</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">newmat</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">block_diag</span><span class="p">([</span><span class="n">newmat</span><span class="p">,</span> <span class="n">this_dim</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">newmat</span>

        <span class="c1"># Reshape nAlpha component-wise</span>
        <span class="n">nAlpha_grad</span> <span class="o">=</span> <span class="n">map_tensor</span><span class="p">(</span><span class="n">nAlpha_grad</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="n">sub_cell_index</span><span class="p">)</span>
        <span class="n">unique_nAlpha_grad</span> <span class="o">=</span> <span class="n">map_tensor</span><span class="p">(</span><span class="n">unique_nAlpha_grad</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="n">sub_cell_index</span><span class="p">)</span>

        <span class="c1"># Step 2</span>

        <span class="c1"># The pressure term in the traction continuity equation is discretized</span>
        <span class="c1"># as a force on the faces. The right-hand side is thus formed of the</span>
        <span class="c1"># unit vector.</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">build_rhs_units_single_dimension</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="c1"># EK: Can we skip argument dim?</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_subfno_unique</span><span class="p">)</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">subcell_topology</span><span class="o">.</span><span class="n">subfno_unique</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span>
                <span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">ind</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">num_subfno_unique</span><span class="p">,</span> <span class="n">num_subfno_unique</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">mat</span>

        <span class="n">rhs_units</span> <span class="o">=</span> <span class="n">build_rhs_units_single_dimension</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nd</span><span class="p">):</span>
            <span class="n">this_dim</span> <span class="o">=</span> <span class="n">build_rhs_units_single_dimension</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">rhs_units</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">block_diag</span><span class="p">([</span><span class="n">rhs_units</span><span class="p">,</span> <span class="n">this_dim</span><span class="p">])</span>

        <span class="c1"># We get the sign of the subfaces. This will be needed for the boundary</span>
        <span class="c1"># faces if the normal vector points inn. This is because boundary</span>
        <span class="c1"># conditions always are set as if the normals point out.</span>
        <span class="n">sgn</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">cell_faces</span><span class="p">[</span>
            <span class="n">subcell_topology</span><span class="o">.</span><span class="n">fno_unique</span><span class="p">,</span> <span class="n">subcell_topology</span><span class="o">.</span><span class="n">cno_unique</span>
        <span class="p">]</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="c1"># NOTE: For some reason one should not multiply with the sign, but I don&#39;t</span>
        <span class="c1"># understand why. It should not matter much for the Biot alpha term since</span>
        <span class="c1"># by construction the biot_alpha_jumps and biot_alpha_force will cancel for</span>
        <span class="c1"># Neumann boundaries. We keep the sign matrix as an Identity matrix to remember</span>
        <span class="c1"># where it should be multiplied:</span>
        <span class="n">sgn_nd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sgn</span><span class="p">),</span> <span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># In the local systems the coordinates are C ordered (first all x, then all y,</span>
        <span class="c1"># etc.), while they are ordered as F (first x,y,z of subface 1 then x,y,z of</span>
        <span class="c1"># subface 2) elsewhere. If there is a problem with the stabilization or the</span>
        <span class="c1"># boundary, this might be the place to start debugging. The fno_unique</span>
        <span class="c1"># and cno_unique is chosen such that the face normal of fno points out of cno</span>
        <span class="c1"># for internal faces, thus, sgn_diag_F/C will only flip the sign at the boundary.</span>
        <span class="n">sgn_diag_F</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">sgn_nd</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">))</span>
        <span class="n">sgn_diag_C</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">sgn_nd</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">))</span>

        <span class="c1"># Recall the ordering of the local equations:</span>
        <span class="c1"># First stress equilibrium for the internal subfaces.</span>
        <span class="c1"># Then the stress equilibrium for the Neumann subfaces.</span>
        <span class="c1"># Then the Robin subfaces.</span>
        <span class="c1"># And last, the displacement continuity on both internal and external subfaces.</span>
        <span class="n">rhs_int</span> <span class="o">=</span> <span class="n">bound_exclusion</span><span class="o">.</span><span class="n">exclude_boundary</span><span class="p">(</span><span class="n">rhs_units</span><span class="p">)</span>
        <span class="n">rhs_neu</span> <span class="o">=</span> <span class="n">bound_exclusion</span><span class="o">.</span><span class="n">keep_neumann</span><span class="p">(</span><span class="n">sgn_diag_C</span> <span class="o">*</span> <span class="n">rhs_units</span><span class="p">)</span>
        <span class="n">rhs_rob</span> <span class="o">=</span> <span class="n">bound_exclusion</span><span class="o">.</span><span class="n">keep_robin</span><span class="p">(</span><span class="n">sgn_diag_C</span> <span class="o">*</span> <span class="n">rhs_units</span><span class="p">)</span>

        <span class="n">num_dir_subface</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">bound_exclusion</span><span class="o">.</span><span class="n">exclude_neu_rob</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="o">-</span> <span class="n">bound_exclusion</span><span class="o">.</span><span class="n">exclude_neu_rob</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># No right-hand side for cell displacement equations.</span>
        <span class="n">rhs_units_displ_var</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span>
            <span class="p">(</span><span class="n">nd</span> <span class="o">*</span> <span class="n">num_subfno</span> <span class="o">-</span> <span class="n">num_dir_subface</span><span class="p">,</span> <span class="n">num_subfno_unique</span> <span class="o">*</span> <span class="n">nd</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># We get a plus because the -n * I * alpha * p term is moved over to the rhs</span>
        <span class="c1"># in the local systems</span>
        <span class="n">rhs_units</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">rhs_int</span><span class="p">,</span> <span class="n">rhs_neu</span><span class="p">,</span> <span class="n">rhs_rob</span><span class="p">,</span> <span class="n">rhs_units_displ_var</span><span class="p">])</span>

        <span class="k">del</span> <span class="n">rhs_units_displ_var</span>

        <span class="c1"># Output should be on cell-level (not sub-cell)</span>
        <span class="n">sc2c</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">cell_scalar_to_subcell_vector</span><span class="p">(</span>
            <span class="n">sd</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">sub_cell_index</span><span class="p">,</span> <span class="n">cell_node_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># prepare for computation of imbalance coefficients,</span>
        <span class="c1"># that is jumps in cell-centers pressures, ready to be</span>
        <span class="c1"># multiplied with inverse gradients</span>
        <span class="n">rhs_jumps</span> <span class="o">=</span> <span class="n">rhs_units</span> <span class="o">*</span> <span class="n">unique_nAlpha_grad</span> <span class="o">*</span> <span class="n">sc2c</span>

        <span class="c1"># Step 3</span>

        <span class="c1"># mapping from subface to unique subface for vector problems.</span>
        <span class="c1"># This mapping gives the convention from which side</span>
        <span class="c1"># the force should be evaluated on.</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_subfno_unique</span> <span class="o">*</span> <span class="n">nd</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">expand_indices_nd</span><span class="p">(</span><span class="n">subcell_topology</span><span class="o">.</span><span class="n">subfno_unique</span><span class="p">,</span> <span class="n">nd</span><span class="p">)</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">expand_indices_incr</span><span class="p">(</span>
            <span class="n">subcell_topology</span><span class="o">.</span><span class="n">unique_subfno</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="n">num_subhfno</span>
        <span class="p">)</span>
        <span class="n">map_unique_subfno</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span>
            <span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">num_subfno_unique</span> <span class="o">*</span> <span class="n">nd</span><span class="p">,</span> <span class="n">num_subhfno</span> <span class="o">*</span> <span class="n">nd</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">del</span> <span class="n">vals</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span>

        <span class="c1"># Prepare for computation of -grad_p_face term</span>
        <span class="c1"># Note that sgn_diag_F might only flip the boundary signs. See comment above.</span>
        <span class="n">grad_p_face</span> <span class="o">=</span> <span class="o">-</span><span class="n">sgn_diag_F</span> <span class="o">*</span> <span class="n">map_unique_subfno</span> <span class="o">*</span> <span class="n">nAlpha_grad</span> <span class="o">*</span> <span class="n">sc2c</span>

        <span class="k">return</span> <span class="n">rhs_jumps</span><span class="p">,</span> <span class="n">grad_p_face</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_face_vector_to_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nf</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">nd</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sps</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a mapping from vector quantities on faces (stresses) to scalar</span>
<span class="sd">        quantities. The mapping is intended for the boundary discretization of the</span>
<span class="sd">        displacement divergence term  (coupling term in the flow equation).</span>

<span class="sd">        Args:</span>
<span class="sd">            nf (int): Number of faces in the grid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nf</span><span class="p">),</span> <span class="p">((</span><span class="n">nd</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">nd</span> <span class="o">*</span> <span class="n">nf</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">expand_indices_nd</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nf</span><span class="p">),</span> <span class="n">nd</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nf</span> <span class="o">*</span> <span class="n">nd</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sps</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">vals</span><span class="p">,</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)))</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_subcell_gradient_to_cell_scalar</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">cell_node_blocks</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a mapping from sub-cell gradients to cell-wise traces of the gradient</span>
<span class="sd">        operator. The mapping is intended for the discretization of the term div(u)</span>
<span class="sd">        (coupling term in flow equation).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># To pick out the trace of the strain tensor, we access elements</span>
        <span class="c1">#   (2d): 0 (u_x) and 3 (u_y)</span>
        <span class="c1">#   (3d): 0 (u_x), 4 (u_y), 8 (u_z)</span>
        <span class="n">nd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span>
        <span class="k">if</span> <span class="n">nd</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">nd</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>

        <span class="c1"># Sub-cell wise trace of strain tensor: One row per sub-cell</span>
        <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cell_node_blocks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">trace</span><span class="p">)</span>
        <span class="c1"># Adjust the columns to hit each sub-cell</span>
        <span class="n">incr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">nd</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cell_node_blocks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">-</span> <span class="n">nd</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">col</span> <span class="o">+=</span> <span class="n">incr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>

        <span class="c1"># Integrate the trace over the sub-cell, that is, distribute the cell</span>
        <span class="c1"># volumes equally over the sub-cells</span>
        <span class="n">num_cell_nodes</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">num_cell_nodes</span><span class="p">()</span>
        <span class="n">cell_vol</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">cell_volumes</span> <span class="o">/</span> <span class="n">num_cell_nodes</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">cell_vol</span><span class="p">[</span><span class="n">cell_node_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># and we have our mapping from vector to scalar values on sub-cells</span>
        <span class="n">vector_2_scalar</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span>
            <span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">),</span> <span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">),</span> <span class="n">col</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)))</span>
        <span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

        <span class="c1"># Mapping from sub-cells to cells</span>
        <span class="n">div_op</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">cell_node_blocks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="p">(</span><span class="n">cell_node_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cell_node_blocks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
            <span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="c1"># and the composed map</span>
        <span class="n">div</span> <span class="o">=</span> <span class="n">div_op</span> <span class="o">*</span> <span class="n">vector_2_scalar</span>
        <span class="k">return</span> <span class="n">div</span>

    <span class="c1"># ----------------------- Methods for post processing -------------------------</span>

<div class="viewcode-block" id="Biot.extract_vector">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.Biot.extract_vector">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">extract_vector</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span>
        <span class="n">u</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">as_vector</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract displacement field from solution.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd: grid, or a subclass.</span>
<span class="sd">            u (np.ndarray): Solution variable, representing displacements and</span>
<span class="sd">                pressure.</span>
<span class="sd">            dims (list of int, optional): Which dimension to extract. If None,</span>
<span class="sd">                all dimensions are returned.</span>
<span class="sd">        Returns:</span>
<span class="sd">            list of np.ndarray: Displacement variables in the specified</span>
<span class="sd">                dimensions.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span> <span class="o">*</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="n">vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">d</span> <span class="o">+</span> <span class="n">inds</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">as_vector</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">vals</span></div>


<div class="viewcode-block" id="Biot.extract_scalar">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.Biot.extract_scalar">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">extract_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract pressure field from solution.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd: grid, or a subclass.</span>
<span class="sd">            u (np.ndarray): Solution variable, representing displacements and</span>
<span class="sd">                pressure.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Pressure part of solution vector.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">[</span><span class="n">sd</span><span class="o">.</span><span class="n">dim</span> <span class="o">*</span> <span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span> <span class="p">:]</span></div>


<div class="viewcode-block" id="Biot.compute_flux">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.Biot.compute_flux">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute flux field corresponding to a solution.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd: grid, or a subclass.</span>
<span class="sd">            u (np.ndarray): Solution variable, representing displacements and</span>
<span class="sd">                pressure.</span>
<span class="sd">            sd_data (dictionary): dictionary related to grid and problem. Should</span>
<span class="sd">                contain boundary discretization.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Flux over all faces</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flux_discr</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION_MATRICES</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_keyword</span><span class="p">][</span><span class="s2">&quot;flux&quot;</span><span class="p">]</span>
        <span class="n">bound_flux</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION_MATRICES</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_keyword</span><span class="p">][</span>
            <span class="s2">&quot;bound_flux&quot;</span>
        <span class="p">]</span>
        <span class="n">bound_val</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PARAMETERS</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_keyword</span><span class="p">][</span><span class="s2">&quot;bc_values&quot;</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_scalar</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="n">flux_discr</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="n">bound_flux</span> <span class="o">*</span> <span class="n">bound_val</span>
        <span class="k">return</span> <span class="n">flux</span></div>


<div class="viewcode-block" id="Biot.compute_stress">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.Biot.compute_stress">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_stress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute stress field corresponding to a solution.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd: grid, or a subclass.</span>
<span class="sd">            u (np.ndarray): Solution variable, representing displacements and</span>
<span class="sd">                pressure.</span>
<span class="sd">            sd_data (dictionary): dictionary related to grid and problem. Should</span>
<span class="sd">                contain boundary discretization.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray, sd.dim * sd.num_faces: Stress over all faces. Stored as</span>
<span class="sd">                all stress values on the first face, then the second etc.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix_dictionary</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION_MATRICES</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">mechanics_keyword</span><span class="p">]</span>
        <span class="n">stress_discr</span> <span class="o">=</span> <span class="n">matrix_dictionary</span><span class="p">[</span><span class="s2">&quot;stress&quot;</span><span class="p">]</span>
        <span class="n">bound_stress</span> <span class="o">=</span> <span class="n">matrix_dictionary</span><span class="p">[</span><span class="s2">&quot;bound_stress&quot;</span><span class="p">]</span>
        <span class="n">bound_val</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PARAMETERS</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">mechanics_keyword</span><span class="p">][</span><span class="s2">&quot;bc_values&quot;</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_vector</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">as_vector</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">stress</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">stress_discr</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">bound_stress</span> <span class="o">*</span> <span class="n">bound_val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stress</span></div>
</div>



<div class="viewcode-block" id="GradP">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.GradP">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GradP</span><span class="p">(</span><span class="n">Discretization</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for the pressure gradient term of the Biot equation.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the discretization, with the keyword used for storing various</span>
<span class="sd">        information associated with the discretization.</span>

<span class="sd">        Args:</span>
<span class="sd">            keyword (str): Identifier of all information used for this</span>
<span class="sd">                discretization.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyword</span> <span class="o">=</span> <span class="n">keyword</span>
        <span class="c1"># Use the same key to access the discretization matrix as the Biot class.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grad_p_matrix_key</span> <span class="o">=</span> <span class="n">Biot</span><span class="p">()</span><span class="o">.</span><span class="n">grad_p_matrix_key</span>

<div class="viewcode-block" id="GradP.ndof">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.GradP.ndof">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ndof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of degrees of freedom associated to the method.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): A grid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The number of degrees of freedom.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span> <span class="o">*</span> <span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span></div>


<div class="viewcode-block" id="GradP.discretize">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.GradP.discretize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">discretize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Discretize the pressure gradient term of the Biot equation.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): grid, or a subclass, with geometry fields computed.</span>
<span class="sd">            sd_data (dict): For entries, see above.</span>

<span class="sd">        Raises:</span>
<span class="sd">            NotImplementedError, the discretization should be performed using the</span>
<span class="sd">            discretize method of the Biot class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;No discretize method implemented for the GradP</span>
<span class="sd">                                  class. See the Biot class.&quot;&quot;&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="GradP.assemble_matrix_rhs">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.GradP.assemble_matrix_rhs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_matrix_rhs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the matrix and right-hand side for a discretization of the pressure</span>
<span class="sd">        gradient term of the Biot equation.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid) : grid, or a subclass, with geometry fields computed.</span>
<span class="sd">            sd_data: dictionary to store the data. For details on necessary keywords,</span>
<span class="sd">                see method discretize().</span>

<span class="sd">        Returns:</span>
<span class="sd">            matrix: sparse csr (sd.dim * g_num_cells, sd.dim * sd.num_cells).</span>
<span class="sd">                Discretization matrix.</span>
<span class="sd">            rhs: array (sd.dim * sd.num_cells) Right-hand side.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assemble_matrix</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">assemble_rhs</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="GradP.assemble_matrix">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.GradP.assemble_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the matrix and right-hand side for a discretization of the pressure</span>
<span class="sd">        gradient term of the Biot equation.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): Computational grid, with geometry fields computed.</span>
<span class="sd">            sd_data (dictionary): With data stored.</span>

<span class="sd">        Returns:</span>
<span class="sd">            scipy.sparse.csr_matrix: System matrix of this discretization. The</span>
<span class="sd">                size of the matrix will depend on the specific discretization.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError if the pressure gradient term has not already been discretized.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mat_dict</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION_MATRICES</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">keyword</span><span class="p">]</span>

        <span class="n">mat_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_p_matrix_key</span>
        <span class="k">if</span> <span class="n">mat_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mat_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;GradP class requires a pre-computed discretization to be</span>
<span class="sd">                             stored in the matrix dictionary.&quot;&quot;&quot;</span>
            <span class="p">)</span>
        <span class="n">div_mech</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">vector_divergence</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span>
        <span class="c1"># Put together linear system</span>
        <span class="k">if</span> <span class="n">mat_dict</span><span class="p">[</span><span class="n">mat_key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span> <span class="o">*</span> <span class="n">sd</span><span class="o">.</span><span class="n">num_faces</span><span class="p">:</span>
            <span class="n">hf2f_nd</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">map_hf_2_f</span><span class="p">(</span><span class="n">sd</span><span class="o">=</span><span class="n">sd</span><span class="p">)</span>
            <span class="n">grad_p</span> <span class="o">=</span> <span class="n">hf2f_nd</span> <span class="o">*</span> <span class="n">mat_dict</span><span class="p">[</span><span class="n">mat_key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grad_p</span> <span class="o">=</span> <span class="n">mat_dict</span><span class="p">[</span><span class="n">mat_key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">div_mech</span> <span class="o">*</span> <span class="n">grad_p</span></div>


<div class="viewcode-block" id="GradP.assemble_rhs">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.GradP.assemble_rhs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the right-hand side for a discretization of the pressure gradient term.</span>

<span class="sd">        The contribution is nonzero only for nonzero p_reference, which mainly is of</span>
<span class="sd">        relevance for thermal stress on the form</span>
<span class="sd">            thermal_expansion * (T-T_reference) * I.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): Computational grid.</span>
<span class="sd">            sd_data (dictionary): With data stored.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Right-hand side vector with representation of reference pressure</span>
<span class="sd">                contribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mat_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">]</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION_MATRICES</span><span class="p">][</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keyword</span>
        <span class="p">]</span>
        <span class="n">parameter_dictionary</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PARAMETERS</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">keyword</span><span class="p">]</span>
        <span class="c1"># Use the same key to access the discretization matrix as the Biot class.</span>
        <span class="n">mat_key</span> <span class="o">=</span> <span class="n">Biot</span><span class="p">()</span><span class="o">.</span><span class="n">grad_p_matrix_key</span>

        <span class="n">p_reference</span> <span class="o">=</span> <span class="n">parameter_dictionary</span><span class="p">[</span><span class="s2">&quot;p_reference&quot;</span><span class="p">]</span>
        <span class="n">div_mech</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">vector_divergence</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span>
        <span class="c1"># Account for half-face based discretization</span>
        <span class="k">if</span> <span class="n">mat_dict</span><span class="p">[</span><span class="n">mat_key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span> <span class="o">*</span> <span class="n">sd</span><span class="o">.</span><span class="n">num_faces</span><span class="p">:</span>
            <span class="n">hf2f_nd</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">fvutils</span><span class="o">.</span><span class="n">map_hf_2_f</span><span class="p">(</span><span class="n">sd</span><span class="o">=</span><span class="n">sd</span><span class="p">)</span>
            <span class="n">grad_p</span> <span class="o">=</span> <span class="n">hf2f_nd</span> <span class="o">*</span> <span class="n">mat_dict</span><span class="p">[</span><span class="n">mat_key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grad_p</span> <span class="o">=</span> <span class="n">mat_dict</span><span class="p">[</span><span class="n">mat_key</span><span class="p">]</span>

        <span class="c1"># The rhs contribution is the lhs discretization applied to the reference</span>
        <span class="c1"># value.</span>
        <span class="k">return</span> <span class="n">div_mech</span> <span class="o">*</span> <span class="n">grad_p</span> <span class="o">*</span> <span class="n">p_reference</span></div>
</div>



<div class="viewcode-block" id="DivU">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.DivU">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DivU</span><span class="p">(</span><span class="n">Discretization</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for the displacement divergence term of the Biot equation.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mechanics_keyword</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mechanics&quot;</span><span class="p">,</span>
        <span class="n">flow_keyword</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;flow&quot;</span><span class="p">,</span>
        <span class="n">variable</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;displacement&quot;</span><span class="p">,</span>
        <span class="n">mortar_variable</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mortar_displacement&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the mechanics keyword and specify the variables.</span>

<span class="sd">        The keywords are used to access and store parameters and discretization</span>
<span class="sd">        matrices.</span>
<span class="sd">        The variable names are used to obtain the previous solution for the time</span>
<span class="sd">        discretization. Consequently, they are those of the unknowns contributing to</span>
<span class="sd">        the DivU term (displacements), not the scalar variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_keyword</span> <span class="o">=</span> <span class="n">flow_keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mechanics_keyword</span> <span class="o">=</span> <span class="n">mechanics_keyword</span>

        <span class="c1"># Use the same key to access the discretization matrix as the Biot class.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">div_u_matrix_key</span> <span class="o">=</span> <span class="n">Biot</span><span class="p">()</span><span class="o">.</span><span class="n">div_u_matrix_key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bound_div_u_matrix_key</span> <span class="o">=</span> <span class="n">Biot</span><span class="p">()</span><span class="o">.</span><span class="n">bound_div_u_matrix_key</span>
        <span class="c1"># We also need to specify the names of the displacement variables on the node</span>
        <span class="c1"># and adjacent edges.</span>
        <span class="c1"># Set variable name for the vector variable (displacement).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">=</span> <span class="n">variable</span>
        <span class="c1"># The following is only used for mixed-dimensional problems.</span>
        <span class="c1"># Set the variable used for contact mechanics.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mortar_variable</span> <span class="o">=</span> <span class="n">mortar_variable</span>

<div class="viewcode-block" id="DivU.ndof">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.DivU.ndof">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ndof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of degrees of freedom associated to the method.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): A grid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The number of degrees of freedom.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span></div>


<div class="viewcode-block" id="DivU.discretize">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.DivU.discretize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">discretize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Discretize the displacement divergence term of the Biot equation.</span>

<span class="sd">        Args:</span>
<span class="sd">            g (pp.Grid): grid, or a subclass, with geometry fields computed.</span>
<span class="sd">            sd_data (dict): For entries, see above.</span>

<span class="sd">        Raises:</span>
<span class="sd">            NotImplementedError, the discretization should be performed using the</span>
<span class="sd">            discretize method of the Biot class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;No discretize method implemented for the GradP</span>
<span class="sd">                                  class. See the Biot class.&quot;&quot;&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="DivU.assemble_matrix_rhs">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.DivU.assemble_matrix_rhs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_matrix_rhs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the matrix and right-hand side for a discretization of the</span>
<span class="sd">        displacement divergence term of the Biot equation.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid) : grid, or a subclass, with geometry fields computed.</span>
<span class="sd">            sd_data: dictionary to store the data. For details on necessary keywords,</span>
<span class="sd">                see method discretize()</span>

<span class="sd">        Returns:</span>
<span class="sd">            matrix: sparse csr (sd.dim * g_num_cells, sd.dim * g_num_cells) Discretization</span>
<span class="sd">            matrix.</span>
<span class="sd">            rhs: array (sd.dim * g_num_cells) Right-hand side.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assemble_matrix</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">assemble_rhs</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="DivU.assemble_matrix">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.DivU.assemble_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the matrix and right-hand side for a discretization of the</span>
<span class="sd">        displacement divergence term of the Biot equation.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): Computational grid, with geometry fields computed.</span>
<span class="sd">            sd_data (dictionary): With data stored.</span>

<span class="sd">        Returns:</span>
<span class="sd">            scipy.sparse.csr_matrix: System matrix of this discretization. The</span>
<span class="sd">                size of the matrix will depend on the specific discretization.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError if the displacement divergence term has not already been</span>
<span class="sd">            discretized.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix_dictionary</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION_MATRICES</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_keyword</span><span class="p">]</span>

        <span class="n">mat_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">div_u_matrix_key</span>
        <span class="k">if</span> <span class="n">mat_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">matrix_dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;DivU class requires a pre-computed discretization to be</span>
<span class="sd">                             stored in the matrix dictionary.&quot;&quot;&quot;</span>
            <span class="p">)</span>
        <span class="n">biot_alpha</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PARAMETERS</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_keyword</span><span class="p">][</span><span class="s2">&quot;biot_alpha&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">matrix_dictionary</span><span class="p">[</span><span class="n">mat_key</span><span class="p">]</span> <span class="o">*</span> <span class="n">biot_alpha</span></div>


<div class="viewcode-block" id="DivU.assemble_rhs">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.DivU.assemble_rhs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the right-hand side for a discretization of the displacement</span>
<span class="sd">        divergence term.</span>

<span class="sd">        For the time being, we assume an IE temporal discretization.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): Computational grid.</span>
<span class="sd">            sd_data (dictionary): With data stored.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Zero right-hand side vector with representation of boundary</span>
<span class="sd">                conditions.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parameter_dictionary_mech</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PARAMETERS</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">mechanics_keyword</span><span class="p">]</span>
        <span class="n">parameter_dictionary_flow</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PARAMETERS</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_keyword</span><span class="p">]</span>
        <span class="n">matrix_dictionary</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION_MATRICES</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_keyword</span><span class="p">]</span>

        <span class="c1"># For IE and constant BCs, the boundary part cancels, as the contribution from</span>
        <span class="c1"># successive time steps (n and n+1) appear on the rhs with opposite signs. For</span>
        <span class="c1"># transient BCs, use the below with the appropriate version of d_bound_i.</span>
        <span class="c1"># Get bc values from mechanics</span>
        <span class="n">d_bound_1</span> <span class="o">=</span> <span class="n">parameter_dictionary_mech</span><span class="p">[</span><span class="s2">&quot;bc_values&quot;</span><span class="p">]</span>

        <span class="n">d_bound_0</span> <span class="o">=</span> <span class="n">parameter_dictionary_mech</span><span class="p">[</span><span class="s2">&quot;bc_values_previous_timestep&quot;</span><span class="p">]</span>
        <span class="c1"># and coupling parameter from flow</span>
        <span class="n">biot_alpha</span> <span class="o">=</span> <span class="n">parameter_dictionary_flow</span><span class="p">[</span><span class="s2">&quot;biot_alpha&quot;</span><span class="p">]</span>
        <span class="n">rhs_bound</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="n">matrix_dictionary</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bound_div_u_matrix_key</span><span class="p">]</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">d_bound_1</span> <span class="o">-</span> <span class="n">d_bound_0</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">biot_alpha</span>
        <span class="p">)</span>

        <span class="c1"># Time part</span>
        <span class="n">d_cell</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">]</span>

        <span class="n">div_u</span> <span class="o">=</span> <span class="n">matrix_dictionary</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">div_u_matrix_key</span><span class="p">]</span>
        <span class="n">rhs_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">biot_alpha</span> <span class="o">*</span> <span class="n">div_u</span> <span class="o">*</span> <span class="n">d_cell</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rhs_bound</span> <span class="o">+</span> <span class="n">rhs_time</span></div>


<div class="viewcode-block" id="DivU.assemble_int_bound_displacement_trace">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.DivU.assemble_int_bound_displacement_trace">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_int_bound_displacement_trace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span>
        <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">intf</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">,</span>
        <span class="n">intf_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">grid_swap</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">cc</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">matrix</span><span class="p">:</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">self_ind</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assemble the contribution from the displacement mortar on an internal boundary,</span>
<span class="sd">        manifested as a displacement boundary condition.</span>

<span class="sd">        The intended use is when the internal boundary is coupled to another</span>
<span class="sd">        node by an interface law. Specific usage depends on the</span>
<span class="sd">        interface condition between the nodes; this method will typically be</span>
<span class="sd">        used to impose the effect of the displacement mortar on the divergence term on</span>
<span class="sd">        the higher-dimensional grid.</span>

<span class="sd">        Implementations of this method will use an interplay between the grid</span>
<span class="sd">        on the node and the mortar grid on the relevant edge.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): Grid which the condition should be imposed on.</span>
<span class="sd">            sd_data (dictionary): Data dictionary for the node in the</span>
<span class="sd">                mixed-dimensional grid.</span>
<span class="sd">            intf_data (dictionary): Data dictionary for the edge in the</span>
<span class="sd">                mixed-dimensional grid.</span>
<span class="sd">            grid_swap (boolean): If True, the grid g is identified with the @</span>
<span class="sd">                secondary side of the mortar grid in intf_data.</span>
<span class="sd">            cc (block matrix, 3x3): Block matrix for the coupling condition.</span>
<span class="sd">                The first and second rows and columns are identified with the</span>
<span class="sd">                primary and secondary side; the third belongs to the edge variable.</span>
<span class="sd">                The discretization of the relevant term is done in-place in cc.</span>
<span class="sd">            matrix (block matrix 3x3): Discretization matrix for the edge and</span>
<span class="sd">                the two adjacent nodes.</span>
<span class="sd">            self_ind (int): Index in cc and matrix associated with this node.</span>
<span class="sd">                Should be either 1 or 2.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">grid_swap</span><span class="p">:</span>
            <span class="n">proj</span> <span class="o">=</span> <span class="n">intf</span><span class="o">.</span><span class="n">mortar_to_secondary_avg</span><span class="p">(</span><span class="n">nd</span><span class="o">=</span><span class="n">sd</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">proj</span> <span class="o">=</span> <span class="n">intf</span><span class="o">.</span><span class="n">mortar_to_primary_avg</span><span class="p">(</span><span class="n">nd</span><span class="o">=</span><span class="n">sd</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>

        <span class="n">matrix_dictionary</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION_MATRICES</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_keyword</span><span class="p">]</span>
        <span class="n">biot_alpha</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PARAMETERS</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_keyword</span><span class="p">][</span><span class="s2">&quot;biot_alpha&quot;</span><span class="p">]</span>
        <span class="n">bound_div_u</span> <span class="o">=</span> <span class="n">matrix_dictionary</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bound_div_u_matrix_key</span><span class="p">]</span>

        <span class="n">u_bound_previous</span> <span class="o">=</span> <span class="n">intf_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">mortar_variable</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">bound_div_u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">proj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Inconsistent shapes. Did you define a</span>
<span class="sd">            sub-face boundary condition but only a face-wise mortar?&quot;&quot;&quot;</span>
            <span class="p">)</span>
        <span class="c1"># The mortar will act as a boundary condition for the div_u term.</span>
        <span class="c1"># We assume implicit Euler in Biot, thus the div_u term appears</span>
        <span class="c1"># on the rhs as div_u^{k-1}. This results in a contribution to the</span>
        <span class="c1"># rhs for the coupling variable also.</span>
        <span class="n">cc</span><span class="p">[</span><span class="n">self_ind</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">biot_alpha</span> <span class="o">*</span> <span class="n">bound_div_u</span> <span class="o">*</span> <span class="n">proj</span>
        <span class="n">rhs</span><span class="p">[</span><span class="n">self_ind</span><span class="p">]</span> <span class="o">+=</span> <span class="n">biot_alpha</span> <span class="o">*</span> <span class="n">bound_div_u</span> <span class="o">*</span> <span class="n">proj</span> <span class="o">*</span> <span class="n">u_bound_previous</span></div>


<div class="viewcode-block" id="DivU.assemble_int_bound_displacement_source">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.DivU.assemble_int_bound_displacement_source">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_int_bound_displacement_source</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">,</span> <span class="n">intf</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">,</span> <span class="n">intf_data</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">self_ind</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assemble the contribution from the displacement mortar on an internal boundary,</span>
<span class="sd">        manifested as a source term. Only the normal component of the mortar displacement</span>
<span class="sd">        is considered.</span>

<span class="sd">        The intended use is when the internal boundary is coupled to another</span>
<span class="sd">        node by an interface law. Specific usage depends on the</span>
<span class="sd">        interface condition between the nodes; this method will typically be</span>
<span class="sd">        used to impose the effect of the displacement mortar on the divergence term on</span>
<span class="sd">        the lower-dimensional grid.</span>

<span class="sd">        Implementations of this method will use an interplay between the grid</span>
<span class="sd">        on the node and the mortar grid on the relevant edge.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): Grid which the condition should be imposed on.</span>
<span class="sd">            sd_data (dictionary): Data dictionary for the node in the</span>
<span class="sd">                mixed-dimensional grid.</span>
<span class="sd">            intf_data (dictionary): Data dictionary for the edge in the</span>
<span class="sd">                mixed-dimensional grid.</span>
<span class="sd">            cc (block matrix, 3x3): Block matrix for the coupling condition.</span>
<span class="sd">                The first and second rows and columns are identified with the</span>
<span class="sd">                primary and secondary side; the third belongs to the edge variable.</span>
<span class="sd">                The discretization of the relevant term is done in-place in cc.</span>
<span class="sd">            matrix (block matrix 3x3): Discretization matrix for the edge and</span>
<span class="sd">                the two adjacent nodes.</span>
<span class="sd">            self_ind (int): Index in cc and matrix associated with this node.</span>
<span class="sd">                Should be either 0 or 1.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># From the mortar displacements, we want to</span>
        <span class="c1"># 1) Take the jump between the two mortar sides,</span>
        <span class="c1"># 2) Project to the secondary grid and</span>
        <span class="c1"># 3) Extract the normal component.</span>

        <span class="c1"># Define projections and rotations</span>
        <span class="n">nd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="n">intf</span><span class="o">.</span><span class="n">mortar_to_secondary_avg</span><span class="p">(</span><span class="n">nd</span><span class="o">=</span><span class="n">nd</span><span class="p">)</span>
        <span class="n">jump_on_secondary</span> <span class="o">=</span> <span class="n">proj</span> <span class="o">*</span> <span class="n">intf</span><span class="o">.</span><span class="n">sign_of_mortar_sides</span><span class="p">(</span><span class="n">nd</span><span class="o">=</span><span class="n">nd</span><span class="p">)</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="s2">&quot;tangential_normal_projection&quot;</span><span class="p">]</span>

        <span class="n">normal_component</span> <span class="o">=</span> <span class="n">rotation</span><span class="o">.</span><span class="n">project_normal</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">)</span>

        <span class="c1"># Obtain possibly heterogeneous biot alpha values</span>
        <span class="n">biot_alpha</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PARAMETERS</span><span class="p">]</span><span class="o">.</span><span class="n">expand_scalars</span><span class="p">(</span>
            <span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_keyword</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;biot_alpha&quot;</span><span class="p">]</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Project the previous solution to the secondary grid</span>
        <span class="n">previous_displacement_jump_global_coord</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">jump_on_secondary</span> <span class="o">*</span> <span class="n">intf_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">mortar_variable</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># Rotated displacement jumps. These are in the local coordinates, on</span>
        <span class="c1"># the lower-dimensional grid</span>
        <span class="n">previous_displacement_jump_normal</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">normal_component</span> <span class="o">*</span> <span class="n">previous_displacement_jump_global_coord</span>
        <span class="p">)</span>
        <span class="c1"># The same procedure is applied to the unknown displacements, by assembling the</span>
        <span class="c1"># jump operator, projection and normal component extraction in the coupling matrix.</span>
        <span class="c1"># Finally, we integrate over the cell volume.</span>
        <span class="n">vol</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">dia_matrix</span><span class="p">((</span><span class="n">sd</span><span class="o">.</span><span class="n">cell_volumes</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">,</span> <span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span><span class="p">))</span>
        <span class="n">cc</span><span class="p">[</span><span class="n">self_ind</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="n">sps</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">biot_alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">vol</span> <span class="o">*</span> <span class="n">normal_component</span> <span class="o">*</span> <span class="n">jump_on_secondary</span>
        <span class="p">)</span>

        <span class="c1"># We assume implicit Euler in Biot, thus the div_u term appears</span>
        <span class="c1"># on the rhs as div_u^{k-1}. This results in a contribution to the</span>
        <span class="c1"># rhs for the coupling variable also.</span>
        <span class="c1"># This term is second part of (u^k - u^{k-1}) moved to</span>
        <span class="c1"># the rhs, yielding the same sign as for the k term on the lhs.</span>
        <span class="n">rhs</span><span class="p">[</span><span class="n">self_ind</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sps</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">biot_alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">vol</span> <span class="o">*</span> <span class="n">previous_displacement_jump_normal</span></div>
</div>



<div class="viewcode-block" id="BiotStabilization">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.BiotStabilization">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BiotStabilization</span><span class="p">(</span><span class="n">Discretization</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for the stabilization term of the Biot equation.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="o">=</span><span class="s2">&quot;mechanics&quot;</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="s2">&quot;pressure&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the two keywords.</span>

<span class="sd">        The keywords are used to access and store parameters and discretization</span>
<span class="sd">        matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyword</span> <span class="o">=</span> <span class="n">keyword</span>
        <span class="c1"># Set variable name for the scalar variable (pressure)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">=</span> <span class="n">variable</span>

        <span class="c1"># Use same keyword as in Biot class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stabilization_matrix_key</span> <span class="o">=</span> <span class="n">Biot</span><span class="p">()</span><span class="o">.</span><span class="n">stabilization_matrix_key</span>

<div class="viewcode-block" id="BiotStabilization.ndof">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.BiotStabilization.ndof">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ndof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of degrees of freedom associated to the method.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): A grid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The number of degrees of freedom.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span></div>


<div class="viewcode-block" id="BiotStabilization.discretize">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.BiotStabilization.discretize">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">discretize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Discretize the stabilization term of the Biot equation.</span>

<span class="sd">        Args:</span>
<span class="sd">            g (pp.Grid): grid, or a subclass, with geometry fields computed.</span>
<span class="sd">            sd_data (dict): Data dictionary.</span>

<span class="sd">        Raises:</span>
<span class="sd">            NotImplementedError, the discretization should be performed using the</span>
<span class="sd">            discretize method of the Biot class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;No discretize method implemented for the BiotStabilization</span>
<span class="sd">                                  class. See the Biot class.&quot;&quot;&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="BiotStabilization.assemble_matrix_rhs">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.BiotStabilization.assemble_matrix_rhs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_matrix_rhs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the matrix and right-hand side for a discretization of the</span>
<span class="sd">        stabilization term of the Biot equation.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): grid, or a subclass, with geometry fields computed.</span>
<span class="sd">            sd_data: dictionary to store the data. For details on necessary keywords,</span>
<span class="sd">                see method discretize()</span>

<span class="sd">        Returns:</span>
<span class="sd">            matrix: sparse csr (sd.dim * g.num_cells, sd.dim * sd.num_cells)</span>
<span class="sd">                Discretization matrix.</span>
<span class="sd">            rhs: array (sd.dim * sd.num_cells) Right-hand side.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assemble_matrix</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">assemble_rhs</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="BiotStabilization.assemble_matrix">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.BiotStabilization.assemble_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the matrix and right-hand side for a discretization of the</span>
<span class="sd">        stabilization term of the Biot equation.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): Computational grid, with geometry fields computed.</span>
<span class="sd">            sd_data (dictionary): With data stored.</span>

<span class="sd">        Returns:</span>
<span class="sd">            scipy.sparse.csr_matrix: System matrix of this discretization. The</span>
<span class="sd">                size of the matrix will depend on the specific discretization.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError if the stabilization term has not already been</span>
<span class="sd">            discretized.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mat_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stabilization_matrix_key</span>
        <span class="n">matrix_dictionary</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION_MATRICES</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">keyword</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mat_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">matrix_dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;BiotStabilization class requires a pre-computed</span>
<span class="sd">                             discretization to be stored in the matrix dictionary.&quot;&quot;&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">matrix_dictionary</span><span class="p">[</span><span class="n">mat_key</span><span class="p">]</span></div>


<div class="viewcode-block" id="BiotStabilization.assemble_rhs">
<a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.fv.biot.html#porepy.numerics.fv.biot.BiotStabilization.assemble_rhs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assemble_rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sd</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">sd_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the right-hand side for the stabilization part of the displacement</span>
<span class="sd">        divergence term.</span>

<span class="sd">        For the time being, we assume an IE temporal discretization.</span>

<span class="sd">        Args:</span>
<span class="sd">            sd (pp.Grid): Computational grid.</span>
<span class="sd">            sd_data (dictionary): With data stored.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Zero right-hand side vector with representation of boundary</span>
<span class="sd">                conditions.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix_dictionary</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION_MATRICES</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">keyword</span><span class="p">]</span>

        <span class="c1"># The stabilization is the pressure contribution to the div u part of the</span>
        <span class="c1"># fluid mass conservation, thus needs a right-hand side in the implicit Euler</span>
        <span class="c1"># discretization.</span>
        <span class="n">pressure_0</span> <span class="o">=</span> <span class="n">sd_data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">]</span>
        <span class="n">A_stability</span> <span class="o">=</span> <span class="n">matrix_dictionary</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stabilization_matrix_key</span><span class="p">]</span>
        <span class="n">rhs_time</span> <span class="o">=</span> <span class="n">A_stability</span> <span class="o">*</span> <span class="n">pressure_0</span>

        <span class="c1"># The stabilization has no rhs.</span>
        <span class="n">rhs_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">(</span><span class="n">sd</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">rhs_bound</span> <span class="o">+</span> <span class="n">rhs_time</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022 UiB Center for Modeling of Coupled Subsurface Dynamics, GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007..</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>