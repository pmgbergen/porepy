<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>porepy.numerics.ad.equation_system &mdash; PorePy 1.6.0 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
    <link rel="canonical" href="https://pmgbergen.github.io/porepy/_modules/porepy/numerics/ad/equation_system.html" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >
            <a href="../../../../index.html" class="icon icon-home"> PorePy
          </a>
              <div class="version">
                1.6.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../docsrc/howto/howto-docstring.html">1. How-To docstring</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../docsrc/porepy/modules.html">porepy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../docsrc/porepy/porepy.html">porepy package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.html">porepy.fracs package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.fracture.html">porepy.fracs.fracture module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.fracture_importer.html">porepy.fracs.fracture_importer module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.fracture_network_2d.html">porepy.fracs.fracture_network_2d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html">porepy.fracs.fracture_network_3d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.gmsh_interface.html">porepy.fracs.gmsh_interface module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.line_fracture.html">porepy.fracs.line_fracture module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.meshing.html">porepy.fracs.meshing module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.msh_2_grid.html">porepy.fracs.msh_2_grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.non_conforming.html">porepy.fracs.non_conforming module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.plane_fracture.html">porepy.fracs.plane_fracture module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.simplex.html">porepy.fracs.simplex module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.split_grid.html">porepy.fracs.split_grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.structured.html">porepy.fracs.structured module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.tools.html">porepy.fracs.tools module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.utils.html">porepy.fracs.utils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.wells_3d.html">porepy.fracs.wells_3d module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.html">porepy.geometry package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.bounding_box.html">porepy.geometry.bounding_box module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.constrain_geometry.html">porepy.geometry.constrain_geometry module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.distances.html">porepy.geometry.distances module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.geometry_property_checks.html">porepy.geometry.geometry_property_checks module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.half_space.html">porepy.geometry.half_space module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.intersections.html">porepy.geometry.intersections module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.map_geometry.html">porepy.geometry.map_geometry module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.point_in_polyhedron_test.html">porepy.geometry.point_in_polyhedron_test module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.html">porepy.grids package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.standard_grids.html">porepy.grids.standard_grids package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.boundary_grid.html">porepy.grids.boundary_grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.coarsening.html">porepy.grids.coarsening module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.grid.html">porepy.grids.grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.grid_extrusion.html">porepy.grids.grid_extrusion module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.match_grids.html">porepy.grids.match_grids module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.md_grid.html">porepy.grids.md_grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.mortar_grid.html">porepy.grids.mortar_grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.partition.html">porepy.grids.partition module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.point_grid.html">porepy.grids.point_grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.refinement.html">porepy.grids.refinement module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.simplex.html">porepy.grids.simplex module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.structured.html">porepy.grids.structured module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.html">porepy.models package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.verification_setups.html">porepy.models.verification_setups package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.abstract_equations.html">porepy.models.abstract_equations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.abstract_model.html">porepy.models.abstract_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.constitutive_laws.html">porepy.models.constitutive_laws module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.contact_mechanics_biot_model.html">porepy.models.contact_mechanics_biot_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.contact_mechanics_model.html">porepy.models.contact_mechanics_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.energy_balance.html">porepy.models.energy_balance module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.fluid_mass_balance.html">porepy.models.fluid_mass_balance module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.geometry.html">porepy.models.geometry module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.incompressible_flow_model.html">porepy.models.incompressible_flow_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.mass_and_energy_balance.html">porepy.models.mass_and_energy_balance module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.material_constants.html">porepy.models.material_constants module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.momentum_balance.html">porepy.models.momentum_balance module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.poromechanics.html">porepy.models.poromechanics module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.run_models.html">porepy.models.run_models module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.slightly_compressible_flow_model.html">porepy.models.slightly_compressible_flow_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.solution_strategy.html">porepy.models.solution_strategy module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.thermoporomechanics.html">porepy.models.thermoporomechanics module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.thm_model.html">porepy.models.thm_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.units.html">porepy.models.units module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.html">porepy.numerics package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.ad.html">porepy.numerics.ad package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fem.html">porepy.numerics.fem package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fracture_deformation.html">porepy.numerics.fracture_deformation package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fv.html">porepy.numerics.fv package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.interface_laws.html">porepy.numerics.interface_laws package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.linalg.html">porepy.numerics.linalg package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.mixed_dim.html">porepy.numerics.mixed_dim package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.nonlinear.html">porepy.numerics.nonlinear package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.solvers.html">porepy.numerics.solvers package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.vem.html">porepy.numerics.vem package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.discretization.html">porepy.numerics.discretization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.displacement_correlation.html">porepy.numerics.displacement_correlation module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.linear_solvers.html">porepy.numerics.linear_solvers module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.time_step_control.html">porepy.numerics.time_step_control module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.html">porepy.params package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.bc.html">porepy.params.bc module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.data.html">porepy.params.data module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.fluid.html">porepy.params.fluid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.parameter_dictionaries.html">porepy.params.parameter_dictionaries module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.rock.html">porepy.params.rock module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.tensor.html">porepy.params.tensor module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.html">porepy.utils package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.derived_discretizations.html">porepy.utils.derived_discretizations package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.accumarray.html">porepy.utils.accumarray module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.adtree.html">porepy.utils.adtree module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.array_operations.html">porepy.utils.array_operations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.common_constants.html">porepy.utils.common_constants module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.default_domains.html">porepy.utils.default_domains module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.error.html">porepy.utils.error module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.graph.html">porepy.utils.graph module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.grid_utils.html">porepy.utils.grid_utils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.interpolation_tables.html">porepy.utils.interpolation_tables module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.mcolon.html">porepy.utils.mcolon module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.permutations.html">porepy.utils.permutations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.porepy_types.html">porepy.utils.porepy_types module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.setmembership.html">porepy.utils.setmembership module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.sort_points.html">porepy.utils.sort_points module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.tags.html">porepy.utils.tags module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.tangential_normal_projection.html">porepy.utils.tangential_normal_projection module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.viz.html">porepy.viz package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.viz.data_saving_model_mixin.html">porepy.viz.data_saving_model_mixin module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.viz.exporter.html">porepy.viz.exporter module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.viz.fracture_visualization.html">porepy.viz.fracture_visualization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.viz.plot_grid.html">porepy.viz.plot_grid module</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">PorePy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">porepy.numerics.ad.equation_system</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for porepy.numerics.ad.equation_system</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Contains the EquationSystem, managing variables and equations for a system modelled</span>
<span class="sd">using the AD framework.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sps</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">TypeAlias</span>

<span class="kn">import</span> <span class="nn">porepy</span> <span class="k">as</span> <span class="nn">pp</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_ad_utils</span>
<span class="kn">from</span> <span class="nn">.operators</span> <span class="kn">import</span> <span class="n">MixedDimensionalVariable</span><span class="p">,</span> <span class="n">Operator</span><span class="p">,</span> <span class="n">Variable</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;EquationSystem&quot;</span><span class="p">]</span>

<span class="n">GridLike</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">]</span>
<span class="sd">&quot;&quot;&quot;A union type representing a domain either by a grid or mortar grid.</span>
<span class="sd">FIXME: Rename to Domain? Or GridLikeList/GridList below?&quot;&quot;&quot;</span>

<span class="c1"># For Python3.8, a direct definition of type aliases with list is apparently not posible</span>
<span class="c1"># (DomainList = Union[list[pp.Grid], list[pp.MortarGrid]]]), the same applies to dict</span>
<span class="c1"># and presumably tuple etc. As a temporary solution, we use a TypeAlias together with a</span>
<span class="c1"># string representation of the type. This can be replaced with the more straightforward</span>
<span class="c1"># definition when we drop support for Python3.8.</span>
<span class="n">DomainList</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="s2">&quot;Union[list[pp.Grid], list[pp.MortarGrid]]&quot;</span>
<span class="sd">&quot;&quot;&quot;A union type representing a list of grids or mortar grids.</span>
<span class="sd">This is *not* a list of GridLike, as that would allow a list of mixed grids and</span>
<span class="sd">mortar grids.&quot;&quot;&quot;</span>

<span class="n">VariableList</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;Union[list[str], list[Variable], list[MixedDimensionalVariable]]&quot;</span>
<span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A union type representing variables</span>

<span class="sd">Variables are defined through either</span>
<span class="sd">    - names (:class:`str`),</span>
<span class="sd">    - multiple :class:`~porepy.numerics.ad.operators.Variable` or</span>
<span class="sd">    - :class:`~porepy.numerics.ad.operators.MixedDimensionalVariable`.</span>

<span class="sd">This type is accepted as input to various methods and parsed to a list of</span>
<span class="sd">:class:`~porepy.numerics.ad.operators.Variable` using</span>
<span class="sd">:meth:`~porepy.numerics.ad.equation_system.EquationSystem._parse_variable_list`.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="n">EquationList</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="s2">&quot;Union[list[str], list[Operator]]&quot;</span>
<span class="sd">&quot;&quot;&quot;A union type representing equations through either names (:class:`str`), or</span>
<span class="sd">:class:`~porepy.numerics.ad.operators.Operator`.</span>

<span class="sd">This type is accepted as input to various methods and parsed to a list of</span>
<span class="sd">:class:`~porepy.numerics.ad.operators.Operator` using</span>
<span class="sd">:meth:`~porepy.numerics.ad.equation_system.EquationSystem._parse_equations`.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="n">EquationRestriction</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="s2">&quot;dict[Union[str, Operator], DomainList]&quot;</span>
<span class="sd">&quot;&quot;&quot;A dictionary mapping equations to a list of domains on which the equation should be</span>
<span class="sd">applied.</span>

<span class="sd">The keys of the dictionary can be either the name of the equation, or the equation</span>
<span class="sd">itself represented as an :class:`~porepy.numerics.ad.operators.Operator`. The values of</span>
<span class="sd">the dictionary are DomainList, i.e., a list of grids or mortar grids.</span>

<span class="sd">This type is accepted as input to various methods and parsed to an index set</span>
<span class="sd">representing a restricted image of the equation by</span>
<span class="sd">:meth:`~porepy.numerics.ad.equation_system.EquationSystem._parse_equations`.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># IMPLEMENTATION NOTE: EK could not find an elegant way to represent all types of</span>
<span class="c1"># equation input in a single type. The problem is that, while strings and Operators</span>
<span class="c1"># are naturally wrapped in lists, even if there is only one item, restrictions of</span>
<span class="c1"># equations are most naturally represented as a dictionary. This means iteration over</span>
<span class="c1"># equations and restrictions must be handled separately, as is now done in</span>
<span class="c1">#  _parse_equations(). To avoid this, we could have introduced</span>
<span class="c1">#</span>
<span class="c1">#   EquationType = Union[str, Operator, dict[Union[str, Operator], DomainList]]</span>
<span class="c1">#</span>
<span class="c1"># and allowed for list[EquationType] as input to various methods. This does however</span>
<span class="c1"># require passing a list of dictionaries to _parse_equations(), which was very</span>
<span class="c1"># awkward from the user side when EK tried it. The current solution seems like a fair</span>
<span class="c1"># compromise, and it has the positive side of being explicit on the difference between</span>
<span class="c1"># equations and restrictions of equations, but it does not feel like a fully</span>
<span class="c1"># satisfactory solution.</span>

<span class="n">GridEntity</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="s2">&quot;faces&quot;</span><span class="p">,</span> <span class="s2">&quot;nodes&quot;</span><span class="p">]</span>
<span class="sd">&quot;&quot;&quot;A union type representing a grid entity, either a cell, face or node.</span>
<span class="sd">This is used to define the domain of a variable or an equation,</span>
<span class="sd">i.e. whether it is defined on cells, faces or nodes.</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="EquationSystem"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem">[docs]</a><span class="k">class</span> <span class="nc">EquationSystem</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Represents an equation system, modelled by AD variables and equations in AD form.</span>

<span class="sd">    This class provides functionalities to create and manage variables, as well as</span>
<span class="sd">    managing equations on the form of :class:`~porepy.numerics.ad.operators.Operator`.</span>
<span class="sd">    It further provides functions to assemble subsystems and using subsets of equations</span>
<span class="sd">    and variables.</span>

<span class="sd">    Note:</span>
<span class="sd">        As of now, the system matrix (Jacobian) is assembled with respect to ALL</span>
<span class="sd">        variables and then the columns belonging to the requested subset of variables</span>
<span class="sd">        and grids are sliced out and returned. This will be optimized with minor changes</span>
<span class="sd">        to the AD operator class and its recursive forward AD mode in the future.</span>

<span class="sd">        Currently, this class optimizes the block structure of the Jacobian only</span>
<span class="sd">        regarding the subdomains and interfaces. A more localized optimization (e.g.</span>
<span class="sd">        cell-wise for equations without spatial differential operators) is not</span>
<span class="sd">        performed.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">admissible_dof_types</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;cells&quot;</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;faces&quot;</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;nodes&quot;</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="s2">&quot;faces&quot;</span><span class="p">,</span> <span class="s2">&quot;nodes&quot;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;A set denoting admissible types of local DOFs for variables.</span>

<span class="sd">    - nodes: DOFs per grid node.</span>
<span class="sd">    - cells: DOFs per grid cell.</span>
<span class="sd">    - faces: DOFS per grid face.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mdg</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">MixedDimensionalGrid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="c1">### PUBLIC</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">MixedDimensionalGrid</span> <span class="o">=</span> <span class="n">mdg</span>
        <span class="sd">&quot;&quot;&quot;Mixed-dimensional domain passed at instantiation.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">assembled_equation_indices</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;Contains the row indices in the last assembled (sub-) system for a given</span>
<span class="sd">        equation name (key).</span>

<span class="sd">        This dictionary changes with every call to any assemble-method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">### PRIVATE</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Operator</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;Contains references to equations in AD operator form for a given name (key).</span>

<span class="sd">        Private to avoid users setting equations directly and circumventing the current</span>
<span class="sd">        set-method which includes information about the image space.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_equation_image_space_composition</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
            <span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="n">GridLike</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;Definition of image space for all equations.</span>

<span class="sd">        Contains for every equation name (key) a dictionary, which provides again for</span>
<span class="sd">        every involved grid (key) the indices of equations expressed through the</span>
<span class="sd">        equation operator. The ordering of the items in the grid-array dictionaries is</span>
<span class="sd">        consistent with the remaining PorePy framework. The ordering is local to the</span>
<span class="sd">        equation, so it can be used to slice an eqution prior to concatenation of</span>
<span class="sd">        equations into a global matrix.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_equation_image_size_info</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="n">GridEntity</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;Contains for every equation name (key) the number of equations per grid</span>
<span class="sd">        entity.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Variable</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;Contains references to Variables.</span>

<span class="sd">        A Variable is uniquely identified by its name and domain, stored as attributes</span>
<span class="sd">        of the Variable object.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_Schur_complement</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Contains block matrices and the rhs of the last assembled Schur complement.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_variable_numbers</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Variable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;Dictionary containing the index of the variable in the system vector of the</span>
<span class="sd">        last assembled system.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_variable_num_dofs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;Array containing the number of DOFS per block number.</span>

<span class="sd">        The block number corresponds to this array&#39;s indexation, see also</span>
<span class="sd">        attr:`_variable_numbers`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_variable_dof_type</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Variable</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="n">GridEntity</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;Dictionary containing the type of DOFs per variable.</span>

<span class="sd">        The type is given as a dictionary with keys &#39;cells&#39;, &#39;faces&#39; or &#39;nodes&#39;,</span>
<span class="sd">        and integer values denoting the number of DOFs per grid entity.</span>

<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="EquationSystem.SubSystem"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem.SubSystem">[docs]</a>    <span class="k">def</span> <span class="nf">SubSystem</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">equation_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">EquationList</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">variable_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">VariableList</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EquationSystem</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates an :class:`EquationSystem` for a given subset of equations and</span>
<span class="sd">        variables.</span>

<span class="sd">        Currently only subsystems containing *whole* equations and variables in the</span>
<span class="sd">        mixed-dimensional sense can be created. Restrictions of equations to subdomains</span>
<span class="sd">        is not supported.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            equation_names: Names of equations for the new subsystem. If None, all</span>
<span class="sd">                equations known to the :class:`EquationSystem` are used.</span>
<span class="sd">            variable_names: Names of known variables for the new subsystem. If None, all</span>
<span class="sd">                variables known to the :class:`EquationSystem` are used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A new instance of :class:`EquationSystem`. The subsystem equations and</span>
<span class="sd">            variables are ordered as imposed by this systems&#39;s order.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if passed names are not among created variables and set</span>
<span class="sd">                equations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Parsing of input arguments.</span>
        <span class="n">equations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parse_equations</span><span class="p">(</span><span class="n">equation_names</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_variable_type</span><span class="p">(</span><span class="n">variable_names</span><span class="p">)</span>

        <span class="c1"># Check that the requested equations and variables are known to the system.</span>
        <span class="n">known_equations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">unknown_equations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">equations</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">known_equations</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unknown_equations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown variable(s) </span><span class="si">{</span><span class="n">unknown_equations</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">unknown_variables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unknown_variables</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown variable(s) </span><span class="si">{</span><span class="n">unknown_variables</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># Create the new subsystem.</span>
        <span class="n">new_equation_system</span> <span class="o">=</span> <span class="n">EquationSystem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="p">)</span>

        <span class="c1"># IMPLEMENTATION NOTE: This method imitates the variable creation and equation</span>
        <span class="c1"># setting procedures by calling private methods and accessing private</span>
        <span class="c1"># attributes. This should be acceptable since this is a factory method.</span>

        <span class="c1"># Loop over known variables to preserve DOF order.</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="c1"># Update variables in subsystem.</span>
                <span class="n">new_equation_system</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

                <span class="c1"># Update variable numbers in subsystem.</span>
                <span class="n">new_equation_system</span><span class="o">.</span><span class="n">_variable_dof_type</span><span class="p">[</span>
                    <span class="n">variable</span>
                <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable_dof_type</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>

                <span class="c1"># Create dofs in subsystem.</span>
                <span class="n">new_equation_system</span><span class="o">.</span><span class="n">_append_dofs</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

        <span class="c1"># Loop over known equations to preserve row order.</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">known_equations</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">equations</span><span class="p">:</span>
                <span class="n">equation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="n">image_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equation_image_size_info</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="n">image_composition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equation_image_space_composition</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="c1"># et the information produced in set_equations directly.</span>
                <span class="n">new_equation_system</span><span class="o">.</span><span class="n">_equation_image_space_composition</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">image_composition</span><span class="p">}</span>
                <span class="p">)</span>
                <span class="n">new_equation_system</span><span class="o">.</span><span class="n">_equation_image_size_info</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">image_info</span><span class="p">})</span>
                <span class="n">new_equation_system</span><span class="o">.</span><span class="n">_equations</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">equation</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">new_equation_system</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">equations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Operator</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Dictionary containing names of operators (keys) and operators (values), which</span>
<span class="sd">        have been set as equations in this system.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Variable</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;List containing all :class:`~porepy.numerics.ad.Variable`s known to this</span>
<span class="sd">        system.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">variable_domains</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">GridLike</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;List containing all domains where at least one variable is defined.&quot;&quot;&quot;</span>
        <span class="n">domains</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">:</span>
            <span class="n">domains</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">domains</span><span class="p">)</span>

    <span class="c1">### Variable management ------------------------------------------------------------</span>

<div class="viewcode-block" id="EquationSystem.md_variable"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem.md_variable">[docs]</a>    <span class="k">def</span> <span class="nf">md_variable</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">grids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DomainList</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MixedDimensionalVariable</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a mixed-dimensional variable for a given name-domain list combination.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            name (str): Name of the mixed-dimensional variable.</span>
<span class="sd">            grids (optional): List of grids where the variable is defined. If None</span>
<span class="sd">                (default), all grids where the variable is defined are used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A mixed-dimensional variable.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If variables name exist on both grids and interfaces and domain</span>
<span class="sd">                type is not specified (grids is None).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">grids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span> <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span>
            <span class="c1"># We don&#39;t allow combinations of variables with different domain types</span>
            <span class="c1"># in a md variable.</span>
            <span class="n">heterogeneous_domain</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">):</span>
                <span class="n">heterogeneous_domain</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">):</span>
                <span class="n">heterogeneous_domain</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown domain type for variable&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">heterogeneous_domain</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Variable </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> is defined on multiple domain types.&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">var</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span>
                <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span> <span class="ow">in</span> <span class="n">grids</span>
            <span class="p">]</span>
        <span class="k">return</span> <span class="n">MixedDimensionalVariable</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span></div>

<div class="viewcode-block" id="EquationSystem.create_variables"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem.create_variables">[docs]</a>    <span class="k">def</span> <span class="nf">create_variables</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">dof_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="n">GridEntity</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">subdomains</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">interfaces</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tags</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MixedDimensionalVariable</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates new variables according to specifications.</span>

<span class="sd">        This method does not assign any values to the variable. This has to be done in a</span>
<span class="sd">        subsequent step (e.g. using :meth:`set_var_values`).</span>

<span class="sd">        Examples:</span>
<span class="sd">            An example on how to define a pressure variable with cell-wise one DOF</span>
<span class="sd">            (default) on **all** subdomains and **no** interfaces would be</span>

<span class="sd">            .. code:: Python</span>

<span class="sd">                p = ad_system.create_variables(&#39;pressure&#39;, subdomains=mdg.subdomains())</span>

<span class="sd">        Parameters:</span>
<span class="sd">            name: Name of the variable.</span>
<span class="sd">            dof_info: Dictionary containing information about number of DOFs per</span>
<span class="sd">                admissible type. Defaults to ``{&#39;cells&#39;:1}``.</span>
<span class="sd">            subdomains (optional): List of subdomains on which the variable is defined.</span>
<span class="sd">                If None, then it will not be defined on any subdomain.</span>
<span class="sd">            interfaces (optional): list of interfaces on which the variable is defined.</span>
<span class="sd">                If None, then it will not be defined on any interface.</span>
<span class="sd">            tags (optional): dictionary containing tags for the variables. The tags are</span>
<span class="sd">                assigned to all variables created by this method and can be updated</span>
<span class="sd">                using :meth:`update_variable_tags`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A mixed-dimensional variable with above specifications.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If non-admissible DOF types are used as local DOFs.</span>
<span class="sd">            ValueError: If one attempts to create a variable not defined on any grid.</span>
<span class="sd">            KeyError: If a variable with given name is already defined.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set default value for dof_info. This is a mutable object, so we need to</span>
        <span class="c1"># create a new one each time and not set the default in the signature.</span>
        <span class="k">if</span> <span class="n">dof_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dof_info</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;cells&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>

        <span class="c1"># Sanity check for admissible DOF types.</span>
        <span class="n">requested_type</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dof_info</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">requested_type</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">admissible_dof_types</span><span class="p">)):</span>
            <span class="n">non_admissible</span> <span class="o">=</span> <span class="n">requested_type</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">admissible_dof_types</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Non-admissible DOF types </span><span class="si">{</span><span class="n">non_admissible</span><span class="si">}</span><span class="s2"> requested.&quot;</span><span class="p">)</span>

        <span class="c1"># Sanity check if variable is defined anywhere.</span>
        <span class="k">if</span> <span class="n">subdomains</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">interfaces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot create variable not defined on any subdomain or interface.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Container for all grid variables.</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Merge subdomains and interfaces into a single list.</span>
        <span class="k">assert</span> <span class="n">subdomains</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">interfaces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>  <span class="c1"># for mypy</span>
        <span class="n">grids</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">GridLike</span><span class="p">]</span> <span class="o">=</span> <span class="n">subdomains</span> <span class="k">if</span> <span class="n">subdomains</span> <span class="k">else</span> <span class="n">interfaces</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># Check if a md variable was already defined under that name on any of grids.</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Variable </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> already defined on </span><span class="si">{</span><span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">grids</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">subdomains</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">)</span>  <span class="c1"># mypy</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomain_data</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">)</span>  <span class="c1"># mypy</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_data</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

                <span class="c1"># Prepare data dictionary if this was not done already.</span>
                <span class="k">if</span> <span class="n">pp</span><span class="o">.</span><span class="n">STATE</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">pp</span><span class="o">.</span><span class="n">ITERATE</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">]:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="n">pp</span><span class="o">.</span><span class="n">ITERATE</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

                <span class="c1"># Create grid variable.</span>
                <span class="n">new_variable</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dof_info</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="n">tags</span><span class="p">)</span>

                <span class="c1"># Store it in the system</span>
                <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_variable</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_variable</span><span class="p">)</span>

                <span class="c1"># Append the new DOFs to the global system.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_variable_dof_type</span><span class="p">[</span><span class="n">new_variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">dof_info</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_append_dofs</span><span class="p">(</span><span class="n">new_variable</span><span class="p">)</span>

        <span class="c1"># Create an md variable that wrapps all the individual variables created on</span>
        <span class="c1"># individual grids.</span>
        <span class="n">merged_variable</span> <span class="o">=</span> <span class="n">MixedDimensionalVariable</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_variable</span></div>

<div class="viewcode-block" id="EquationSystem.update_variable_tags"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem.update_variable_tags">[docs]</a>    <span class="k">def</span> <span class="nf">update_variable_tags</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tags</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">variables</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">VariableList</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Assigns tags to variables.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            tag_name: Tag dictionary (tag-value pairs). This will be assigned to all</span>
<span class="sd">                variables in the list.</span>
<span class="sd">            variables: List of variables to which the tag should be assigned. None is</span>
<span class="sd">                interpreted as all variables. If a mixed-dimensional variable is passed,</span>
<span class="sd">                the tags will be assigned to its sub-variables (living on individual</span>
<span class="sd">                grids).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_variable_type</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="n">var</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span></div>

<div class="viewcode-block" id="EquationSystem.get_variables"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem.get_variables">[docs]</a>    <span class="k">def</span> <span class="nf">get_variables</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">VariableList</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">grids</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">GridLike</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tag_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tag_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Variable</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Filter variables based on grid, tag name and tag value.</span>

<span class="sd">        Particular usage: calling without arguments will return all variables in the</span>
<span class="sd">        system.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            variables: List of variables to filter. If None, all variables in the system</span>
<span class="sd">                are included. Variables can be given as a list of variables, mixed-</span>
<span class="sd">                dimensional variables, or variable names (strings).</span>
<span class="sd">            grids: List of grids to filter on. If None, all grids are included.</span>
<span class="sd">            tag_name: Name of the tag to filter on. If None, no filtering on tags.</span>
<span class="sd">            tag_value: Value of the tag to filter on. If None, no filtering on tag</span>
<span class="sd">                values. If tag_name is not None, but tag_value is None, all variables</span>
<span class="sd">                with the given tag_name are returned regardless of value.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of filtered variables.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Shortcut for efficiency.</span>
        <span class="c1"># The same behavior is achieved without this, but it is slower.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">grids</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">tag_name</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">tag_value</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span>

        <span class="c1"># If no variables or grids are given, use full sets.</span>
        <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span>
        <span class="k">if</span> <span class="n">grids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Note: This gives all grids known to variables, not all grids in the</span>
            <span class="c1"># md grid. The result of the filtering will be the same, though.</span>
            <span class="n">grids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable_domains</span>

        <span class="n">filtered_variables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_variable_type</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">:</span>
                <span class="c1"># Add variable if tag_name is not specified or if the variable has the</span>
                <span class="c1"># tag and the tag value matches the requested value.</span>
                <span class="k">if</span> <span class="n">tag_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">filtered_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">tag_name</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">tags</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tag_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">var</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="n">tag_name</span><span class="p">]</span> <span class="o">==</span> <span class="n">tag_value</span><span class="p">:</span>
                        <span class="n">filtered_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">filtered_variables</span></div>

<div class="viewcode-block" id="EquationSystem.get_variable_values"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem.get_variable_values">[docs]</a>    <span class="k">def</span> <span class="nf">get_variable_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">VariableList</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">from_iterate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Assembles an array containing values for the passed variable-like argument.</span>

<span class="sd">        The global order is preserved and independent of the order of the argument.</span>


<span class="sd">        Parameters:</span>
<span class="sd">            variables (optional): VariableType input for which the values are</span>
<span class="sd">                requested. If None (default), the global vector of unknowns is returned.</span>
<span class="sd">            from_iterate (optional): flag to return values stored as ITERATE,</span>
<span class="sd">                instead of STATE (default).</span>

<span class="sd">        Returns:</span>
<span class="sd">            The respective (sub) vector in numerical format, size anywhere between 0 and</span>
<span class="sd">                :meth:`num_dofs`.</span>


<span class="sd">        Raises:</span>
<span class="sd">            KeyError: If no values are stored for the VariableType input.</span>
<span class="sd">            ValueError: If unknown VariableType arguments are passed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_variable_type</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="c1"># Storage for atomic blocks of the sub vector (identified by name-grid pairs).</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Loop over all blocks and process those requested.</span>
        <span class="c1"># This ensures uniqueness and correct order.</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable_numbers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">name</span>
                <span class="n">grid</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">domain</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomain_data</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_data</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
                <span class="c1"># Extract a copy of requested values.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">from_iterate</span><span class="p">:</span>
                        <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="n">pp</span><span class="o">.</span><span class="n">ITERATE</span><span class="p">][</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;No values stored for variable </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;from_iterate=</span><span class="si">{</span><span class="n">from_iterate</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">on grid </span><span class="si">{</span><span class="n">grid</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>

        <span class="c1"># If there are matching blocks, concatenate and return.</span>
        <span class="k">if</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="c1"># Else return an empty vector.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span></div>

<div class="viewcode-block" id="EquationSystem.set_variable_values"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem.set_variable_values">[docs]</a>    <span class="k">def</span> <span class="nf">set_variable_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">VariableList</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">to_state</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">to_iterate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">additive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sets values for a (sub) vector of the global vector of unknowns.</span>

<span class="sd">        The order of values is assumed to fit the global order.</span>

<span class="sd">        Note:</span>
<span class="sd">            The vector is assumed to be of proper size and will be dissected according</span>
<span class="sd">            to the global order, starting with the index 0.</span>
<span class="sd">            Mismatches of is-size and should-be-size according to the subspace specified</span>
<span class="sd">            by ``variables`` will raise respective errors by numpy.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            values: Vector of size corresponding to number of DOFs of the specified</span>
<span class="sd">                variables.</span>
<span class="sd">            variables (optional): VariableType input for which the values are</span>
<span class="sd">                 requested. If None (default), the global vector of unknowns will be</span>
<span class="sd">                 set.</span>
<span class="sd">            to_state (optional): Flag to write values to ``pp.STATE``.</span>
<span class="sd">            to_iterate (optional): Flag to write values to ``pp.ITERATE``.</span>

<span class="sd">            additive (optional): Flag to write values additively. To be used in</span>
<span class="sd">                iterative procedures.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If unknown VariableType arguments are passed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Start of dissection.</span>
        <span class="n">dof_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dof_end</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_variable_type</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">variable_number</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable_numbers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">name</span>
                <span class="n">grid</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">domain</span>
                <span class="n">num_dofs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variable_num_dofs</span><span class="p">[</span><span class="n">variable_number</span><span class="p">])</span>
                <span class="n">dof_end</span> <span class="o">=</span> <span class="n">dof_start</span> <span class="o">+</span> <span class="n">num_dofs</span>
                <span class="c1"># Extract local vector.</span>
                <span class="c1"># This will raise errors if indexation is out of range.</span>
                <span class="n">local_vec</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">dof_start</span><span class="p">:</span><span class="n">dof_end</span><span class="p">]</span>
                <span class="c1"># Fetch the storage from the relevant dicitonary in the</span>
                <span class="c1"># MixedDimensionalGrid.</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomain_data</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_data</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

                <span class="c1"># Data dict will have pp.STATE and pp.ITERATE entries already created</span>
                <span class="c1"># during create_variables. If an error is returned here, a variable has</span>
                <span class="c1"># been created in a non-standard way.</span>
                <span class="c1"># Store new values as requested.</span>
                <span class="k">if</span> <span class="n">additive</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">to_iterate</span><span class="p">:</span>
                        <span class="c1"># No need for a copy here, since we are adding to an existing</span>
                        <span class="c1"># array.</span>
                        <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="n">pp</span><span class="o">.</span><span class="n">ITERATE</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">+=</span> <span class="n">local_vec</span>
                    <span class="k">if</span> <span class="n">to_state</span><span class="p">:</span>
                        <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">+=</span> <span class="n">local_vec</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">to_iterate</span><span class="p">:</span>
                        <span class="c1"># The copy is critcial here.</span>
                        <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="n">pp</span><span class="o">.</span><span class="n">ITERATE</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_vec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">to_state</span><span class="p">:</span>
                        <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">STATE</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_vec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># Move dissection forward.</span>
                <span class="n">dof_start</span> <span class="o">=</span> <span class="n">dof_end</span>

        <span class="c1"># Last sanity check if the vector was properly sized, or if it was too large.</span>
        <span class="c1"># This imposes a theoretically unnecessary restriction on the input argument</span>
        <span class="c1"># since we only require a vector of at least this size.</span>
        <span class="k">assert</span> <span class="n">dof_end</span> <span class="o">==</span> <span class="n">values</span><span class="o">.</span><span class="n">size</span></div>

    <span class="c1">### DOF management -----------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">_append_dofs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">ad</span><span class="o">.</span><span class="n">Variable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Appends DOFs for a newly created variable.</span>

<span class="sd">        Must only be called by :meth:`create_variables`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            variable: The newly created variable</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># number of totally created dof blocks so far</span>
        <span class="n">last_variable_number</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variable_numbers</span><span class="p">)</span>

        <span class="c1"># Sanity check that no previous data is overwritten. This should not happen,</span>
        <span class="c1"># if class not used in hacky way.</span>
        <span class="k">assert</span> <span class="n">variable</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable_numbers</span>

        <span class="c1"># Count number of dofs for this variable on this grid and store it.</span>
        <span class="c1"># The number of dofs for each dof type defaults to zero.</span>

        <span class="n">local_dofs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable_dof_type</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
        <span class="c1"># Both subdomains and interfaces have cell variables.</span>
        <span class="n">num_dofs</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">num_cells</span> <span class="o">*</span> <span class="n">local_dofs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># For subdomains, but not interfaces, we also need to account for faces and</span>
        <span class="c1"># nodes.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">):</span>
            <span class="n">num_dofs</span> <span class="o">+=</span> <span class="n">variable</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">num_faces</span> <span class="o">*</span> <span class="n">local_dofs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s2">&quot;faces&quot;</span><span class="p">,</span> <span class="mi">0</span>
            <span class="p">)</span> <span class="o">+</span> <span class="n">variable</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">num_nodes</span> <span class="o">*</span> <span class="n">local_dofs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nodes&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Update the global dofs and block numbers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_variable_numbers</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">variable</span><span class="p">:</span> <span class="n">last_variable_number</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_variable_num_dofs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_variable_num_dofs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">num_dofs</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)]</span>
        <span class="p">)</span>

        <span class="c1"># first optimization of Jacobian structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cluster_dofs_gridwise</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_cluster_dofs_gridwise</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Re-arranges the DOFs grid-wise s.t. we obtain grid-blocks in the column sense</span>
<span class="sd">        and reduce the matrix bandwidth.</span>

<span class="sd">        The aim is to impose a more block-diagonal-like structure on the Jacobian where</span>
<span class="sd">        blocks in the column sense represent single grids in the following order:</span>

<span class="sd">        Note:</span>
<span class="sd">            Off-diagonal blocks will still be present if subdomain-interface variables</span>
<span class="sd">            are defined.</span>

<span class="sd">        1. For each grid in ``mdg.subdomains``</span>
<span class="sd">            1. For each variable defined on that grid</span>
<span class="sd">        2. For each grid in ``mdg.interfaces``</span>
<span class="sd">            1. For each variable defined on that mortar grid</span>

<span class="sd">        The order of variables per grid is given by the order of variable creation</span>
<span class="sd">        (stored as order of keys in ``self.variables``).</span>

<span class="sd">        This method is called after each creation of variables and respective DOFs.</span>
<span class="sd">        TODO: Revisit. I think I have broken it by looping over _variables instead of</span>
<span class="sd">        subdomains and interfaces.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Data stracture for the new order of dofs.</span>
        <span class="n">new_variable_counter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">new_variable_numbers</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Variable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">new_block_dofs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">:</span>
            <span class="c1"># If this variable-grid combination is present, add it to the new</span>
            <span class="c1"># order of dofs.</span>
            <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable_numbers</span><span class="p">:</span>
                <span class="c1"># Extract created number of dofs</span>
                <span class="n">local_dofs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable_num_dofs</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_variable_numbers</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
                <span class="p">]</span>

                <span class="c1"># Store new block number and dofs in new order.</span>
                <span class="n">new_block_dofs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">local_dofs</span><span class="p">)</span>
                <span class="n">new_variable_numbers</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">variable</span><span class="p">:</span> <span class="n">new_variable_counter</span><span class="p">})</span>
                <span class="n">new_variable_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Replace old block order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_variable_num_dofs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_block_dofs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_variable_numbers</span> <span class="o">=</span> <span class="n">new_variable_numbers</span>

    <span class="k">def</span> <span class="nf">_parse_variable_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">VariableList</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Variable</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Parse the input argument for the variable type.</span>

<span class="sd">        This method is used to parse the input argument for the variable type in</span>
<span class="sd">        several exposed methods, allowing the user to specify a single variable or a</span>
<span class="sd">        list of variables more flexibly.</span>

<span class="sd">        There is no filtering of the variables, for instance:</span>

<span class="sd">            - No assumptions should be made on the order of the parsed variables.</span>
<span class="sd">            - The variable list is not uniquified; if the same variable is passed twice</span>
<span class="sd">              (say, as a Variable and by its string), it will duplicated in the list of</span>
<span class="sd">              parsed variables.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            variables: The input argument for the variable type.</span>
<span class="sd">                The following interpretation rules are applied:</span>
<span class="sd">                    - If None, return all variables.</span>
<span class="sd">                    - If a list of variables, return same.</span>
<span class="sd">                    - If a list of strings, return all variables with those names.</span>
<span class="sd">                    - If mixed-dimensional variable, return sub-variables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of Variables.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_variables</span><span class="p">()</span>
        <span class="n">parsed_variables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">MixedDimensionalVariable</span><span class="p">):</span>
                <span class="n">parsed_variables</span> <span class="o">+=</span> <span class="n">variable</span><span class="o">.</span><span class="n">sub_vars</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="n">parsed_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># Use _variables to avoid recursion (get_variables() calls this method)</span>
                <span class="nb">vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span> <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">variable</span><span class="p">]</span>
                <span class="n">parsed_variables</span> <span class="o">+=</span> <span class="nb">vars</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Variable type must be a string or a Variable, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">type</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">parsed_variables</span>

    <span class="k">def</span> <span class="nf">_gridbased_variable_complement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="n">VariableList</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Variable</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Finds the grid-based complement of a variable-like structure.</span>

<span class="sd">        The grid-based complement consists of all variables known to this</span>
<span class="sd">        EquationSystem, but which are not in the passed list ``variables``.</span>

<span class="sd">        TODO: Revisit. This method is not used anywhere, and I am not sure it is</span>
<span class="sd">        correct/does what it is supposed to do.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># strings and md variables represent always a whole in the variable sense. Hence,</span>
        <span class="c1"># the complement is empty</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">MixedDimensionalVariable</span><span class="p">)):</span>
            <span class="c1"># TODO: Can we drop this, or is it possible that a single variable has made</span>
            <span class="c1"># it into this subroutine?</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># non sequential var-like structure</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid_variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="c1"># same processing as above, only grid variables are of interest</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                    <span class="n">md_variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_variable</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="n">grid_variables</span> <span class="o">+=</span> <span class="p">[</span>
                        <span class="n">var</span>
                        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">md_variable</span><span class="o">.</span><span class="n">sub_vars</span>
                        <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">domain</span> <span class="o">!=</span> <span class="n">variable</span><span class="o">.</span><span class="n">domain</span>
                    <span class="p">]</span>
            <span class="c1"># return a unique collection</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">grid_variables</span><span class="p">))</span>

<div class="viewcode-block" id="EquationSystem.num_dofs"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem.num_dofs">[docs]</a>    <span class="k">def</span> <span class="nf">num_dofs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns the total number of dofs managed by this system.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variable_num_dofs</span><span class="p">))</span>  <span class="c1"># cast numpy.int64 into Python int</span></div>

<div class="viewcode-block" id="EquationSystem.projection_to"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem.projection_to">[docs]</a>    <span class="k">def</span> <span class="nf">projection_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">VariableList</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a projection matrix from the global vector of unknowns to a specified</span>
<span class="sd">        subspace.</span>

<span class="sd">        The transpose of the returned matrix can be used to slice respective columns out</span>
<span class="sd">        of the global Jacobian.</span>

<span class="sd">        The projection preserves the global order defined by the system, i.e. it</span>
<span class="sd">        includes no permutation.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            variables (optional): VariableType input for which the subspace is</span>
<span class="sd">                requested. If no subspace is specified using ``variables``,</span>
<span class="sd">                a null-space projection is returned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            a sparse projection matrix of shape ``(M, num_dofs)``, where</span>
<span class="sd">            ``0 &lt;= M &lt;= num_dofs``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># current number of total dofs</span>
        <span class="n">num_dofs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dofs</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">variables</span><span class="p">:</span>
            <span class="c1"># Array for the indices associated with argument.</span>
            <span class="c1"># The sort is needed so as not to permute the columns of the projection.</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dofs_of</span><span class="p">(</span><span class="n">variables</span><span class="p">))</span>
            <span class="c1"># case where no dofs where found for the VariableType input</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_dofs</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subspace_size</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span>
                <span class="k">return</span> <span class="n">sps</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">subspace_size</span><span class="p">),</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">subspace_size</span><span class="p">),</span> <span class="n">indices</span><span class="p">)),</span>
                    <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">subspace_size</span><span class="p">,</span> <span class="n">num_dofs</span><span class="p">),</span>
                <span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="c1"># Case where the subspace is null, i.e. no variables specified</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_dofs</span><span class="p">))</span></div>

<div class="viewcode-block" id="EquationSystem.dofs_of"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem.dofs_of">[docs]</a>    <span class="k">def</span> <span class="nf">dofs_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="n">VariableList</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the indices in the global vector of unknowns belonging to the variable(s).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            variables: VariableType input for which the indices are requested.</span>

<span class="sd">        Returns:</span>
<span class="sd">            an order-preserving array of indices of DOFs belonging to the VariableType input.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if unknown VariableType arguments are passed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_variable_type</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="n">global_variable_dofs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variable_num_dofs</span><span class="p">)))</span>

        <span class="c1"># Storage of indices per requested variable.</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="n">var_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable_numbers</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span>
            <span class="n">var_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                <span class="n">global_variable_dofs</span><span class="p">[</span><span class="n">var_number</span><span class="p">],</span>
                <span class="n">global_variable_dofs</span><span class="p">[</span><span class="n">var_number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_indices</span><span class="p">)</span>

        <span class="c1"># Concatenate indices, if any</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span></div>

<div class="viewcode-block" id="EquationSystem.identify_dof"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem.identify_dof">[docs]</a>    <span class="k">def</span> <span class="nf">identify_dof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dof</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Variable</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Identifies the variable to which a specific DOF index belongs.</span>

<span class="sd">        The intended use is to help identify entries in the global vector or the column</span>
<span class="sd">        of the Jacobian.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            dof: a single index in the global vector.</span>

<span class="sd">        Returns: the identified Variable object.</span>

<span class="sd">        Raises:</span>
<span class="sd">            KeyError: if the dof is out of range (larger than ``num_dofs`` or smaller</span>
<span class="sd">                than 0).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_dofs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dofs</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">dof</span> <span class="o">&lt;</span> <span class="n">num_dofs</span><span class="p">):</span>  <span class="c1"># indices go from 0 to num_dofs - 1</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Dof index out of range.&quot;</span><span class="p">)</span>

        <span class="n">global_variable_dofs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_variable_num_dofs</span><span class="p">)))</span>
        <span class="c1"># Find the variable number belonging to this index</span>
        <span class="n">variable_number</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">global_variable_dofs</span> <span class="o">&gt;</span> <span class="n">dof</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># Get the variable key from _variable_numbers</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">var</span> <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable_numbers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="n">variable_number</span>
        <span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">variable</span></div>

    <span class="c1">### Equation management -------------------------------------------------------------------</span>

<div class="viewcode-block" id="EquationSystem.set_equation"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem.set_equation">[docs]</a>    <span class="k">def</span> <span class="nf">set_equation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">equation</span><span class="p">:</span> <span class="n">Operator</span><span class="p">,</span>
        <span class="n">grids</span><span class="p">:</span> <span class="n">DomainList</span><span class="p">,</span>
        <span class="n">equations_per_grid_entity</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">GridEntity</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sets an equation using the passed operator and uses its name as an identifier.</span>

<span class="sd">        If an equation already exists under that name, it is overwritten.</span>

<span class="sd">        Information about the image space must be provided for now, such that grid-wise</span>
<span class="sd">        row slicing is possible. This will hopefully be provided automatically in the</span>
<span class="sd">        future.</span>

<span class="sd">        Note:</span>
<span class="sd">            Regarding the number of equations, this method assumes that the AD framework</span>
<span class="sd">            assembles row blocks per grid in subdomains, then per grid in interfaces,</span>
<span class="sd">            for each operator representing an equation. This is assumed to be the way</span>
<span class="sd">            PorePy AD works.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            equation: An equation in AD operator form, assuming the right-hand side is</span>
<span class="sd">                zero and this instance represents the left-hand side.</span>
<span class="sd">            grids: A list of subdomain *or* interface grids on which the equation is</span>
<span class="sd">                defined.</span>
<span class="sd">            equations_per_grid_entity: a dictionary describing how many equations</span>
<span class="sd">                ``equation_operator`` provides. This is a temporary work-around until</span>
<span class="sd">                operators are able to provide information on their image space.</span>
<span class="sd">                The dictionary must contain the number of equations per grid entity</span>
<span class="sd">                (cells, faces, nodes) for the operator.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the equation operator has a name already assigned to a</span>
<span class="sd">                previously set equation.</span>
<span class="sd">            ValueError: If the equation is defined on both subdomains and interfaces.</span>
<span class="sd">            AssertionError: If the equation is defined on an unknown grid.</span>
<span class="sd">            ValueError: If indicated number of equations does not match the actual</span>
<span class="sd">                number as per evaluation of operator.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The grid list is changed in place, so we need to make a copy</span>
        <span class="n">grids</span> <span class="o">=</span> <span class="n">grids</span><span class="p">[:]</span>
        <span class="c1"># The function loops over all grids the operator is defined on and calculate the</span>
        <span class="c1"># number of equations per grid quantity (cell, face, node). This information</span>
        <span class="c1"># is then stored together with the equation itself.</span>
        <span class="n">image_info</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">GridLike</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">total_num_equ</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># The domain of this equation is the set of grids on which it is defined</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">equation</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The name of the equation operator is already used by another equation:&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Make sure your equations are uniquely named.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># If no grids are specified, there is nothing to do</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">grids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_equation_image_space_composition</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">image_info</span><span class="p">})</span>
            <span class="c1"># Information on the size of the equation, in terms of the grids it is defined</span>
            <span class="c1"># on.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_equation_image_size_info</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">equations_per_grid_entity</span><span class="p">})</span>
            <span class="c1"># Store the equation itself.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">equation</span><span class="p">})</span>
            <span class="k">return</span>

        <span class="c1"># We require that equations are defined either on a set of subdomains, or a set</span>
        <span class="c1"># of interfaces. The combination of the two is mathematically possible, provided</span>
        <span class="c1"># a sufficiently general notation is used, but the chances of this being</span>
        <span class="c1"># misused is considered high compared to the benefits of allowing such combined</span>
        <span class="c1"># domains, and we therefore disallow it.</span>

        <span class="n">all_subdomains</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">])</span>
        <span class="n">all_interfaces</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">])</span>

        <span class="c1"># Allow for no subdomains or interfaces here (case &lt; 1). This is relevant for</span>
        <span class="c1"># equations stated for general md problems, but on domains that happened not to</span>
        <span class="c1"># have, e.g., fractures.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_interfaces</span> <span class="o">+</span> <span class="n">all_subdomains</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="s2">&quot;An equation should not be defined on both subdomains and interfaces.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># We loop over the subdomains and interfaces in that order to assert a correct</span>
        <span class="c1"># indexation according to the global order (for grid in sds, for grid in intfs).</span>
        <span class="c1"># The user does not have to care about the order in grids.</span>
        <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">:</span>
                <span class="c1"># Equations on subdomains can be defined on any grid quantity.</span>
                <span class="n">num_equ_per_grid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="n">sd</span><span class="o">.</span><span class="n">num_cells</span> <span class="o">*</span> <span class="n">equations_per_grid_entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">sd</span><span class="o">.</span><span class="n">num_nodes</span> <span class="o">*</span> <span class="n">equations_per_grid_entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nodes&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">sd</span><span class="o">.</span><span class="n">num_faces</span> <span class="o">*</span> <span class="n">equations_per_grid_entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;faces&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="c1"># Row indices for this grid, cast to integers.</span>
                <span class="n">block_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_equ_per_grid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="n">total_num_equ</span>
                <span class="c1"># Cumulate total number of equations.</span>
                <span class="n">total_num_equ</span> <span class="o">+=</span> <span class="n">num_equ_per_grid</span>
                <span class="c1"># Store block idx per grid.</span>
                <span class="n">image_info</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">sd</span><span class="p">:</span> <span class="n">block_idx</span><span class="p">})</span>
                <span class="c1"># Remove the subdomain from the domain list.</span>
                <span class="c1"># Ignore mypy error here, since we know that sd is in grids.</span>
                <span class="n">grids</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="k">for</span> <span class="n">intf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interfaces</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">intf</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">:</span>
                <span class="c1"># Equations on interfaces can only be defined on cells.</span>
                <span class="n">num_equ_per_grid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="n">intf</span><span class="o">.</span><span class="n">num_cells</span> <span class="o">*</span> <span class="n">equations_per_grid_entity</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="c1"># Row indices for this grid, cast to integers.</span>
                <span class="n">block_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_equ_per_grid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="n">total_num_equ</span>
                <span class="c1"># Cumulate total number of equations.</span>
                <span class="n">total_num_equ</span> <span class="o">+=</span> <span class="n">num_equ_per_grid</span>
                <span class="c1"># Store block idx per grid</span>
                <span class="n">image_info</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">intf</span><span class="p">:</span> <span class="n">block_idx</span><span class="p">})</span>
                <span class="c1"># Remove the grid from the domain list</span>
                <span class="c1"># Ignore mypy error here, since we know that intf is in grids.</span>
                <span class="n">grids</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">intf</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># Assert the equation is not defined on an unknown domain.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">grids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># If all good, we store the information:</span>
        <span class="c1"># The rows (referring to a global indexation) that this equation provides.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_equation_image_space_composition</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">image_info</span><span class="p">})</span>
        <span class="c1"># Information on the size of the equation, in terms of the grids it is defined</span>
        <span class="c1"># on.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_equation_image_size_info</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">equations_per_grid_entity</span><span class="p">})</span>
        <span class="c1"># Store the equation itself.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">equation</span><span class="p">})</span></div>

<div class="viewcode-block" id="EquationSystem.remove_equation"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem.remove_equation">[docs]</a>    <span class="k">def</span> <span class="nf">remove_equation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Operator</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Removes a previously set equation and all related information.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A reference to the equation in operator form or None, if the equation is</span>
<span class="sd">            unknown.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If an unknown equation is attempted removed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">:</span>
            <span class="c1"># Remove the equation from the storage</span>
            <span class="n">equ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="c1"># Remove the image space information.</span>
            <span class="c1"># Note that there is no need to modify the numbering of the other equations,</span>
            <span class="c1"># since this is a local (to the equation) numbering.</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equation_image_space_composition</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">equ</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot remove unknown equation </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

    <span class="c1">### System assembly and discretization ----------------------------------------------------</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_recursive_discretization_search</span><span class="p">(</span><span class="n">operator</span><span class="p">:</span> <span class="n">Operator</span><span class="p">,</span> <span class="n">discr</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Recursive search in the tree of this operator to identify all discretizations</span>
<span class="sd">        represented in the operator.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            operator: top level operator to be searched.</span>
<span class="sd">            discr: list storing found discretizations</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Go further in recursion</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">discr</span> <span class="o">+=</span> <span class="n">EquationSystem</span><span class="o">.</span><span class="n">_recursive_discretization_search</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">list</span><span class="p">())</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">_ad_utils</span><span class="o">.</span><span class="n">MergedOperator</span><span class="p">):</span>
            <span class="c1"># We have reached the bottom; this is a discretization (example: mpfa.flux)</span>
            <span class="n">discr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">discr</span>

    <span class="k">def</span> <span class="nf">_parse_equations</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">equations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">EquationList</span> <span class="o">|</span> <span class="n">EquationRestriction</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Helper method to parse equations into a properly ordered structure.</span>

<span class="sd">        The equations will be ordered according to the order in self._equations (which</span>
<span class="sd">        is the order in which they were added to the equation system manager and which</span>
<span class="sd">        alsois fixed since iteration of dictionaries is so).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            equations: A list of equations or a dictionary of equation restrictions.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary with the index set of the restricted equations (referring to</span>
<span class="sd">            equation rows) as values. If no restriction is given, the value is None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The default return value is all equations with no grid restrictions.</span>
        <span class="k">if</span> <span class="n">equations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">)</span>

        <span class="c1"># We need to parse the input.</span>
        <span class="c1"># Storage for requested blocks, unique information per equation name.</span>
        <span class="n">requested_row_blocks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># Storage for restricted equations.</span>
        <span class="n">restricted_equations</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Get the row indices (in the global system) associated with this equation.</span>
        <span class="c1"># If the equation is restricted (the user has provided a dictionary with</span>
        <span class="c1"># grids on which the equation should be evaluated), the variable blocks</span>
        <span class="c1"># will contain only the row indices associated with the restricted grids.</span>

        <span class="k">for</span> <span class="n">equation</span> <span class="ow">in</span> <span class="n">equations</span><span class="p">:</span>
            <span class="c1"># Store restrictions, using different storage for restricted and</span>
            <span class="c1"># unrestricted equations.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">equations</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_single_equation</span><span class="p">({</span><span class="n">equation</span><span class="p">:</span> <span class="n">equations</span><span class="p">[</span><span class="n">equation</span><span class="p">]})</span>
                <span class="c1"># A dictionary means the equation is restricted to a subset of grids.</span>
                <span class="n">restricted_equations</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This equation is not restricted to a subset of grids.</span>
                <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_single_equation</span><span class="p">(</span><span class="n">equation</span><span class="p">)</span>
                <span class="n">requested_row_blocks</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

        <span class="c1"># Update the requested blocks with the restricted to overwrite the indices if</span>
        <span class="c1"># an equation was passed in both restricted and unrestricted structure.</span>
        <span class="n">requested_row_blocks</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">restricted_equations</span><span class="p">)</span>

        <span class="c1"># Build the restricted set of equations, using the order in self._equations.</span>
        <span class="c1"># The latter is critical for ensuring determinism of the system.</span>
        <span class="n">ordered_blocks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">equation</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">:</span>
            <span class="c1"># By now, all equations are contained in requested_row_blocks.</span>
            <span class="k">if</span> <span class="n">equation</span> <span class="ow">in</span> <span class="n">requested_row_blocks</span><span class="p">:</span>
                <span class="n">ordered_blocks</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">equation</span><span class="p">:</span> <span class="n">requested_row_blocks</span><span class="p">[</span><span class="n">equation</span><span class="p">]})</span>

        <span class="k">return</span> <span class="n">ordered_blocks</span>

    <span class="k">def</span> <span class="nf">_parse_single_equation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">equation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Operator</span> <span class="o">|</span> <span class="n">EquationRestriction</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Helper method to identify possible restrictions of a single equation.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            equation: Equation to be parsed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary with the name of the equation as key and the corresponding</span>
<span class="sd">            restricted indices as values. If no restriction is given, the value is None.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If an unknown equation name is requested.</span>
<span class="sd">            ValueError: If an unknown operator is requested.</span>
<span class="sd">            ValueError: If an equation is requested restricted to a grid on which it is</span>
<span class="sd">                not defined.</span>
<span class="sd">            TypeError: If the input is not an equation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the equation is a dictionary, the dictionary values are grids (subdomains</span>
        <span class="c1"># or interfaces) that defines restrictions of the equation; these must be</span>
        <span class="c1"># identified. If the equation is not a dictionary, there will be restriction.</span>

        <span class="c1"># Equation represented by string - return the corresponding equation.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">equation</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">equation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown equation name </span><span class="si">{</span><span class="n">equation</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">equation</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

        <span class="c1"># Equation represented by Operator. Return the</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">equation</span><span class="p">,</span> <span class="n">Operator</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">equation</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown equation operator </span><span class="si">{</span><span class="n">equation</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="c1"># No restriction.</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">equation</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

        <span class="c1"># Equations represented by dict with restriction to grids: get target row</span>
        <span class="c1"># indices.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">equation</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>

            <span class="n">block</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">equ</span><span class="p">,</span> <span class="n">grids</span> <span class="ow">in</span> <span class="n">equation</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># equ is an identifier of the equation (either a string or an operator)</span>
                <span class="c1"># grids is a list of grids (subdomains or interfaces) that defines</span>
                <span class="c1"># a restriction of the equation domain.</span>

                <span class="c1"># Translate equ into a name (string).</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">equ</span><span class="p">,</span> <span class="n">Operator</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">equ</span><span class="o">.</span><span class="n">name</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown equation name </span><span class="si">{</span><span class="n">equation</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">equ</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">equ</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown equation operator </span><span class="si">{</span><span class="n">equation</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Item (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">equ</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">grids</span><span class="p">)</span><span class="si">}</span><span class="s2">) not parsable as equation.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Get the indices associated with this equation.</span>
                <span class="n">img_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equation_image_space_composition</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

                <span class="c1"># Check if the user requests a properly defined subsets of the grids</span>
                <span class="c1"># associated with this equation.</span>
                <span class="n">unknown_grids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">grids</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">img_info</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unknown_grids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Getting an error here means the user has requested a grid that is</span>
                    <span class="c1"># not associated with this equation. This is not a meaningful</span>
                    <span class="c1"># operation.</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Equation </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> not defined on grids </span><span class="si">{</span><span class="n">unknown_grids</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># The indices (row indices in the global system) associated with this</span>
                <span class="c1"># equation and the grids requested by the user.</span>
                <span class="n">block_idx</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

                <span class="c1"># Loop over image space information to ensure correct order.</span>
                <span class="c1"># Note that looping over the grids risks that the order does not</span>
                <span class="c1"># correspond to the order in the equation was defined. This will surely</span>
                <span class="c1"># lead to trouble down the line.</span>
                <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">img_info</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">:</span>
                        <span class="n">block_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_info</span><span class="p">[</span><span class="n">grid</span><span class="p">])</span>
                <span class="c1"># If indices not empty, concatenate and return</span>
                <span class="k">if</span> <span class="n">block_idx</span><span class="p">:</span>
                    <span class="n">block</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">block_idx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)})</span>
                <span class="c1"># indices should by logic always be found, if not alert the user.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># TODO: Should this not be permissible, say, due to a filtering of</span>
                    <span class="c1"># the grids? However, it may lead to errors downstream.</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Equation-like item (</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">equ</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">grids</span><span class="p">)</span><span class="si">}</span><span class="s2">) yielded no rows.&quot;</span>
                    <span class="p">)</span>
            <span class="k">return</span> <span class="n">block</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Getting an error here means the user has passed a type that is not</span>
            <span class="c1"># an equation.</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">equation</span><span class="p">)</span><span class="si">}</span><span class="s2"> not parsable as an equation.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_gridbased_equation_complement</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">equations</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Takes the information from equation parsing and finds for each equation</span>
<span class="sd">        (identified by its name string) the indices which were excluded in the</span>
<span class="sd">        grid-sense.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            equations: Dictionary with equation names as keys and indices as values.</span>
<span class="sd">                The indices are the indices of the rows in the global system that</span>
<span class="sd">                were included in the last parsing of the equations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary with the name of the equation as key and the grid-complement</span>
<span class="sd">            as values. If the complement is empty, the value is None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">complement</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">equations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># If indices were filtered based on grids, we find the complementing</span>
            <span class="c1"># indices.</span>
            <span class="c1"># If idx is None, this means no filtering was done.</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Get the indices associated with this equation.</span>
                <span class="n">img_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equation_image_space_composition</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

                <span class="c1"># Ensure ordering and uniqueness of equation indexation.</span>
                <span class="n">img_values</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">img_info</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="n">all_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">img_values</span><span class="p">))</span>

                <span class="c1"># Complementing indices are found by deleting the filtered indices.</span>
                <span class="n">complement_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">all_idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                <span class="n">complement</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">complement_idx</span><span class="p">})</span>

            <span class="c1"># If there was no grid-based row filtering, the complement is empty.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">complement</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="kc">None</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">complement</span>

<div class="viewcode-block" id="EquationSystem.discretize"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem.discretize">[docs]</a>    <span class="k">def</span> <span class="nf">discretize</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">equations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">EquationList</span> <span class="o">|</span> <span class="n">EquationRestriction</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Find and loop over all discretizations in the equation operators, extract</span>
<span class="sd">        unique references and discretize.</span>

<span class="sd">        This is more efficient than discretizing on the Operator level, since</span>
<span class="sd">        discretizations which occur more than once in a set of equations will be</span>
<span class="sd">        identified and only discretized once.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            equations (optional): A subset of equations. If not provided (None), all</span>
<span class="sd">                known equations will be discretized.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">equation_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parse_equations</span><span class="p">(</span><span class="n">equations</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># List containing all discretizations</span>
        <span class="n">discr</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># TODO: the search can be done once (in some kind of initialization). Revisit</span>
        <span class="c1"># this during update of the Ad machinery.</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">equation_names</span><span class="p">:</span>
            <span class="c1"># this raises a key error if a given equation name is unknown</span>
            <span class="n">eqn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="c1"># This will expand the list discr with new discretizations.</span>
            <span class="c1"># The list may contain duplicates.</span>
            <span class="n">discr</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursive_discretization_search</span><span class="p">(</span><span class="n">eqn</span><span class="p">,</span> <span class="nb">list</span><span class="p">())</span>

        <span class="c1"># Uniquify to save computational time, then discretize.</span>
        <span class="n">unique_discr</span> <span class="o">=</span> <span class="n">_ad_utils</span><span class="o">.</span><span class="n">uniquify_discretization_list</span><span class="p">(</span><span class="n">discr</span><span class="p">)</span>
        <span class="n">_ad_utils</span><span class="o">.</span><span class="n">discretize_from_list</span><span class="p">(</span><span class="n">unique_discr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="p">)</span></div>

<div class="viewcode-block" id="EquationSystem.assemble"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem.assemble">[docs]</a>    <span class="k">def</span> <span class="nf">assemble</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Assemble Jacobian matrix and residual vector of the whole system.</span>

<span class="sd">        This is a shallow wrapper of :meth:`assemble_subsystem`. Here, the subsystem is</span>
<span class="sd">        the complete set of equations, variables and grids.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            state (optional): see :meth:`assemble_subsystem`. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple containing</span>
<span class="sd">                sps.spmatrix: Jacobian matrix corresponding to the targeted state.</span>
<span class="sd">                The ordering of the equations (rows) is determined by the order the</span>
<span class="sd">                equations were added. The DOFs (columns) are ordered according to the</span>
<span class="sd">                global order.</span>

<span class="sd">                np.ndarray: Residual vector corresponding to the targeted state, scaled</span>
<span class="sd">                by -1 (moved to rhs).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assemble_subsystem</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="n">state</span><span class="p">)</span></div>

<div class="viewcode-block" id="EquationSystem.assemble_subsystem"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem.assemble_subsystem">[docs]</a>    <span class="k">def</span> <span class="nf">assemble_subsystem</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">equations</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">EquationList</span> <span class="o">|</span> <span class="n">EquationRestriction</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">VariableList</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Assemble Jacobian matrix and residual vector using a specified subset of</span>
<span class="sd">        equations, variables and grids.</span>

<span class="sd">        The method is intended for use in splitting algorithms. Matrix blocks not</span>
<span class="sd">        included will simply be sliced out.</span>

<span class="sd">        Note:</span>
<span class="sd">            The ordering of columns in the returned system are defined by the global</span>
<span class="sd">            DOF order. The row blocks are in the same order as equations were added to</span>
<span class="sd">            this system. If an equation is defined on multiple grids, the respective</span>
<span class="sd">            row-block is internally ordered as given by the mixed-dimensional grid</span>
<span class="sd">            (for sd in subdomains, for intf in interfaces).</span>

<span class="sd">            The columns of the subsystem are assumed to be properly defined by</span>
<span class="sd">            ``variables``, otherwise a matrix of shape ``(M,)`` is returned. This</span>
<span class="sd">            happens if grid variables are passed which are unknown to this</span>
<span class="sd">            :class:`EquationSystem`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            equations (optional): a subset of equations to which the subsystem should be</span>
<span class="sd">                restricted. If not provided (None), all equations known to this</span>
<span class="sd">                :class:`EquationSystem` will be included.</span>

<span class="sd">                The user can specify grids per equation (name) to which the subsystem</span>
<span class="sd">                should be restricted in the row-sense. Grids not belonging to the domain</span>
<span class="sd">                of an equation will raise an error.</span>

<span class="sd">            variables (optional): VariableType input specifying the subspace in</span>
<span class="sd">                column-sense. If not provided (None), all variables will be included.</span>
<span class="sd">            state (optional): State vector to assemble from. By default, the stored</span>
<span class="sd">                ``pp.ITERATE`` or ``pp.STATE`` are used, in that order.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple with two elements</span>

<span class="sd">                spmatrix: (Part of the) Jacobian matrix corresponding to the targeted</span>
<span class="sd">                variable state, for the specified equations and variables.</span>
<span class="sd">                ndarray: Residual vector corresponding to the targeted variable state,</span>
<span class="sd">                for the specified equations. Scaled with -1 (moved to rhs).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span>

        <span class="c1"># equ_blocks is a dictionary with equation names as keys and the corresponding</span>
        <span class="c1"># row indices of the equations. If the user has requested that equations are</span>
        <span class="c1"># restricted to a subset of grids, the row indices are restricted accordingly.</span>
        <span class="c1"># If no such request has been made, the value is None.</span>
        <span class="n">equ_blocks</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_equations</span><span class="p">(</span><span class="n">equations</span><span class="p">)</span>

        <span class="c1"># Data structures for building matrix and residual vector</span>
        <span class="n">mat</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rhs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Keep track of DOFs for each equation/block</span>
        <span class="n">ind_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembled_equation_indices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Iterate over equations, assemble.</span>
        <span class="c1"># Also keep track of the row indices of each equation, and store it in</span>
        <span class="c1"># assembled_equation_indices.</span>
        <span class="k">for</span> <span class="n">equ_name</span><span class="p">,</span> <span class="n">rows</span> <span class="ow">in</span> <span class="n">equ_blocks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># This will raise a key error if the equation name is unknown.</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">[</span><span class="n">equ_name</span><span class="p">]</span>
            <span class="n">ad</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

            <span class="c1"># If restriction to grid-related row blocks was made,</span>
            <span class="c1"># perform row slicing based on information we have obtained from parsing.</span>
            <span class="k">if</span> <span class="n">rows</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">jac</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()[</span><span class="n">rows</span><span class="p">])</span>
                <span class="n">rhs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="n">rows</span><span class="p">])</span>
                <span class="n">block_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># If no grid-related row restriction was made, append the whole thing.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">jac</span><span class="p">)</span>
                <span class="n">rhs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                <span class="n">block_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

            <span class="c1"># Create indices range and shift to correct position.</span>
            <span class="n">block_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">block_length</span><span class="p">)</span> <span class="o">+</span> <span class="n">ind_start</span>
            <span class="c1"># Extract last index and add 1 to get the starting point for next block of</span>
            <span class="c1"># indices.</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">assembled_equation_indices</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">equ_name</span><span class="p">:</span> <span class="n">block_indices</span><span class="p">})</span>

            <span class="k">if</span> <span class="n">block_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ind_start</span> <span class="o">=</span> <span class="n">block_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Concatenate results equation-wise.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">)</span>
            <span class="n">rhs_cat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Special case if the restriction produced an empty system.</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dofs</span><span class="p">()))</span>
            <span class="n">rhs_cat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Slice out the columns belonging to the requested subsets of variables and</span>
        <span class="c1"># grid-related column blocks by using the transposed projection to respective</span>
        <span class="c1"># subspace.</span>
        <span class="c1"># Multiply rhs by -1 to move to the rhs.</span>
        <span class="n">column_projection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_to</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">A</span> <span class="o">*</span> <span class="n">column_projection</span><span class="p">,</span> <span class="o">-</span><span class="n">rhs_cat</span></div>

<div class="viewcode-block" id="EquationSystem.assemble_schur_complement_system"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem.assemble_schur_complement_system">[docs]</a>    <span class="k">def</span> <span class="nf">assemble_schur_complement_system</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">primary_equations</span><span class="p">:</span> <span class="n">EquationList</span> <span class="o">|</span> <span class="n">EquationRestriction</span><span class="p">,</span>
        <span class="n">primary_variables</span><span class="p">:</span> <span class="n">VariableList</span><span class="p">,</span>
        <span class="n">inverter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">],</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Assemble Jacobian matrix and residual vector using a Schur complement</span>
<span class="sd">        elimination of the variables and equations not to be included.</span>

<span class="sd">        The specified equations and variables will define blocks of the linearized</span>
<span class="sd">        system as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \left [ \begin{matrix} A_{pp} &amp; A_{ps} \\ A_{sp} &amp; A_{ss} \end{matrix} \right]</span>
<span class="sd">            \left [ \begin{matrix} x_p \\ x_s \end{matrix}\right]</span>
<span class="sd">            = \left [ \begin{matrix} b_p \\ b_s \end{matrix}\right]</span>


<span class="sd">        where subscripts p and s define primary and secondary blocks.</span>
<span class="sd">        The Schur complement system is then given by</span>

<span class="sd">        .. math::</span>

<span class="sd">            \left( A_{pp} - A_{ps} * A_{ss}^{-1} * A_{sp}\right) * x_p</span>
<span class="sd">            = b_p - A_{ps} * A_{ss} * b_s</span>

<span class="sd">        The Schur complement is well-defined only if the inverse of :math:`A_{ss}`</span>
<span class="sd">        exists, and the efficiency of the approach assumes that an efficient inverter</span>
<span class="sd">        for :math:`A_{ss}` can be found.</span>
<span class="sd">        **The user must ensure both requirements are fulfilled.**</span>

<span class="sd">        Note:</span>
<span class="sd">            The optional arguments defining the secondary block, and the flag</span>
<span class="sd">            ``excl_loc_prim_to_sec`` are meant for nested Schur-complements and</span>
<span class="sd">            splitting solvers. This is an advanced usage and requires the user to be</span>
<span class="sd">            careful, since the resulting blocks :math:`A_{pp}` and :math:`A_{ss}` might</span>
<span class="sd">            end up to be not square. This will result in errors.</span>

<span class="sd">        Examples:</span>
<span class="sd">            The default inverter can be defined by</span>

<span class="sd">            .. code-block:: python</span>

<span class="sd">                import scipy.sparse as sps</span>
<span class="sd">                inverter = lambda A: sps.csr_matrix(sps.linalg.inv(A.A))</span>

<span class="sd">            It is costly in terms of computational time and memory, though.</span>

<span class="sd">            TODO: We should rather use the block inverter in pp.matrix_operations. This</span>
<span class="sd">            will require some work on ensuring the system is block-diagonal.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            primary_equations: a subset of equations specifying the primary subspace in</span>
<span class="sd">                row-sense.</span>
<span class="sd">            primary_variables: VariableType input specifying the primary subspace in</span>
<span class="sd">                column-sense.</span>
<span class="sd">            inverter (optional): callable object to compute the inverse of the matrix</span>
<span class="sd">                :math:`A_{ss}`. By default, the scipy direct sparse inverter is used.</span>
<span class="sd">            state (optional): see :meth:`assemble_subsystem`. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple containing</span>

<span class="sd">                sps.spmatrix: Jacobian matrix representing the Schur complement with</span>
<span class="sd">                respect to the targeted state.</span>
<span class="sd">                np.ndarray: Residual vector for the Schur complement with respect to the</span>
<span class="sd">                targeted state. Scaled with -1 (moved to rhs).</span>

<span class="sd">        Raises:</span>
<span class="sd">            AssertionError:</span>

<span class="sd">                - If the primary block would have 0 rows or columns.</span>
<span class="sd">                - If the secondary block would have 0 rows or columns.</span>
<span class="sd">                - If the secondary block is not square.</span>

<span class="sd">            ValueError: If primary and secondary columns overlap.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inverter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inverter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">sps</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">A</span><span class="p">))</span>

        <span class="c1"># Find the rows of the primary block. This can include both equations defined</span>
        <span class="c1"># on their full image, and equations specified on a subset of grids.</span>
        <span class="c1"># The variable primary_rows will contain the indices in the global system</span>
        <span class="c1"># corresponding to the primary block.</span>
        <span class="n">primary_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_equations</span><span class="p">(</span><span class="n">primary_equations</span><span class="p">)</span>
        <span class="c1"># Find indices of equations involved in the primary block, but on grids that</span>
        <span class="c1"># were filtered out. These will be added to the secondary block.</span>
        <span class="n">excluded_primary_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gridbased_equation_complement</span><span class="p">(</span><span class="n">primary_rows</span><span class="p">)</span>

        <span class="c1"># Names of equations that form the primary block.</span>
        <span class="n">primary_equation_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">primary_rows</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># Get the primary variables, represented as Ad variables.</span>
        <span class="n">active_variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_variable_type</span><span class="p">(</span><span class="n">primary_variables</span><span class="p">)</span>

        <span class="c1"># Projection of variables to the set of primary blocks.</span>
        <span class="n">primary_projection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_to</span><span class="p">(</span><span class="n">active_variables</span><span class="p">)</span>

        <span class="c1"># Assert non-emptiness of primary block.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">primary_rows</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">primary_projection</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="c1"># Equations that are not part of the primary block. These will form parts of the</span>
        <span class="c1"># secondary block, as will the equations that are defined on grids that were</span>
        <span class="c1"># excluded.</span>
        <span class="n">secondary_equation_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">primary_rows</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="p">)</span>
        <span class="n">secondary_variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">active_variables</span><span class="p">))</span>
        <span class="n">secondary_projection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection_to</span><span class="p">(</span><span class="n">secondary_variables</span><span class="p">)</span>

        <span class="c1"># Assert non-emptiness of secondary block. We do not check the length of</span>
        <span class="c1"># sequandary_equation_names, since this can empty if the secondary block is</span>
        <span class="c1"># defined by a subset of grids.</span>
        <span class="k">assert</span> <span class="n">secondary_projection</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="c1"># Storage of primary and secondary row blocks.</span>
        <span class="n">A_sec</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">b_sec</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">A_prim</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">b_prim</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># Keep track of indices or primary block.</span>
        <span class="n">ind_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">assembled_equation_indices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># We loop over stored equations to ensure the correct order but process only</span>
        <span class="c1"># primary equations.</span>
        <span class="c1"># Excluded local primary blocks are stored as top rows in the secondary block.</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">primary_equation_names</span><span class="p">:</span>
                <span class="n">A_temp</span><span class="p">,</span> <span class="n">b_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assemble_subsystem</span><span class="p">(</span><span class="n">equations</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">state</span><span class="o">=</span><span class="n">state</span><span class="p">)</span>
                <span class="n">idx_p</span> <span class="o">=</span> <span class="n">primary_rows</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="c1"># Check if a grid filter was applied for that equation</span>
                <span class="k">if</span> <span class="n">idx_p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Append the respective rows.</span>
                    <span class="n">A_prim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A_temp</span><span class="p">[</span><span class="n">idx_p</span><span class="p">])</span>
                    <span class="n">b_prim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_temp</span><span class="p">[</span><span class="n">idx_p</span><span class="p">])</span>
                    <span class="c1"># If requested, the excluded primary rows are appended as secondary.</span>
                    <span class="n">idx_excl_p</span> <span class="o">=</span> <span class="n">excluded_primary_rows</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="n">A_sec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A_temp</span><span class="p">[</span><span class="n">idx_excl_p</span><span class="p">])</span>
                    <span class="n">b_sec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_temp</span><span class="p">[</span><span class="n">idx_excl_p</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If no filter was applied, the whole row block is appended.</span>
                    <span class="n">A_prim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A_temp</span><span class="p">)</span>
                    <span class="n">b_prim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_temp</span><span class="p">)</span>

                <span class="c1"># Track indices of block rows. Only primary equations are included.</span>
                <span class="n">row_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">b_prim</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">row_idx</span> <span class="o">+</span> <span class="n">ind_start</span>
                <span class="n">ind_start</span> <span class="o">+=</span> <span class="n">row_idx</span><span class="o">.</span><span class="n">size</span>
                <span class="n">assembled_equation_indices</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">indices</span><span class="p">})</span>

        <span class="c1"># store the assembled row indices for the primary block only (Schur)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assembled_equation_indices</span> <span class="o">=</span> <span class="n">assembled_equation_indices</span>

        <span class="c1"># We loop again over stored equation to ensure a correct order</span>
        <span class="c1"># but process only secondary equations.</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">:</span>
            <span class="c1"># Secondary equations (those not explicitly given as being primary) are</span>
            <span class="c1"># assembled wholesale to the secondary block.</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">secondary_equation_names</span><span class="p">:</span>
                <span class="n">A_temp</span><span class="p">,</span> <span class="n">b_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assemble_subsystem</span><span class="p">(</span><span class="n">equations</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">state</span><span class="o">=</span><span class="n">state</span><span class="p">)</span>
                <span class="n">A_sec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A_temp</span><span class="p">)</span>
                <span class="n">b_sec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_temp</span><span class="p">)</span>

        <span class="c1"># stack the results</span>
        <span class="n">A_p</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">A_prim</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">)</span>
        <span class="n">b_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">b_prim</span><span class="p">)</span>
        <span class="n">A_s</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">A_sec</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">)</span>
        <span class="n">b_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">b_sec</span><span class="p">)</span>

        <span class="c1"># turn the projections into prolongations</span>
        <span class="n">primary_projection</span> <span class="o">=</span> <span class="n">primary_projection</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">secondary_projection</span> <span class="o">=</span> <span class="n">secondary_projection</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="c1"># Matrices involved in the Schur complements</span>
        <span class="n">A_pp</span> <span class="o">=</span> <span class="n">A_p</span> <span class="o">*</span> <span class="n">primary_projection</span>
        <span class="n">A_ps</span> <span class="o">=</span> <span class="n">A_p</span> <span class="o">*</span> <span class="n">secondary_projection</span>
        <span class="n">A_sp</span> <span class="o">=</span> <span class="n">A_s</span> <span class="o">*</span> <span class="n">primary_projection</span>
        <span class="n">A_ss</span> <span class="o">=</span> <span class="n">A_s</span> <span class="o">*</span> <span class="n">secondary_projection</span>

        <span class="c1"># Last sanity check, if A_ss is square.</span>
        <span class="k">assert</span> <span class="n">A_ss</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">A_ss</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Compute the inverse of A_ss using the passed inverter.</span>
        <span class="n">inv_A_ss</span> <span class="o">=</span> <span class="n">inverter</span><span class="p">(</span><span class="n">A_ss</span><span class="p">)</span>

        <span class="n">S</span> <span class="o">=</span> <span class="n">A_pp</span> <span class="o">-</span> <span class="n">A_ps</span> <span class="o">*</span> <span class="n">inv_A_ss</span> <span class="o">*</span> <span class="n">A_sp</span>
        <span class="n">rhs_S</span> <span class="o">=</span> <span class="n">b_p</span> <span class="o">-</span> <span class="n">A_ps</span> <span class="o">*</span> <span class="n">inv_A_ss</span> <span class="o">*</span> <span class="n">b_s</span>

        <span class="c1"># Store information necessary for expanding the Schur complement later.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Schur_complement</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">inv_A_ss</span><span class="p">,</span>
            <span class="n">b_s</span><span class="p">,</span>
            <span class="n">A_sp</span><span class="p">,</span>
            <span class="n">primary_projection</span><span class="p">,</span>
            <span class="n">secondary_projection</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">S</span><span class="p">,</span> <span class="n">rhs_S</span></div>

<div class="viewcode-block" id="EquationSystem.expand_schur_complement_solution"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.ad.equation_system.html#porepy.numerics.ad.EquationSystem.expand_schur_complement_solution">[docs]</a>    <span class="k">def</span> <span class="nf">expand_schur_complement_solution</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">reduced_solution</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Expands the solution of the *last assembled* Schur complement system to the</span>
<span class="sd">        whole solution.</span>

<span class="sd">        With ``reduced_solution`` as :math:`x_p` from</span>

<span class="sd">        .. math::</span>
<span class="sd">            \left [ \begin{matrix} A_{pp} &amp; A_{ps} \\ A_{sp} &amp; A_{ss} \end{matrix} \right]</span>
<span class="sd">            \left [ \begin{matrix} x_p \\ x_s \end{matrix}\right]</span>
<span class="sd">            = \left [ \begin{matrix} b_p \\ b_s \end{matrix}\right],</span>

<span class="sd">        the method returns the whole vector :math:`[x_p, x_s]`, where</span>

<span class="sd">        .. math::</span>
<span class="sd">            x_s = A_{ss}^{-1} * (b_s - A_{sp} * x_p).</span>

<span class="sd">        Note:</span>
<span class="sd">            Independent of how the primary and secondary blocks were chosen, this method</span>
<span class="sd">            always returns a vector of size ``num_dofs``.</span>
<span class="sd">            Especially when the primary and secondary variables did not constitute the</span>
<span class="sd">            whole vector of unknowns, the result is still of size ``num_dofs``.</span>
<span class="sd">            The entries corresponding to the excluded grid variables are zero.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            reduced_solution: Solution to the linear system returned by</span>
<span class="sd">                :meth:`assemble_schur_complement_system`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The expanded Schur solution in global size.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the Schur complement system was not assembled before.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Schur_complement</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Schur complement system was not assembled before.&quot;</span><span class="p">)</span>

        <span class="c1"># Get data stored from last constructed Schur complement.</span>
        <span class="n">inv_A_ss</span><span class="p">,</span> <span class="n">b_s</span><span class="p">,</span> <span class="n">A_sp</span><span class="p">,</span> <span class="n">prolong_p</span><span class="p">,</span> <span class="n">prolong_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Schur_complement</span>

        <span class="c1"># Calculate the complement solution.</span>
        <span class="n">x_s</span> <span class="o">=</span> <span class="n">inv_A_ss</span> <span class="o">*</span> <span class="p">(</span><span class="n">b_s</span> <span class="o">-</span> <span class="n">A_sp</span> <span class="o">*</span> <span class="n">reduced_solution</span><span class="p">)</span>

        <span class="c1"># Prolong primary and secondary block to global-sized arrays</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">prolong_p</span> <span class="o">*</span> <span class="n">reduced_solution</span> <span class="o">+</span> <span class="n">prolong_s</span> <span class="o">*</span> <span class="n">x_s</span>
        <span class="k">return</span> <span class="n">X</span></div>

    <span class="c1">### Special methods ----------------------------------------------------------------</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;EquationSystem for mixed-dimensional grid with &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">num_subdomains</span><span class="p">()</span><span class="si">}</span><span class="s2"> subdomains &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">num_interfaces</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="s2">&quot; interfaces.</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="c1"># Sort variables alphabetically, not case-sensitive</span>
        <span class="n">all_variables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">var</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">])</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;Variables present on at least one grid or interface:</span><span class="se">\n\t</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">all_variables</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eq_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;In total </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">)</span><span class="si">}</span><span class="s2"> equations, with names: </span><span class="se">\n\t</span><span class="s2">&quot;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">eq_names</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;EquationSystem for mixed-dimensional grid with &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">num_subdomains</span><span class="p">()</span><span class="si">}</span><span class="s2"> subdomains &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">num_interfaces</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="s2">&quot; interfaces.</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="n">all_variables</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">var</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">])</span>
        <span class="n">variable_grid</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">GridLike</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="n">var</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">all_variables</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">variable_grid</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>

        <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;There are in total </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">all_variables</span><span class="p">)</span><span class="si">}</span><span class="s2"> variables,&quot;</span>
            <span class="o">+</span> <span class="s2">&quot; distributed as follows:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Sort variables alphabetically, not case-sensitive</span>
        <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">grids</span> <span class="ow">in</span> <span class="n">variable_grid</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2"> is present on&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">])</span>
                <span class="n">sorted_grids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">sort_subdomains</span><span class="p">(</span><span class="n">grids</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot; subdomains with id: &quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">sorted_grids</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">])</span>
                <span class="n">sorted_grids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">sort_interfaces</span><span class="p">(</span><span class="n">grids</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot; interfaces with id: &quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">sorted_grids</span><span class="p">]</span>
                <span class="p">)</span>

        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eq_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;In total </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_equations</span><span class="p">)</span><span class="si">}</span><span class="s2"> equations, with names: </span><span class="se">\n\t</span><span class="s2">&quot;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">eq_names</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="n">s</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022 UiB Center for Modeling of Coupled Subsurface Dynamics, GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007..</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>