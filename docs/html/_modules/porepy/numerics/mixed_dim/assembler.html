<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>porepy.numerics.mixed_dim.assembler &mdash; PorePy 1.6.0 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
    <link rel="canonical" href="https://pmgbergen.github.io/porepy/_modules/porepy/numerics/mixed_dim/assembler.html" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >
            <a href="../../../../index.html" class="icon icon-home"> PorePy
          </a>
              <div class="version">
                1.6.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../docsrc/howto/howto-docstring.html">1. How-To docstring</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../docsrc/porepy/modules.html">porepy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../docsrc/porepy/porepy.html">porepy package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.html">porepy.fracs package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.fracture.html">porepy.fracs.fracture module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.fracture_importer.html">porepy.fracs.fracture_importer module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.fracture_network_2d.html">porepy.fracs.fracture_network_2d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.fracture_network_3d.html">porepy.fracs.fracture_network_3d module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.gmsh_interface.html">porepy.fracs.gmsh_interface module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.line_fracture.html">porepy.fracs.line_fracture module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.meshing.html">porepy.fracs.meshing module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.msh_2_grid.html">porepy.fracs.msh_2_grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.non_conforming.html">porepy.fracs.non_conforming module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.plane_fracture.html">porepy.fracs.plane_fracture module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.simplex.html">porepy.fracs.simplex module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.split_grid.html">porepy.fracs.split_grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.structured.html">porepy.fracs.structured module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.tools.html">porepy.fracs.tools module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.utils.html">porepy.fracs.utils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.fracs.wells_3d.html">porepy.fracs.wells_3d module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.html">porepy.geometry package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.bounding_box.html">porepy.geometry.bounding_box module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.constrain_geometry.html">porepy.geometry.constrain_geometry module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.distances.html">porepy.geometry.distances module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.geometry_property_checks.html">porepy.geometry.geometry_property_checks module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.half_space.html">porepy.geometry.half_space module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.intersections.html">porepy.geometry.intersections module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.map_geometry.html">porepy.geometry.map_geometry module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.geometry.point_in_polyhedron_test.html">porepy.geometry.point_in_polyhedron_test module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.html">porepy.grids package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.standard_grids.html">porepy.grids.standard_grids package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.boundary_grid.html">porepy.grids.boundary_grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.coarsening.html">porepy.grids.coarsening module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.grid.html">porepy.grids.grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.grid_extrusion.html">porepy.grids.grid_extrusion module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.match_grids.html">porepy.grids.match_grids module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.md_grid.html">porepy.grids.md_grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.mortar_grid.html">porepy.grids.mortar_grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.partition.html">porepy.grids.partition module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.point_grid.html">porepy.grids.point_grid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.refinement.html">porepy.grids.refinement module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.simplex.html">porepy.grids.simplex module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.grids.structured.html">porepy.grids.structured module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.html">porepy.models package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.verification_setups.html">porepy.models.verification_setups package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.abstract_equations.html">porepy.models.abstract_equations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.abstract_model.html">porepy.models.abstract_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.constitutive_laws.html">porepy.models.constitutive_laws module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.contact_mechanics_biot_model.html">porepy.models.contact_mechanics_biot_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.contact_mechanics_model.html">porepy.models.contact_mechanics_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.energy_balance.html">porepy.models.energy_balance module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.fluid_mass_balance.html">porepy.models.fluid_mass_balance module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.geometry.html">porepy.models.geometry module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.incompressible_flow_model.html">porepy.models.incompressible_flow_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.mass_and_energy_balance.html">porepy.models.mass_and_energy_balance module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.material_constants.html">porepy.models.material_constants module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.momentum_balance.html">porepy.models.momentum_balance module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.poromechanics.html">porepy.models.poromechanics module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.run_models.html">porepy.models.run_models module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.slightly_compressible_flow_model.html">porepy.models.slightly_compressible_flow_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.solution_strategy.html">porepy.models.solution_strategy module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.thermoporomechanics.html">porepy.models.thermoporomechanics module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.thm_model.html">porepy.models.thm_model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.models.units.html">porepy.models.units module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.html">porepy.numerics package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.ad.html">porepy.numerics.ad package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fem.html">porepy.numerics.fem package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fracture_deformation.html">porepy.numerics.fracture_deformation package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.fv.html">porepy.numerics.fv package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.interface_laws.html">porepy.numerics.interface_laws package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.linalg.html">porepy.numerics.linalg package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.mixed_dim.html">porepy.numerics.mixed_dim package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.nonlinear.html">porepy.numerics.nonlinear package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.solvers.html">porepy.numerics.solvers package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.vem.html">porepy.numerics.vem package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.discretization.html">porepy.numerics.discretization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.displacement_correlation.html">porepy.numerics.displacement_correlation module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.linear_solvers.html">porepy.numerics.linear_solvers module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.numerics.time_step_control.html">porepy.numerics.time_step_control module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.html">porepy.params package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.bc.html">porepy.params.bc module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.data.html">porepy.params.data module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.fluid.html">porepy.params.fluid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.parameter_dictionaries.html">porepy.params.parameter_dictionaries module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.rock.html">porepy.params.rock module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.params.tensor.html">porepy.params.tensor module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.html">porepy.utils package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.derived_discretizations.html">porepy.utils.derived_discretizations package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.accumarray.html">porepy.utils.accumarray module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.adtree.html">porepy.utils.adtree module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.array_operations.html">porepy.utils.array_operations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.common_constants.html">porepy.utils.common_constants module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.default_domains.html">porepy.utils.default_domains module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.error.html">porepy.utils.error module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.graph.html">porepy.utils.graph module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.grid_utils.html">porepy.utils.grid_utils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.interpolation_tables.html">porepy.utils.interpolation_tables module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.mcolon.html">porepy.utils.mcolon module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.permutations.html">porepy.utils.permutations module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.porepy_types.html">porepy.utils.porepy_types module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.setmembership.html">porepy.utils.setmembership module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.sort_points.html">porepy.utils.sort_points module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.tags.html">porepy.utils.tags module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.utils.tangential_normal_projection.html">porepy.utils.tangential_normal_projection module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../../docsrc/porepy/porepy.viz.html">porepy.viz package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.viz.data_saving_model_mixin.html">porepy.viz.data_saving_model_mixin module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.viz.exporter.html">porepy.viz.exporter module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.viz.fracture_visualization.html">porepy.viz.fracture_visualization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../../docsrc/porepy/porepy.viz.plot_grid.html">porepy.viz.plot_grid module</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">PorePy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">porepy.numerics.mixed_dim.assembler</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for porepy.numerics.mixed_dim.assembler</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The module contains the Assembler class, which is responsible for assembly of</span>
<span class="sd">system matrix and right hand side for a general multi-domain, multi-physics problem.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sps</span>

<span class="kn">import</span> <span class="nn">porepy</span> <span class="k">as</span> <span class="nn">pp</span>

<span class="n">csc_or_csr_matrix</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">sps</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">,</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">]</span>

<span class="n">GridVariableTerm</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;GridVariableTerm&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;grid&quot;</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">,</span> <span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;term&quot;</span><span class="p">])</span>
<span class="n">GridVariableTerm</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">+=</span> <span class="p">(</span>
    <span class="s2">&quot;Combinations of grids variables and terms found in MixedDimensionalGrid&quot;</span>
<span class="p">)</span>
<span class="n">GridVariableTerm</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;Item in MixedDimensionalGrid. Can be subdomain or interface.&quot;</span>
<span class="p">)</span>
<span class="n">GridVariableTerm</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Variable name of the row for this term.&quot;</span>
<span class="n">GridVariableTerm</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;Variable name of the column for this term. &quot;</span>
    <span class="o">+</span> <span class="s2">&quot;Differs from row for variable couplings.&quot;</span>
<span class="p">)</span>
<span class="n">GridVariableTerm</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Term for this discretization&quot;</span>

<span class="n">CouplingVariableTerm</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span>
    <span class="s2">&quot;CouplingVariableTerm&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;coupling&quot;</span><span class="p">,</span> <span class="s2">&quot;interface&quot;</span><span class="p">,</span> <span class="s2">&quot;primary&quot;</span><span class="p">,</span> <span class="s2">&quot;secondary&quot;</span><span class="p">,</span> <span class="s2">&quot;term&quot;</span><span class="p">]</span>
<span class="p">)</span>


<div class="viewcode-block" id="Assembler"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler.html#porepy.numerics.mixed_dim.assembler.Assembler">[docs]</a><span class="k">class</span> <span class="nc">Assembler</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A class that assembles multi-physics problems on mixed-dimensional</span>
<span class="sd">    domains.</span>

<span class="sd">    The class is designed to combine different variables on different grids,</span>
<span class="sd">    different discretizations for the same variable, various coupling schemes</span>
<span class="sd">    between the grids etc. To use the functionality, discretization schemes</span>
<span class="sd">    for the individual terms in the equation must be defined and follow certain</span>
<span class="sd">    rules. For further description, see the documentation of self.assemble_matrix_rhs().</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;The Assembler class is deprecated, and will be deleted from PorePy,</span>
<span class="s2">        most likely during the second half of 2022.</span>

<span class="s2">        To set up mixed-dimensional or multiphysics models, confer the model classes</span>
<span class="s2">        (highly recommended), or use the algorithmic differentiation framework.</span>
<span class="s2">        &quot;&quot;&quot;</span>

        <span class="sd">&quot;&quot;&quot;This throws a deprecation warning on subclassing.&quot;&quot;&quot;</span>
        <span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mdg</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">MixedDimensionalGrid</span><span class="p">,</span> <span class="n">dof_manager</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DofManager</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Construct an assembler for a given MixedDimensionalGrid on a given set of variables.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            self.mdg (pp.MixedDimensionalGrid): Mixed-dimensional grid where the equations are</span>
<span class="sd">                discretized. The data dictionaries on subdomains and interfaces should contain</span>
<span class="sd">                variable and discretization information, see tutorial for details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;The Assembler class is deprecated, and will be deleted from PorePy,</span>
<span class="s2">        most likely during the second half of 2022.</span>

<span class="s2">        To set up mixed-dimensional or multiphysics models, confer the model classes</span>
<span class="s2">        (highly recommended), or use the algorithmic differentiation framework.</span>
<span class="s2">        &quot;&quot;&quot;</span>

        <span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span> <span class="o">=</span> <span class="n">mdg</span>

        <span class="k">if</span> <span class="n">dof_manager</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dof_manager</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">DofManager</span><span class="p">(</span><span class="n">mdg</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span> <span class="o">=</span> <span class="n">dof_manager</span>

        <span class="c1"># Identify all variable couplings in the MixedDimensionalGrid, and assign degrees of</span>
        <span class="c1"># freedom for each block.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_identify_variable_combinations</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_discretization_key</span><span class="p">(</span><span class="n">row</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">row</span> <span class="o">==</span> <span class="n">col</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">row</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">row</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">col</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_variable_term_key</span><span class="p">(</span>
        <span class="n">term</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key_1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key_2</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key_3</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the key-variable combination used to identify a specific term in the</span>
<span class="sd">        equation.</span>

<span class="sd">        For subdomains and internally to interfaces in the MixedDimensionalGrid (i.e.</span>
<span class="sd">        fixed-dimensional grids), the variable name is formed by combining the name of</span>
<span class="sd">        one or two primary variables, and the name of term all of which are defined in</span>
<span class="sd">        the data dictionary of this subdomain / interface.</span>

<span class="sd">        As examples:</span>
<span class="sd">            - An advection-diffusion equation will typically have two terms, say,</span>
<span class="sd">                advection_temperature, diffusion_temperature</span>
<span class="sd">            - For a coupled flow-temperature discretization, the coupling (off-diagonal)</span>
<span class="sd">                terms may have identifiers &#39;coupling_temperature_flow&#39; and</span>
<span class="sd">                &#39;coupling_flow_temperature&#39;</span>

<span class="sd">        For couplings between interfaces and subdomains, a three variable combination is</span>
<span class="sd">        needed, identifying variable names on the interface and the respective</span>
<span class="sd">        neighboring subdomains.</span>

<span class="sd">        NOTE: The naming of variables and terms are left to the user. For examples</span>
<span class="sd">        on how to set this up, confer the tutorial parameter_asignment_assembler_setup</span>

<span class="sd">        Parameters:</span>
<span class="sd">            term (str): Identifier of a discretization operation.</span>
<span class="sd">            key_1 (str): Variable name.</span>
<span class="sd">            key_2 (str): Variable name</span>
<span class="sd">            key_3 (str, optional): Variable name. If not provided, a 2-variable</span>
<span class="sd">                identifier is returned, that is, we are not working on a</span>
<span class="sd">                subdomain-interface coupling.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Identifier for this combination of term and variables.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key_3</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Internal to a subdomain or an interface</span>
            <span class="k">if</span> <span class="n">key_1</span> <span class="o">==</span> <span class="n">key_2</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">term</span><span class="p">,</span> <span class="n">key_1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">term</span><span class="p">,</span> <span class="n">key_1</span><span class="p">,</span> <span class="n">key_2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Coupling between subdomain and interface</span>
            <span class="k">return</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">term</span><span class="p">,</span> <span class="n">key_1</span><span class="p">,</span> <span class="n">key_2</span><span class="p">,</span> <span class="n">key_3</span><span class="p">])</span>

<div class="viewcode-block" id="Assembler.assemble_matrix_rhs"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler.html#porepy.numerics.mixed_dim.assembler.Assembler.assemble_matrix_rhs">[docs]</a>    <span class="k">def</span> <span class="nf">assemble_matrix_rhs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">assembler_filters</span><span class="o">.</span><span class="n">AssemblerFilter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">matrix_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;csr&quot;</span><span class="p">,</span>
        <span class="n">add_matrices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">only_matrix</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">only_rhs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">csc_or_csr_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
    <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Assemble the system matrix and right hand side for a general linear</span>
<span class="sd">        multi-physics problem, and return a block matrix and right hand side.</span>

<span class="sd">        For examples on how to use the assembler, confer the tutorial</span>
<span class="sd">        parameter_assignment_assembler_setup.ipynb. Here, we list the main capabilities</span>
<span class="sd">        of the assembler:</span>
<span class="sd">            * Assign an arbitrary number of variables on each subdomain and interface in</span>
<span class="sd">              the mixed-dimensional. Allow for general couplings between the variables</span>
<span class="sd">              internal to each subdomain / interface.</span>
<span class="sd">            * Assign general coupling schemes between interfaces and  one or both neighboring</span>
<span class="sd">              subdomains. There are no limitations on variable naming conventions in the</span>
<span class="sd">              coupling.</span>
<span class="sd">            * Construct a system matrix that only consideres a subset of the variables</span>

<span class="sd">              defined in the MixedDimensionalGrid data dictionary.</span>
<span class="sd">            * Return either a single discretization matrix covering all variables and</span>
<span class="sd">              terms, or one matrix per term per variable. The latter is useful e.g. in</span>
<span class="sd">              operator splitting or time stepping schemes.</span>

<span class="sd">        The latter two effects can be achieved by applying a filter to the assembly</span>
<span class="sd">        operation, see for instance pp.assembler_filters.ListFilter.</span>

<span class="sd">        In all cases, it is assumed that a discretization object for the relevant terms</span>
<span class="sd">        is available. It is up to the user to ensure that the resulting problem is</span>
<span class="sd">        well posed.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            filt (pp.assembler_filters.AssemblerFilter, optional): Filter to invoke</span>
<span class="sd">                selected discretizations. Defaults to a PassAllFilter, which will</span>
<span class="sd">                lead to discretization of all terms in the entire MixedDimensionalGrid.</span>
<span class="sd">            matrix_format (str, optional): Matrix format used for the system matrix.</span>
<span class="sd">                Defaults to CSR.</span>
<span class="sd">            add_matrices (boolean, optional): If True, a single system matrix is added,</span>
<span class="sd">                else, separate matrices for each variable and term are returned in a</span>
<span class="sd">                dictionary.</span>
<span class="sd">            only_matrix (boolean, optional). If True, only the matrix will be assembled.</span>
<span class="sd">                Note that some discretization methods will still invoke its full</span>
<span class="sd">                assemble_matrix_rhs method. This method will still return a (zero)</span>
<span class="sd">                rhs vector.</span>
<span class="sd">            only_rhs (boolean, optional). If True, only the rhs will be assembled.</span>
<span class="sd">                Note that some discretization methods will still invoke its full</span>
<span class="sd">                assemble_matrix_rhs method. This method will still return a (zero)</span>
<span class="sd">                discretization matrix.</span>

<span class="sd">        Returns:</span>
<span class="sd">            scipy sparse matrix, or dictionary of matrices: Discretization matrix,</span>
<span class="sd">                dictionary is returned if add_matrices=False.</span>
<span class="sd">            np.ndarray, or dictionary of arrays: Right hand side terms. Dictionary is</span>
<span class="sd">                returned if add_matrices=False.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Define the matrix format, common for all the sub-matrices</span>
        <span class="k">if</span> <span class="n">matrix_format</span> <span class="o">==</span> <span class="s2">&quot;csc&quot;</span><span class="p">:</span>
            <span class="n">sps_matrix</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csc_matrix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sps_matrix</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span>

        <span class="k">if</span> <span class="n">only_matrix</span> <span class="ow">and</span> <span class="n">only_rhs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;At most one of &#39;only_matrix&#39; and &#39;only_rhs&#39; should be True&quot;</span>
            <span class="p">)</span>

        <span class="c1"># If there are no variables, w can return now</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">full_dof</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">add_matrices</span><span class="p">:</span>
                <span class="c1"># If a single returned value is expected, (summed matrices) it is most easy</span>
                <span class="c1"># to generate a new, empty matrix, of the right size.</span>
                <span class="n">mat</span><span class="p">,</span> <span class="n">vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assign_matrix_vector</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">full_dof</span><span class="p">,</span> <span class="n">sps_matrix</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">mat</span><span class="p">,</span> <span class="n">vec</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_matrix_rhs</span><span class="p">(</span><span class="n">sps_matrix</span><span class="p">)</span>

        <span class="c1"># Assemble</span>
        <span class="n">matrix</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_operate_on_mdg</span><span class="p">(</span>  <span class="c1"># type:ignore</span>
            <span class="n">operation</span><span class="o">=</span><span class="s2">&quot;assemble&quot;</span><span class="p">,</span>
            <span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">,</span>
            <span class="n">matrix_format</span><span class="o">=</span><span class="n">matrix_format</span><span class="p">,</span>
            <span class="n">assemble_matrix_only</span><span class="o">=</span><span class="n">only_matrix</span><span class="p">,</span>
            <span class="n">assemble_rhs_only</span><span class="o">=</span><span class="n">only_rhs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># At this stage, all assembly is done. The remaining step is optionally to</span>
        <span class="c1"># add the matrices associated with different terms, and anyhow convert</span>
        <span class="c1"># the matrix to a sps. block matrix.</span>
        <span class="k">if</span> <span class="n">add_matrices</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">full_dof</span><span class="p">)</span>
            <span class="n">full_matrix</span><span class="p">:</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span> <span class="o">=</span> <span class="n">sps_matrix</span><span class="p">((</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
            <span class="n">full_rhs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

            <span class="k">for</span> <span class="n">mat</span> <span class="ow">in</span> <span class="n">matrix</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">full_matrix</span> <span class="o">+=</span> <span class="n">sps</span><span class="o">.</span><span class="n">bmat</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">matrix_format</span><span class="p">)</span>

            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>  <span class="c1"># Appease mypy</span>
            <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">rhs</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">full_rhs</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">vec</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">full_matrix</span><span class="p">,</span> <span class="n">full_rhs</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">matrix</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">bmat</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">matrix_format</span><span class="p">)</span>

            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>  <span class="c1"># Appease mypy</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">rhs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">rhs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">rhs</span></div>

<div class="viewcode-block" id="Assembler.update_discretization"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler.html#porepy.numerics.mixed_dim.assembler.Assembler.update_discretization">[docs]</a>    <span class="k">def</span> <span class="nf">update_discretization</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">filt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">assembler_filters</span><span class="o">.</span><span class="n">AssemblerFilter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update discretizations without a full rediscretization.</span>

<span class="sd">        The method will invoke the update_discretization() method on discretizations</span>
<span class="sd">        on all grids which have the parameter partial_update set to True in its data</span>
<span class="sd">        dictionary. If a Filter is given to this function, the partial update will</span>
<span class="sd">        be used as an additional filter.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            filt (pp.assembler_filters.AssemblerFilter, optional): Filter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Only those grids that are marked for update will be updated. This is</span>
        <span class="c1"># implemented as an additional filtering step.</span>

        <span class="k">if</span> <span class="n">filt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">assembler_filters</span><span class="o">.</span><span class="n">AllPassFilter</span><span class="p">):</span>

            <span class="c1"># If no filter is provided, make a ListFilter that effectively is AllPass.</span>
            <span class="c1"># The grid list must be constructed explicitly, we may remove items below.</span>
            <span class="n">grid_list_type</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
                <span class="n">Union</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">]],</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">,</span>
                <span class="n">Tuple</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">],</span>
            <span class="p">]</span>

            <span class="n">grid_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">grid_list_type</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">()]</span>

            <span class="k">for</span> <span class="n">intf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interfaces</span><span class="p">():</span>
                <span class="n">grid_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">intf</span><span class="p">]</span>
                <span class="n">sd_pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_to_subdomain_pair</span><span class="p">(</span><span class="n">intf</span><span class="p">)</span>
                <span class="n">grid_list</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">sd_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sd_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">intf</span><span class="p">)]</span>

            <span class="n">variable_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">term_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">assembler_filters</span><span class="o">.</span><span class="n">ListFilter</span><span class="p">):</span>
            <span class="c1"># Pick from ListFilter</span>
            <span class="n">grid_list</span> <span class="o">=</span> <span class="n">filt</span><span class="o">.</span><span class="n">_grid_list</span>
            <span class="n">variable_list</span> <span class="o">=</span> <span class="n">filt</span><span class="o">.</span><span class="n">_variable_list</span>
            <span class="n">term_list</span> <span class="o">=</span> <span class="n">filt</span><span class="o">.</span><span class="n">_term_list</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Discretization update cannot be combined with non-standard filter&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Keep track of which grids are marked or update</span>
        <span class="n">update_grid</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Represent as set for easy removal of grids</span>
        <span class="n">grid_set</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">grid_list_type</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">grid_list</span><span class="p">)</span>

        <span class="c1"># Loop over all subdomains, either register them as marked for update, or remove</span>
        <span class="c1"># from the grid_set.</span>
        <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;partial_update&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">update_grid</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grid_set</span><span class="p">:</span>
                    <span class="n">grid_set</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                <span class="n">update_grid</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">intf</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interfaces</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="c1"># if interface not marked for partial update, remove</span>
            <span class="n">update_interface</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;partial_update&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">update_interface</span> <span class="ow">and</span> <span class="n">intf</span> <span class="ow">in</span> <span class="n">grid_set</span><span class="p">:</span>
                <span class="n">grid_set</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">intf</span><span class="p">)</span>

            <span class="n">sd_primary</span><span class="p">,</span> <span class="n">sd_secondary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_to_subdomain_pair</span><span class="p">(</span><span class="n">intf</span><span class="p">)</span>
            <span class="c1"># The coupling should be updated if the interface or any of the neighboring</span>
            <span class="c1"># subdomains is marked for update</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="p">(</span>
                    <span class="n">update_grid</span><span class="p">[</span><span class="n">sd_primary</span><span class="p">]</span>
                    <span class="ow">or</span> <span class="n">update_grid</span><span class="p">[</span><span class="n">sd_secondary</span><span class="p">]</span>
                    <span class="ow">or</span> <span class="n">update_interface</span>
                <span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">sd_primary</span><span class="p">,</span> <span class="n">sd_secondary</span><span class="p">,</span> <span class="n">intf</span><span class="p">)</span> <span class="ow">in</span> <span class="n">grid_set</span>
            <span class="p">):</span>
                <span class="n">grid_set</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">sd_primary</span><span class="p">,</span> <span class="n">sd_secondary</span><span class="p">,</span> <span class="n">intf</span><span class="p">))</span>

        <span class="c1"># Create a new filter with only grids marked for update.</span>
        <span class="n">new_filt</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">assembler_filters</span><span class="o">.</span><span class="n">ListFilter</span><span class="p">(</span>
            <span class="n">grid_list</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">grid_set</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">variable_list</span><span class="o">=</span><span class="n">variable_list</span><span class="p">,</span>
            <span class="n">term_list</span><span class="o">=</span><span class="n">term_list</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_operate_on_mdg</span><span class="p">(</span><span class="n">operation</span><span class="o">=</span><span class="s2">&quot;update_discretization&quot;</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="n">new_filt</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembler.discretize"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler.html#porepy.numerics.mixed_dim.assembler.Assembler.discretize">[docs]</a>    <span class="k">def</span> <span class="nf">discretize</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">filt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">assembler_filters</span><span class="o">.</span><span class="n">AssemblerFilter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Run the discretization operation on discretizations specified in</span>
<span class="sd">        the mixed-dimensional grid.</span>

<span class="sd">        Discretization can be applied selectively to specific discretization objects</span>
<span class="sd">        in the MixedDimensionalGrid by passing an appropriate filter. See pp.assembler_filters</span>
<span class="sd">        for details, in particular the class ListFilter.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            filt (pp.assembler_filters.AssemblerFilter, optional): Filter to invoke</span>
<span class="sd">                selected discretizations. Defaults to a PassAllFilter, which will</span>
<span class="sd">                lead to discretization of all terms in the entire MixedDimensionalGrid.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_operate_on_mdg</span><span class="p">(</span><span class="s2">&quot;discretize&quot;</span><span class="p">,</span> <span class="n">filt</span><span class="o">=</span><span class="n">filt</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_operate_on_mdg</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">operation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">filt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">assembler_filters</span><span class="o">.</span><span class="n">AssemblerFilter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">csc_or_csr_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">csc_or_csr_matrix</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
        <span class="kc">None</span><span class="p">,</span>
    <span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Helper method, loop over the MixedDimensionalGrid, identify subdomain or</span>
<span class="sd">        interface variables and discretizations, and perform an operation on these.</span>

<span class="sd">        Implemented actions are discretization and assembly.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If the filter is not specified, do no filtering.</span>
            <span class="n">filt</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">assembler_filters</span><span class="o">.</span><span class="n">AllPassFilter</span><span class="p">()</span>

        <span class="c1"># Both assemble and discretize relies on t</span>
        <span class="k">if</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;assemble&quot;</span><span class="p">:</span>
            <span class="c1"># Initialize the global matrix.</span>
            <span class="c1"># This gives us a set of matrices (essentially one per term per variable)</span>
            <span class="c1"># and a similar set of rhs vectors. Furthermore, we get block indices</span>
            <span class="c1"># of variables on individual subdomains and interfaces, and count the number of</span>
            <span class="c1"># dofs per local variable.</span>
            <span class="c1"># For details, and some nuances, see documentation of the function</span>
            <span class="c1"># _initialize_matrix_rhs.</span>
            <span class="n">matrix_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;matrix_format&quot;</span><span class="p">,</span> <span class="s2">&quot;csc&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">matrix_format</span> <span class="o">==</span> <span class="s2">&quot;csc&quot;</span><span class="p">:</span>
                <span class="n">sps_matrix</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csc_matrix</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sps_matrix</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">csr_matrix</span>

            <span class="n">matrix</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_matrix_rhs</span><span class="p">(</span><span class="n">sps_matrix</span><span class="p">)</span>

            <span class="n">extra_args</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;assemble_matrix_only&quot;</span><span class="p">,</span> <span class="s2">&quot;assemble_rhs_only&quot;</span><span class="p">]</span>
            <span class="p">}</span>

            <span class="c1"># Make term and variable filters that let everything through</span>

        <span class="k">elif</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;discretize&quot;</span> <span class="ow">or</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;update_discretization&quot;</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type:ignore</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type:ignore</span>
            <span class="n">sps_matrix</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">extra_args</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We will only reach this if someone has invoked this private method</span>
            <span class="c1"># from the outside.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown mdg operation &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">operation</span><span class="p">))</span>

        <span class="c1"># First take care of operations internal to subdomains and interfaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_operate_on_subdomains_and_interfaces</span><span class="p">(</span>
            <span class="n">filt</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_args</span>
        <span class="p">)</span>

        <span class="c1"># Next, handle coupling over interfaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_operate_on_interface_coupling</span><span class="p">(</span>
            <span class="n">filt</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sps_matrix</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_args</span>
        <span class="p">)</span>

        <span class="c1"># Return type depends on operation</span>
        <span class="k">if</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;assemble&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">rhs</span>  <span class="c1"># type:ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_operate_on_subdomains_and_interfaces</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filt</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">assembler_filters</span><span class="o">.</span><span class="n">AssemblerFilter</span><span class="p">,</span>
        <span class="n">operation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">assemble_matrix_only</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">assemble_rhs_only</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">for</span> <span class="n">combination</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_variable_term_combinations</span><span class="p">:</span>
            <span class="c1"># Coupling terms should not be considered here</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">combination</span><span class="p">,</span> <span class="n">CouplingVariableTerm</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">filt</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">grids</span><span class="o">=</span><span class="p">[</span><span class="n">combination</span><span class="o">.</span><span class="n">grid</span><span class="p">],</span>
                <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="n">combination</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">combination</span><span class="o">.</span><span class="n">col</span><span class="p">],</span>
                <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="n">combination</span><span class="o">.</span><span class="n">term</span><span class="p">],</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># The grid-like quantity is either a grid or an interface.</span>
            <span class="c1"># The two require slightly different function calls etc.</span>

            <span class="n">grid</span> <span class="o">=</span> <span class="n">combination</span><span class="o">.</span><span class="n">grid</span>
            <span class="n">is_subdomain</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">)</span>
            <span class="c1"># Get hold of data dictionary</span>
            <span class="k">if</span> <span class="n">is_subdomain</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomain_data</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_data</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

            <span class="c1"># Discretization</span>
            <span class="c1"># NOTE: For the interface, this is not the coupling discretization,</span>
            <span class="c1"># for that see self._operate_on_subdomains_and_interfaces().</span>
            <span class="n">discr</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION</span><span class="p">][</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_discretization_key</span><span class="p">(</span><span class="n">combination</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">combination</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
            <span class="p">][</span><span class="n">combination</span><span class="o">.</span><span class="n">term</span><span class="p">]</span>

            <span class="c1"># Either discretize (full or update) or assemble</span>
            <span class="k">if</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;discretize&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_subdomain</span><span class="p">:</span>
                    <span class="n">discr</span><span class="o">.</span><span class="n">discretize</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">discr</span><span class="o">.</span><span class="n">discretize</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;update_discretization&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_subdomain</span><span class="p">:</span>
                    <span class="n">discr</span><span class="o">.</span><span class="n">update_discretization</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">discr</span><span class="o">.</span><span class="n">update_discretization</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># assemble</span>
                <span class="c1"># Assemble the matrix and right hand side. This will also</span>
                <span class="c1"># discretize if not done before.</span>
                <span class="c1"># Call appropriate assembler for subdomains and interfaces, respectively.</span>
                <span class="k">if</span> <span class="n">assemble_matrix_only</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_subdomain</span><span class="p">:</span>
                        <span class="n">loc_A</span> <span class="o">=</span> <span class="n">discr</span><span class="o">.</span><span class="n">assemble_matrix</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">loc_A</span> <span class="o">=</span> <span class="n">discr</span><span class="o">.</span><span class="n">assemble_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">assemble_rhs_only</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_subdomain</span><span class="p">:</span>
                        <span class="n">loc_b</span> <span class="o">=</span> <span class="n">discr</span><span class="o">.</span><span class="n">assemble_rhs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">loc_b</span> <span class="o">=</span> <span class="n">discr</span><span class="o">.</span><span class="n">assemble_rhs</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_subdomain</span><span class="p">:</span>
                        <span class="n">loc_A</span><span class="p">,</span> <span class="n">loc_b</span> <span class="o">=</span> <span class="n">discr</span><span class="o">.</span><span class="n">assemble_matrix_rhs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">loc_A</span><span class="p">,</span> <span class="n">loc_b</span> <span class="o">=</span> <span class="n">discr</span><span class="o">.</span><span class="n">assemble_matrix_rhs</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

                <span class="c1"># Assign values in global matrix: Create the same key used</span>
                <span class="c1"># defined when initializing matrices (see that function)</span>
                <span class="n">ri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">block_dof</span><span class="p">[(</span><span class="n">grid</span><span class="p">,</span> <span class="n">combination</span><span class="o">.</span><span class="n">row</span><span class="p">)]</span>
                <span class="n">ci</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">block_dof</span><span class="p">[(</span><span class="n">grid</span><span class="p">,</span> <span class="n">combination</span><span class="o">.</span><span class="n">col</span><span class="p">)]</span>
                <span class="n">var_key_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable_term_key</span><span class="p">(</span>
                    <span class="n">combination</span><span class="o">.</span><span class="n">term</span><span class="p">,</span> <span class="n">combination</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">combination</span><span class="o">.</span><span class="n">col</span>
                <span class="p">)</span>

                <span class="c1"># Check if the current block is None or not, it could</span>
                <span class="c1"># based on the problem setting. Better to stay</span>
                <span class="c1"># the safe side.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">assemble_rhs_only</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">var_key_name</span><span class="p">][</span><span class="n">ri</span><span class="p">,</span> <span class="n">ci</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># type:ignore</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">var_key_name</span><span class="p">][</span><span class="n">ri</span><span class="p">,</span> <span class="n">ci</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc_A</span>  <span class="c1"># type:ignore</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">var_key_name</span><span class="p">][</span><span class="n">ri</span><span class="p">,</span> <span class="n">ci</span><span class="p">]</span> <span class="o">+=</span> <span class="n">loc_A</span>  <span class="c1"># type:ignore</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">assemble_matrix_only</span><span class="p">:</span>
                    <span class="n">rhs</span><span class="p">[</span><span class="n">var_key_name</span><span class="p">][</span><span class="n">ri</span><span class="p">]</span> <span class="o">+=</span> <span class="n">loc_b</span>  <span class="c1"># type:ignore</span>

    <span class="k">def</span> <span class="nf">_operate_on_interface_coupling</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filt</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">assembler_filters</span><span class="o">.</span><span class="n">AssemblerFilter</span><span class="p">,</span>
        <span class="n">operation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
        <span class="n">rhs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
        <span class="n">sps_matrix</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">csc_or_csr_matrix</span><span class="p">],</span>
        <span class="n">assemble_matrix_only</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">assemble_rhs_only</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Perform operation on all interface-subdomain couplings.</span>

<span class="sd">        This method should not be invoked directly, but instead accessed via the public</span>
<span class="sd">        methods discretize() or assemble_matrix_rhs()</span>

<span class="sd">        Parameters:</span>
<span class="sd">            operation (str): Should be &#39;assemble&#39; or &#39;discretize&#39;.</span>
<span class="sd">            matrix (dict): Dictionary that maps strings of variable combinations to the</span>
<span class="sd">                block matrix. The keys are variable combinations, found in</span>
<span class="sd">                self.variable_combinations. The values are block matrices, stored as</span>
<span class="sd">                np.ndarrays, with each array item defined as a sps.spmatrix.</span>
<span class="sd">                Only needed if operation == &#39;assemble&#39;.</span>
<span class="sd">            rhs (dict): Dictionary that maps strings of variable combinations to the</span>
<span class="sd">                block rhsx. The keys are variable combinations, found in</span>
<span class="sd">                self.variable_combinations. The values are block vectors, stored as</span>
<span class="sd">                np.ndarrays, with each array item defined as an np.ndarray.</span>
<span class="sd">                Only needed if operation == &#39;assemble&#39;.</span>
<span class="sd">            sps_matrix(csc or csr sparse matrix): The sparse matrix format.</span>
<span class="sd">                Should be csc or csr.</span>

<span class="sd">            variable_filter, term_filter: Parameters that can be used for</span>
<span class="sd">                partial discretization or assembly. The usage of these terms is</span>
<span class="sd">                currently unclear. Use with care.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        For reference, the following is an example of the contents of</span>
<span class="sd">        pp.COUPLING_DISCRETIZATION, annotated for the code below:</span>

<span class="sd">            d[pp.COUPLING_DISCRETIZATION] = {</span>
<span class="sd">                &quot;scalar_coupling_term&quot;: {                           &lt;-- coupling_key</span>
<span class="sd">                    sd_h: (&quot;pressure&quot;, &quot;diffusion&quot;),                 &lt;-- (primary_var_key,</span>
<span class="sd">                                                                         primary_term_key)</span>
<span class="sd">                    sd_l: (&quot;pressure&quot;, &quot;diffusion&quot;),                 &lt;-- (secondary_var_key,</span>
<span class="sd">                                                                         secondary_term_key)</span>
<span class="sd">                    e: (</span>
<span class="sd">                        &quot;mortar_pressure&quot;,                          &lt;-- interface_var_key</span>
<span class="sd">                        pp.RobinCoupling(&quot;flow&quot;, pp.Mpfa(&quot;flow&quot;),   &lt;-- interface_discr</span>
<span class="sd">                    ),</span>
<span class="sd">                },</span>
<span class="sd">            }</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">combination</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid_variable_term_combinations</span><span class="p">:</span>
            <span class="c1"># Only CouplingVariableTerms are considered</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">combination</span><span class="p">,</span> <span class="n">GridVariableTerm</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="c1"># Check if this is filtered out</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">filt</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">grids</span><span class="o">=</span><span class="p">[</span><span class="n">combination</span><span class="o">.</span><span class="n">coupling</span><span class="p">],</span>
                <span class="n">variables</span><span class="o">=</span><span class="p">[</span>
                    <span class="n">combination</span><span class="o">.</span><span class="n">primary</span><span class="p">,</span>
                    <span class="n">combination</span><span class="o">.</span><span class="n">secondary</span><span class="p">,</span>
                    <span class="n">combination</span><span class="o">.</span><span class="n">interface</span><span class="p">,</span>
                <span class="p">],</span>
                <span class="n">terms</span><span class="o">=</span><span class="p">[</span><span class="n">combination</span><span class="o">.</span><span class="n">term</span><span class="p">],</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">sd_primary</span><span class="p">,</span> <span class="n">sd_secondary</span><span class="p">,</span> <span class="n">intf</span> <span class="o">=</span> <span class="n">combination</span><span class="o">.</span><span class="n">coupling</span>
            <span class="n">data_secondary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomain_data</span><span class="p">(</span><span class="n">sd_secondary</span><span class="p">)</span>
            <span class="n">data_primary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomain_data</span><span class="p">(</span><span class="n">sd_primary</span><span class="p">)</span>
            <span class="n">data_intf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_data</span><span class="p">(</span><span class="n">intf</span><span class="p">)</span>

            <span class="n">term_key</span> <span class="o">=</span> <span class="n">combination</span><span class="o">.</span><span class="n">term</span>
            <span class="n">coupling</span> <span class="o">=</span> <span class="n">data_intf</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">COUPLING_DISCRETIZATION</span><span class="p">][</span><span class="n">term_key</span><span class="p">]</span>

            <span class="c1"># Get interface coupling discretization</span>
            <span class="n">intf_vals</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">coupling</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">intf</span><span class="p">)</span>
            <span class="n">intf_var_key</span><span class="p">,</span> <span class="n">intf_discr</span> <span class="o">=</span> <span class="n">intf_vals</span>

            <span class="c1"># Global block index associated with this interface variable</span>
            <span class="n">intf_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">block_dof</span><span class="p">[(</span><span class="n">intf</span><span class="p">,</span> <span class="n">intf_var_key</span><span class="p">)]</span>

            <span class="c1"># Get variable name and block index of the primary grid variable.</span>
            <span class="n">primary_vals</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">coupling</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sd_primary</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">primary_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># An empty identifying string will create no problems below.</span>
                <span class="n">primary_var_key</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">primary_term_key</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="c1"># If the primary variable index is None, this signifies that</span>
                <span class="c1"># the primary grid variable index is not active</span>
                <span class="n">primary_idx</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># If operation is &#39;assemble&#39;, set mat_key_primary to None here</span>
                <span class="c1"># and throw and error when the &#39;matrix&#39; dictionary is accessed.</span>
                <span class="n">mat_key_primary</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Name of the relevant variable on the primary grid</span>
                <span class="n">primary_var_key</span><span class="p">,</span> <span class="n">primary_term_key</span> <span class="o">=</span> <span class="n">primary_vals</span>

                <span class="c1"># Global index associated with the primary variable</span>
                <span class="n">primary_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">block_dof</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">sd_primary</span><span class="p">,</span> <span class="n">primary_var_key</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># Also define the key to access the matrix of the discretization of</span>
                <span class="c1"># the primary variable on the primary subdomain.</span>
                <span class="n">mat_key_primary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable_term_key</span><span class="p">(</span>
                    <span class="n">primary_term_key</span><span class="p">,</span> <span class="n">primary_var_key</span><span class="p">,</span> <span class="n">primary_var_key</span>
                <span class="p">)</span>
            <span class="c1"># Do similar operations for the secondary variable.</span>
            <span class="n">secondary_vals</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">coupling</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sd_secondary</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">secondary_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">secondary_var_key</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">secondary_term_key</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">secondary_idx</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># If operation is &#39;assemble&#39;, set mat_key_secondary to None here</span>
                <span class="c1"># and throw and error when the &#39;matrix&#39; dictionary is accessed.</span>
                <span class="n">mat_key_secondary</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">secondary_var_key</span><span class="p">,</span> <span class="n">secondary_term_key</span> <span class="o">=</span> <span class="n">secondary_vals</span>

                <span class="n">secondary_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">block_dof</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">sd_secondary</span><span class="p">,</span> <span class="n">secondary_var_key</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="c1"># Also define the key to access the matrix of the discretization of</span>
                <span class="c1"># the secondary variable on the secondary subdomain.</span>
                <span class="n">mat_key_secondary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable_term_key</span><span class="p">(</span>
                    <span class="n">secondary_term_key</span><span class="p">,</span> <span class="n">secondary_var_key</span><span class="p">,</span> <span class="n">secondary_var_key</span>
                <span class="p">)</span>

            <span class="c1"># Key to the matrix dictionary used to access this coupling</span>
            <span class="c1"># discretization.</span>
            <span class="n">mat_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable_term_key</span><span class="p">(</span>
                <span class="n">term_key</span><span class="p">,</span> <span class="n">intf_var_key</span><span class="p">,</span> <span class="n">secondary_var_key</span><span class="p">,</span> <span class="n">primary_var_key</span>
            <span class="p">)</span>
            <span class="c1"># Now there are three options (and a fourth, invalid one):</span>
            <span class="c1"># The standard case is that both secondary and primary variables</span>
            <span class="c1"># are used in the coupling. Alternatively, only one of the primary or secondary is</span>
            <span class="c1"># used. The fourth alternative, none of them are active, is not</span>
            <span class="c1"># considered valid, and raises an error message.</span>
            <span class="k">if</span> <span class="n">primary_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">secondary_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;discretize&quot;</span><span class="p">:</span>
                    <span class="n">intf_discr</span><span class="o">.</span><span class="n">discretize</span><span class="p">(</span>
                        <span class="n">sd_primary</span><span class="p">,</span>
                        <span class="n">sd_secondary</span><span class="p">,</span>
                        <span class="n">intf</span><span class="p">,</span>
                        <span class="n">data_primary</span><span class="p">,</span>
                        <span class="n">data_secondary</span><span class="p">,</span>
                        <span class="n">data_intf</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="k">elif</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;update_discretization&quot;</span><span class="p">:</span>
                    <span class="n">intf_discr</span><span class="o">.</span><span class="n">discretize</span><span class="p">(</span>
                        <span class="n">sd_primary</span><span class="p">,</span>
                        <span class="n">sd_secondary</span><span class="p">,</span>
                        <span class="n">intf</span><span class="p">,</span>
                        <span class="n">data_primary</span><span class="p">,</span>
                        <span class="n">data_secondary</span><span class="p">,</span>
                        <span class="n">data_intf</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="k">elif</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;assemble&quot;</span><span class="p">:</span>
                    <span class="c1"># Assign a local matrix, which will be populated with the</span>
                    <span class="c1"># current state of the local system.</span>
                    <span class="c1"># Local here refers to the variable and term on the two</span>
                    <span class="c1"># subdomains, together with the relavant mortar variable and term</span>
                    <span class="c1"># Associate the first variable with primary, the second with</span>
                    <span class="c1"># secondary, and the final with interface.</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">assemble_rhs_only</span><span class="p">:</span>
                        <span class="n">loc_mat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assign_matrix_vector</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">full_dof</span><span class="p">[</span>
                                <span class="p">[</span><span class="n">primary_idx</span><span class="p">,</span> <span class="n">secondary_idx</span><span class="p">,</span> <span class="n">intf_idx</span><span class="p">]</span>
                            <span class="p">],</span>
                            <span class="n">sps_matrix</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="c1"># Pick out the discretizations on the primary and secondary subdomain</span>
                        <span class="c1"># for the relevant variables.</span>
                        <span class="c1"># There should be no contribution or modification of the</span>
                        <span class="c1"># [0, 1] and [1, 0] terms, since the variables are only</span>
                        <span class="c1"># allowed to communicate via the interfaces.</span>
                        <span class="k">if</span> <span class="n">mat_key_primary</span><span class="p">:</span>
                            <span class="n">loc_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">mat_key_primary</span><span class="p">][</span>  <span class="c1"># type:ignore</span>
                                <span class="n">primary_idx</span><span class="p">,</span> <span class="n">primary_idx</span>
                            <span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;No discretization found on the primary grid &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;of dimension </span><span class="si">{</span><span class="n">sd_primary</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2">, for the &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;coupling term </span><span class="si">{</span><span class="n">term_key</span><span class="si">}</span><span class="s2">.&quot;</span>
                            <span class="p">)</span>
                        <span class="k">if</span> <span class="n">mat_key_secondary</span><span class="p">:</span>
                            <span class="n">loc_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">mat_key_secondary</span><span class="p">][</span>  <span class="c1"># type:ignore</span>
                                <span class="n">secondary_idx</span><span class="p">,</span> <span class="n">secondary_idx</span>
                            <span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;No discretization found on the secondary grid &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;of dimension </span><span class="si">{</span><span class="n">sd_secondary</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2">, for the &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;coupling term </span><span class="si">{</span><span class="n">term_key</span><span class="si">}</span><span class="s2">.&quot;</span>
                            <span class="p">)</span>

                    <span class="c1"># Run the discretization, and assign the resulting matrix</span>
                    <span class="c1"># to a temporary construct</span>
                    <span class="k">if</span> <span class="n">assemble_matrix_only</span><span class="p">:</span>
                        <span class="n">tmp_mat</span> <span class="o">=</span> <span class="n">intf_discr</span><span class="o">.</span><span class="n">assemble_matrix</span><span class="p">(</span>
                            <span class="n">sd_primary</span><span class="p">,</span>
                            <span class="n">sd_secondary</span><span class="p">,</span>
                            <span class="n">intf</span><span class="p">,</span>
                            <span class="n">data_primary</span><span class="p">,</span>
                            <span class="n">data_secondary</span><span class="p">,</span>
                            <span class="n">data_intf</span><span class="p">,</span>
                            <span class="n">loc_mat</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">assemble_rhs_only</span><span class="p">:</span>
                        <span class="n">loc_rhs</span> <span class="o">=</span> <span class="n">intf_discr</span><span class="o">.</span><span class="n">assemble_rhs</span><span class="p">(</span>
                            <span class="n">sd_primary</span><span class="p">,</span>
                            <span class="n">sd_secondary</span><span class="p">,</span>
                            <span class="n">intf</span><span class="p">,</span>
                            <span class="n">data_primary</span><span class="p">,</span>
                            <span class="n">data_secondary</span><span class="p">,</span>
                            <span class="n">data_intf</span><span class="p">,</span>
                            <span class="kc">None</span><span class="p">,</span>  <span class="c1"># The local matrix should not be used</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tmp_mat</span><span class="p">,</span> <span class="n">loc_rhs</span> <span class="o">=</span> <span class="n">intf_discr</span><span class="o">.</span><span class="n">assemble_matrix_rhs</span><span class="p">(</span>
                            <span class="n">sd_primary</span><span class="p">,</span>
                            <span class="n">sd_secondary</span><span class="p">,</span>
                            <span class="n">intf</span><span class="p">,</span>
                            <span class="n">data_primary</span><span class="p">,</span>
                            <span class="n">data_secondary</span><span class="p">,</span>
                            <span class="n">data_intf</span><span class="p">,</span>
                            <span class="n">loc_mat</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">assemble_rhs_only</span><span class="p">:</span>
                        <span class="c1"># The interface column and row should be assigned to mat_key</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">mat_key</span><span class="p">][</span>  <span class="c1"># type:ignore</span>
                            <span class="n">intf_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">primary_idx</span><span class="p">,</span> <span class="n">secondary_idx</span><span class="p">,</span> <span class="n">intf_idx</span><span class="p">)</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">tmp_mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">mat_key</span><span class="p">][</span>  <span class="c1"># type:ignore</span>
                            <span class="p">(</span><span class="n">primary_idx</span><span class="p">,</span> <span class="n">secondary_idx</span><span class="p">),</span> <span class="n">intf_idx</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">tmp_mat</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">]</span>
                        <span class="c1"># Also update the discretization on the primary and secondary</span>
                        <span class="c1"># subdomains</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">mat_key_primary</span><span class="p">][</span>  <span class="c1"># type:ignore</span>
                            <span class="n">primary_idx</span><span class="p">,</span> <span class="n">primary_idx</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">tmp_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">mat_key_secondary</span><span class="p">][</span>  <span class="c1"># type:ignore</span>
                            <span class="n">secondary_idx</span><span class="p">,</span> <span class="n">secondary_idx</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">tmp_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">assemble_matrix_only</span><span class="p">:</span>
                        <span class="c1"># Finally take care of the right hand side</span>
                        <span class="k">assert</span> <span class="n">rhs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="n">rhs</span><span class="p">[</span><span class="n">mat_key</span><span class="p">][[</span><span class="n">primary_idx</span><span class="p">,</span> <span class="n">secondary_idx</span><span class="p">,</span> <span class="n">intf_idx</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">loc_rhs</span>

            <span class="k">elif</span> <span class="n">primary_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># TODO: Term filters are not applied to this case</span>
                <span class="c1"># secondary_idx is None</span>
                <span class="c1"># The operation is a simplified version of the full option above.</span>
                <span class="k">if</span> <span class="n">operation</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;discretize&quot;</span><span class="p">,</span> <span class="s2">&quot;update_discretization&quot;</span><span class="p">):</span>
                    <span class="n">intf_discr</span><span class="o">.</span><span class="n">discretize</span><span class="p">(</span><span class="n">sd_primary</span><span class="p">,</span> <span class="n">data_primary</span><span class="p">,</span> <span class="n">data_intf</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;assemble&quot;</span><span class="p">:</span>

                    <span class="n">loc_mat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assign_matrix_vector</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">full_dof</span><span class="p">[[</span><span class="n">primary_idx</span><span class="p">,</span> <span class="n">intf_idx</span><span class="p">]],</span> <span class="n">sps_matrix</span>
                    <span class="p">)</span>
                    <span class="n">loc_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">mat_key_primary</span><span class="p">][</span>  <span class="c1"># type:ignore</span>
                        <span class="n">primary_idx</span><span class="p">,</span> <span class="n">primary_idx</span>
                    <span class="p">]</span>

                    <span class="k">if</span> <span class="n">assemble_matrix_only</span><span class="p">:</span>
                        <span class="n">tmp_mat</span> <span class="o">=</span> <span class="n">intf_discr</span><span class="o">.</span><span class="n">assemble_matrix</span><span class="p">(</span>
                            <span class="n">sd_primary</span><span class="p">,</span> <span class="n">data_primary</span><span class="p">,</span> <span class="n">data_intf</span><span class="p">,</span> <span class="n">loc_mat</span>
                        <span class="p">)</span>

                    <span class="k">elif</span> <span class="n">assemble_rhs_only</span><span class="p">:</span>
                        <span class="n">loc_rhs</span> <span class="o">=</span> <span class="n">intf_discr</span><span class="o">.</span><span class="n">assemble_rhs</span><span class="p">(</span>
                            <span class="n">sd_primary</span><span class="p">,</span> <span class="n">data_primary</span><span class="p">,</span> <span class="n">data_intf</span><span class="p">,</span> <span class="n">loc_mat</span>
                        <span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tmp_mat</span><span class="p">,</span> <span class="n">loc_rhs</span> <span class="o">=</span> <span class="n">intf_discr</span><span class="o">.</span><span class="n">assemble_matrix_rhs</span><span class="p">(</span>
                            <span class="n">sd_primary</span><span class="p">,</span> <span class="n">data_primary</span><span class="p">,</span> <span class="n">data_intf</span><span class="p">,</span> <span class="n">loc_mat</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">assemble_rhs_only</span><span class="p">:</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">mat_key</span><span class="p">][</span>  <span class="c1"># type:ignore</span>
                            <span class="n">intf_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">primary_idx</span><span class="p">,</span> <span class="n">intf_idx</span><span class="p">)</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">tmp_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">mat_key</span><span class="p">][</span><span class="n">primary_idx</span><span class="p">,</span> <span class="n">intf_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_mat</span><span class="p">[</span>  <span class="c1"># type:ignore</span>
                            <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
                        <span class="p">]</span>

                        <span class="c1"># Also update the discretization on the primary and secondary</span>
                        <span class="c1"># subdomains</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">mat_key_primary</span><span class="p">][</span>  <span class="c1"># type:ignore</span>
                            <span class="n">primary_idx</span><span class="p">,</span> <span class="n">primary_idx</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">tmp_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">assemble_matrix_only</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="n">rhs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="n">rhs</span><span class="p">[</span><span class="n">mat_key</span><span class="p">][[</span><span class="n">primary_idx</span><span class="p">,</span> <span class="n">intf_idx</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">loc_rhs</span>

            <span class="k">elif</span> <span class="n">secondary_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># TODO: Term filters are not applied to this case</span>
                <span class="c1"># primary_idx is None</span>
                <span class="c1"># The operation is a simplified version of the full option above.</span>
                <span class="k">if</span> <span class="n">operation</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;discretize&quot;</span><span class="p">,</span> <span class="s2">&quot;update_discretization&quot;</span><span class="p">):</span>
                    <span class="n">intf_discr</span><span class="o">.</span><span class="n">discretize</span><span class="p">(</span><span class="n">sd_secondary</span><span class="p">,</span> <span class="n">data_secondary</span><span class="p">,</span> <span class="n">data_intf</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;assemble&quot;</span><span class="p">:</span>

                    <span class="n">loc_mat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assign_matrix_vector</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">full_dof</span><span class="p">[[</span><span class="n">secondary_idx</span><span class="p">,</span> <span class="n">intf_idx</span><span class="p">]],</span>
                        <span class="n">sps_matrix</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">loc_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">mat_key_secondary</span><span class="p">][</span>  <span class="c1"># type:ignore</span>
                        <span class="n">secondary_idx</span><span class="p">,</span> <span class="n">secondary_idx</span>
                    <span class="p">]</span>
                    <span class="k">if</span> <span class="n">assemble_matrix_only</span><span class="p">:</span>
                        <span class="n">tmp_mat</span> <span class="o">=</span> <span class="n">intf_discr</span><span class="o">.</span><span class="n">assemble_matrix</span><span class="p">(</span>
                            <span class="n">sd_secondary</span><span class="p">,</span> <span class="n">data_secondary</span><span class="p">,</span> <span class="n">data_intf</span><span class="p">,</span> <span class="n">loc_mat</span>
                        <span class="p">)</span>

                    <span class="k">elif</span> <span class="n">assemble_rhs_only</span><span class="p">:</span>
                        <span class="n">loc_rhs</span> <span class="o">=</span> <span class="n">intf_discr</span><span class="o">.</span><span class="n">assemble_rhs</span><span class="p">(</span>
                            <span class="n">sd_secondary</span><span class="p">,</span> <span class="n">data_secondary</span><span class="p">,</span> <span class="n">data_intf</span><span class="p">,</span> <span class="n">loc_mat</span>
                        <span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tmp_mat</span><span class="p">,</span> <span class="n">loc_rhs</span> <span class="o">=</span> <span class="n">intf_discr</span><span class="o">.</span><span class="n">assemble_matrix_rhs</span><span class="p">(</span>
                            <span class="n">sd_secondary</span><span class="p">,</span> <span class="n">data_secondary</span><span class="p">,</span> <span class="n">data_intf</span><span class="p">,</span> <span class="n">loc_mat</span>
                        <span class="p">)</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">assemble_rhs_only</span><span class="p">:</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">mat_key</span><span class="p">][</span>  <span class="c1"># type:ignore</span>
                            <span class="n">intf_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">secondary_idx</span><span class="p">,</span> <span class="n">intf_idx</span><span class="p">)</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">tmp_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">mat_key</span><span class="p">][</span>  <span class="c1"># type:ignore</span>
                            <span class="n">secondary_idx</span><span class="p">,</span> <span class="n">intf_idx</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">tmp_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

                        <span class="c1"># Also update the discretization on the primary and secondary</span>
                        <span class="c1"># subdomains</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">mat_key_secondary</span><span class="p">][</span>  <span class="c1"># type:ignore</span>
                            <span class="n">secondary_idx</span><span class="p">,</span> <span class="n">secondary_idx</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">tmp_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">assemble_matrix_only</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="n">rhs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="n">rhs</span><span class="p">[</span><span class="n">mat_key</span><span class="p">][[</span><span class="n">secondary_idx</span><span class="p">,</span> <span class="n">intf_idx</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">loc_rhs</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid combination of variables on subdomain-interface relation&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Finally, discretize direct couplings between this interface and other</span>
            <span class="c1"># interfaces.</span>
            <span class="c1"># The below lines allow only for very specific coupling types:</span>
            <span class="c1">#    i) The discretization type of the two interfaces should be the same</span>
            <span class="c1">#   ii) The variable name should be the same for both interfaces</span>
            <span class="c1">#  iii) Only the block intf_ind - other_intf_ind can be filled in.</span>
            <span class="c1"># These restrictions may be loosened somewhat in the future, but a</span>
            <span class="c1"># general coupling between different interfaces will not be implemented.</span>
            <span class="k">if</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;assemble&quot;</span> <span class="ow">and</span> <span class="n">intf_discr</span><span class="o">.</span><span class="n">intf_coupling_via_high_dim</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">other_intf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomain_to_interfaces</span><span class="p">(</span><span class="n">sd_primary</span><span class="p">):</span>

                    <span class="c1"># Skip the case where the primary and secondary interface is the same</span>
                    <span class="k">if</span> <span class="n">other_intf</span> <span class="o">==</span> <span class="n">intf</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Avoid coupling between mortar grids of different dimensions.</span>
                    <span class="k">if</span> <span class="n">other_intf</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">intf</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Only consider terms where the primary and secondary interface have</span>
                    <span class="c1"># the same variable name. This is an intended restriction of the</span>
                    <span class="c1"># flexibility of the code: Direct interface couplings are implemented</span>
                    <span class="c1"># only to replace explicit variables for boundary conditions on</span>
                    <span class="c1"># external boundaries, for which the current implementation</span>
                    <span class="c1"># should suffice. While more advanced couplings could easily be</span>
                    <span class="c1"># introduced, it will violate the modeling framework for mixed-</span>
                    <span class="c1"># dimensional problems.</span>
                    <span class="c1"># Although different variable names for the same physics is</span>
                    <span class="c1"># permitted in the modeling framework, the current restriction</span>
                    <span class="c1"># is considered reasonable for the time being.</span>
                    <span class="n">oi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">block_dof</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">other_intf</span><span class="p">,</span> <span class="n">intf_var_key</span><span class="p">),</span> <span class="kc">None</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">oi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">assemble_matrix</span><span class="p">,</span> <span class="n">assemble_rhs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">assemble_matrix_only</span><span class="p">:</span>
                        <span class="n">assemble_rhs</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="n">assemble_rhs_only</span><span class="p">:</span>
                        <span class="n">assemble_matrix</span> <span class="o">=</span> <span class="kc">False</span>

                    <span class="c1"># Assign a local matrix, which will be populated with the</span>
                    <span class="c1"># current state of the local system.</span>
                    <span class="c1"># Local here refers to the variable and term on the two</span>
                    <span class="c1"># subdomains, together with the relavant mortar variable and term</span>
                    <span class="c1"># Associate the first variable with primary, the second with</span>
                    <span class="c1"># secondary, and the final with interface.</span>
                    <span class="n">data_other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_data</span><span class="p">(</span><span class="n">other_intf</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">assemble_matrix</span><span class="p">:</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">primary_idx</span><span class="p">,</span> <span class="n">intf_idx</span><span class="p">,</span> <span class="n">oi</span><span class="p">])</span>
                        <span class="n">loc_mat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assign_matrix_vector</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">full_dof</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                            <span class="n">sps_matrix</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="p">(</span>
                            <span class="n">tmp_mat</span><span class="p">,</span>
                            <span class="n">loc_rhs</span><span class="p">,</span>
                        <span class="p">)</span> <span class="o">=</span> <span class="n">intf_discr</span><span class="o">.</span><span class="n">assemble_intf_coupling_via_high_dim</span><span class="p">(</span>
                            <span class="n">sd_primary</span><span class="p">,</span>
                            <span class="n">data_primary</span><span class="p">,</span>
                            <span class="n">intf</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_to_subdomain_pair</span><span class="p">(</span><span class="n">intf</span><span class="p">),</span>
                            <span class="n">data_intf</span><span class="p">,</span>
                            <span class="n">other_intf</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_to_subdomain_pair</span><span class="p">(</span><span class="n">other_intf</span><span class="p">),</span>
                            <span class="n">data_other</span><span class="p">,</span>
                            <span class="n">loc_mat</span><span class="p">,</span>
                            <span class="n">assemble_matrix</span><span class="o">=</span><span class="n">assemble_matrix</span><span class="p">,</span>
                            <span class="n">assemble_rhs</span><span class="o">=</span><span class="n">assemble_rhs</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">mat_key</span><span class="p">][</span><span class="n">intf_idx</span><span class="p">,</span> <span class="n">oi</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># type:ignore</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">loc_mat</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="p">(</span>
                            <span class="n">tmp_mat</span><span class="p">,</span>
                            <span class="n">loc_rhs</span><span class="p">,</span>
                        <span class="p">)</span> <span class="o">=</span> <span class="n">intf_discr</span><span class="o">.</span><span class="n">assemble_intf_coupling_via_high_dim</span><span class="p">(</span>
                            <span class="n">sd_primary</span><span class="p">,</span>
                            <span class="n">data_primary</span><span class="p">,</span>
                            <span class="n">intf</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_to_subdomain_pair</span><span class="p">(</span><span class="n">intf</span><span class="p">),</span>
                            <span class="n">data_intf</span><span class="p">,</span>
                            <span class="n">other_intf</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_to_subdomain_pair</span><span class="p">(</span><span class="n">intf</span><span class="p">),</span>
                            <span class="n">data_other</span><span class="p">,</span>
                            <span class="n">loc_mat</span><span class="p">,</span>
                            <span class="n">assemble_matrix</span><span class="o">=</span><span class="n">assemble_matrix</span><span class="p">,</span>
                            <span class="n">assemble_rhs</span><span class="o">=</span><span class="n">assemble_rhs</span><span class="p">,</span>
                        <span class="p">)</span>

                    <span class="n">rhs</span><span class="p">[</span><span class="n">mat_key</span><span class="p">][</span><span class="n">intf_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">loc_rhs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># type:ignore</span>

            <span class="k">if</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;assemble&quot;</span> <span class="ow">and</span> <span class="n">intf_discr</span><span class="o">.</span><span class="n">intf_coupling_via_low_dim</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">other_intf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomain_to_interfaces</span><span class="p">(</span><span class="n">sd_secondary</span><span class="p">):</span>

                    <span class="c1"># Skip the case where the primary and secondary interface is the same</span>
                    <span class="k">if</span> <span class="n">other_intf</span> <span class="o">==</span> <span class="n">intf</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="k">if</span> <span class="n">other_intf</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">intf</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Only consider terms where the primary and secondary interface have</span>
                    <span class="c1"># the same variable name. This is an intended restriction of the</span>
                    <span class="c1"># flexibility of the code: Direct interface couplings are implemented</span>
                    <span class="c1"># only to replace explicit variables for boundary conditions on</span>
                    <span class="c1"># external boundaries, for which the current implementation</span>
                    <span class="c1"># should suffice. While more advanced couplings could easily be</span>
                    <span class="c1"># introduced, it will violate the modeling framework for mixed-</span>
                    <span class="c1"># dimensional problems.</span>
                    <span class="c1"># Although different variable names for the same physics is</span>
                    <span class="c1"># permitted in the modeling framework, the current restriction</span>
                    <span class="c1"># is considered reasonable for the time being.</span>
                    <span class="n">oi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">block_dof</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">other_intf</span><span class="p">,</span> <span class="n">intf_var_key</span><span class="p">),</span> <span class="kc">None</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">oi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Assign a local matrix, which will be populated with the</span>
                    <span class="c1"># current state of the local system.</span>
                    <span class="c1"># Local here refers to the variable and term on the two</span>
                    <span class="c1"># subdomains, together with the relavant mortar variable and term</span>
                    <span class="c1"># Associate the first variable with primary, the second with</span>
                    <span class="c1"># secondary, and the final with interface.</span>
                    <span class="n">data_other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_data</span><span class="p">(</span><span class="n">other_intf</span><span class="p">)</span>

                    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">secondary_idx</span><span class="p">,</span> <span class="n">intf_idx</span><span class="p">,</span> <span class="n">oi</span><span class="p">])</span>
                    <span class="n">loc_mat</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assign_matrix_vector</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">full_dof</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                        <span class="n">sps_matrix</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">assemble_matrix</span><span class="p">,</span> <span class="n">assemble_rhs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">assemble_matrix_only</span><span class="p">:</span>
                        <span class="n">assemble_rhs</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="n">assemble_rhs_only</span><span class="p">:</span>
                        <span class="n">assemble_matrix</span> <span class="o">=</span> <span class="kc">False</span>

                    <span class="p">(</span><span class="n">tmp_mat</span><span class="p">,</span> <span class="n">loc_rhs</span><span class="p">)</span> <span class="o">=</span> <span class="n">intf_discr</span><span class="o">.</span><span class="n">assemble_intf_coupling_via_low_dim</span><span class="p">(</span>
                        <span class="n">sd_secondary</span><span class="p">,</span>
                        <span class="n">data_secondary</span><span class="p">,</span>
                        <span class="n">data_intf</span><span class="p">,</span>
                        <span class="n">data_other</span><span class="p">,</span>
                        <span class="n">loc_mat</span><span class="p">,</span>
                        <span class="n">assemble_matrix</span><span class="o">=</span><span class="n">assemble_matrix</span><span class="p">,</span>
                        <span class="n">assemble_rhs</span><span class="o">=</span><span class="n">assemble_rhs</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">mat_key</span><span class="p">][</span><span class="n">intf_idx</span><span class="p">,</span> <span class="n">oi</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># type:ignore</span>
                    <span class="k">assert</span> <span class="n">rhs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="n">rhs</span><span class="p">[</span><span class="n">mat_key</span><span class="p">][</span><span class="n">intf_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">loc_rhs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_identify_variable_combinations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize local matrices for all combinations of variables and operators.</span>

<span class="sd">        The function serves two purposes:</span>
<span class="sd">            1. Identify all variables and their discretizations defined on individual</span>
<span class="sd">               subdmains and interfaces in the MixedDimensionalGrid</span>

<span class="sd">        At the end of this function, self has been assigned variable_combinations.</span>
<span class="sd">        This is a list of strings that define all couplings ofvariables  found in the problem</span>
<span class="sd">        specification. This includes both diagonal terms in the system block matrix,</span>
<span class="sd">        coupling terms within subdomains and interfaces, and couplings between</span>
<span class="sd">        subdomains and interfaces</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Implementation note: To fully understand the structure of this function</span>
        <span class="c1"># it is useful to consider an example of a data dictionary with declared</span>
        <span class="c1"># primary variables and discretization operators.</span>
        <span class="c1"># The function needs to dig deep into the dictionaries used in these</span>
        <span class="c1"># declarations, thus the code is rather involved.</span>

        <span class="c1"># Store all combinations of variable pairs (e.g. row-column indices in</span>
        <span class="c1"># the global system matrix), and identifiers of discretization operations</span>
        <span class="c1"># (e.g. advection or diffusion).</span>
        <span class="c1"># Note: This list is common for all subdomains / interfaces.</span>
        <span class="c1"># This list is used to access discretization matrices for different</span>
        <span class="c1"># variables and terms</span>
        <span class="n">variable_combinations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Combinations of grids-like features (subdomain, interface,</span>
        <span class="c1">#  subdomain-interface coupling), variables and terms. Used to track discretizations,</span>
        <span class="c1"># and which grids and variables they act on. Also used to filter discretizations</span>
        <span class="c1"># for partial discretizations etc.</span>
        <span class="c1"># IMPLEMENTATION NOTE: variable_combinations and grid_variable_term_combinations</span>
        <span class="c1"># are sort of overlapping in the information they contained (the former is</span>
        <span class="c1"># a subset of the latter), but for implementation convenience it is useful</span>
        <span class="c1"># to keep both.</span>
        <span class="n">grid_variable_term_combinations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span>
            <span class="n">Union</span><span class="p">[</span><span class="n">CouplingVariableTerm</span><span class="p">,</span> <span class="n">GridVariableTerm</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Loop over all subdomains in the grid bucket, identify its local and active</span>
        <span class="c1"># variables.</span>
        <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

            <span class="c1"># If for some reason there are no primary variables defined for this grid,</span>
            <span class="c1"># skip it.</span>
            <span class="k">if</span> <span class="n">pp</span><span class="o">.</span><span class="n">PRIMARY_VARIABLES</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Loop over variables, count dofs and identify variable-term</span>
            <span class="c1"># combinations internal to the subdomain</span>
            <span class="k">for</span> <span class="n">local_var</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PRIMARY_VARIABLES</span><span class="p">]:</span>

                <span class="c1"># Identify all defined discretization terms for this variable.</span>
                <span class="c1"># Do a second loop over the variables of the grid, the combination</span>
                <span class="c1"># of the two variables gives us all coupling terms (e.g. an off-diagonal</span>
                <span class="c1"># block in the global matrix)</span>
                <span class="k">for</span> <span class="n">other_local_var</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PRIMARY_VARIABLES</span><span class="p">]:</span>
                    <span class="c1"># We need to identify identify individual discretization terms</span>
                    <span class="c1"># defined for this equation. These are identified either by</span>
                    <span class="c1"># the variable k (for variable dependence on itself), or the</span>
                    <span class="c1"># combination var1_var2 if the variables are mixed</span>
                    <span class="n">merged_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_discretization_key</span><span class="p">(</span><span class="n">local_var</span><span class="p">,</span> <span class="n">other_local_var</span><span class="p">)</span>

                    <span class="c1"># Get hold of the discretization operators defined for this</span>
                    <span class="c1"># subdomain / interface; we really just need the keys in the</span>
                    <span class="c1"># discretization map.</span>
                    <span class="c1"># The default assumption is that no discretization has</span>
                    <span class="c1"># been defined, in which case we do nothing.</span>
                    <span class="n">discr</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                    <span class="c1"># It may be that there is no discretization specified</span>
                    <span class="k">if</span> <span class="n">discr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Loop over all the discretization operations, if any, and</span>
                    <span class="c1"># add it to the list of observed variables.</span>
                    <span class="c1"># We will take care of duplicates below.</span>
                    <span class="n">terms</span> <span class="o">=</span> <span class="n">discr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">merged_vars</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">terms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
                        <span class="n">variable_combinations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_variable_term_key</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">local_var</span><span class="p">,</span> <span class="n">other_local_var</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">grid_variable_term_combinations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">GridVariableTerm</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">local_var</span><span class="p">,</span> <span class="n">other_local_var</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span>
                        <span class="p">)</span>

        <span class="c1"># Next do the equivalent operation for interfaces.</span>
        <span class="c1"># Most steps are identical to the operations on the subdomains, we comment</span>
        <span class="c1"># only on interface-specific aspects; see above loop for more information</span>
        <span class="k">for</span> <span class="n">intf</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interfaces</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

            <span class="c1"># If for some reason there are no primary variables defined for this interface,</span>
            <span class="c1"># skip it.</span>
            <span class="k">if</span> <span class="n">pp</span><span class="o">.</span><span class="n">PRIMARY_VARIABLES</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">local_var</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PRIMARY_VARIABLES</span><span class="p">]:</span>

                <span class="c1"># Identify all discretization terms for this variable</span>
                <span class="k">for</span> <span class="n">other_local_var</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PRIMARY_VARIABLES</span><span class="p">]:</span>
                    <span class="n">merged_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_discretization_key</span><span class="p">(</span><span class="n">local_var</span><span class="p">,</span> <span class="n">other_local_var</span><span class="p">)</span>
                    <span class="n">discr</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">discr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">terms</span> <span class="o">=</span> <span class="n">discr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">merged_vars</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">terms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">variable_combinations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_variable_term_key</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">local_var</span><span class="p">,</span> <span class="n">other_local_var</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">grid_variable_term_combinations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">GridVariableTerm</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">local_var</span><span class="p">,</span> <span class="n">other_local_var</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span>
                        <span class="p">)</span>
            <span class="c1"># Finally, identify variable combinations for coupling terms.</span>
            <span class="c1"># This involves both the neighboring grids</span>
            <span class="n">sd_primary</span><span class="p">,</span> <span class="n">sd_secondary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_to_subdomain_pair</span><span class="p">(</span><span class="n">intf</span><span class="p">)</span>

            <span class="n">discr</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">COUPLING_DISCRETIZATION</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">discr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">discr</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># term identifies the discretization operator (e.g. advection or</span>
                <span class="c1"># diffusion), val contains the coupling information</span>

                <span class="c1"># Identify this term in the discretization by the variable names</span>
                <span class="c1"># on the interface, the variable names of the secondary and primary grid</span>
                <span class="c1"># in that order, and finally the term name.</span>
                <span class="c1"># There is a tacit assumption here that</span>
                <span class="c1"># self.mdg.interface_to_subdomain_pair returns the</span>
                <span class="c1"># grids in the same order here and in the assembly. This should be okay.</span>
                <span class="c1"># The consequences for the methods if this is no longer the case is unclear.</span>

                <span class="c1"># Get the name of the interface variable (it is the first item in a tuple)</span>
                <span class="n">key_intf</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">intf</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Get name of the interface variable, if it exists</span>
                <span class="n">key_secondary</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sd_secondary</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key_secondary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">key_secondary</span> <span class="o">=</span> <span class="n">key_secondary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># This can happen if the the coupling is one-sided, e.g.</span>
                    <span class="c1"># it does not consider the secondary grid.</span>
                    <span class="c1"># An empty string will give no impact on the generated</span>
                    <span class="c1"># combination of variable names and discretizaiton terms</span>
                    <span class="n">key_secondary</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

                <span class="n">key_primary</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sd_primary</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key_primary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">key_primary</span> <span class="o">=</span> <span class="n">key_primary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">key_primary</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

                <span class="n">variable_combinations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_variable_term_key</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">key_intf</span><span class="p">,</span> <span class="n">key_secondary</span><span class="p">,</span> <span class="n">key_primary</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">grid_variable_term_combinations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">CouplingVariableTerm</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">sd_primary</span><span class="p">,</span> <span class="n">sd_secondary</span><span class="p">,</span> <span class="n">intf</span><span class="p">),</span>
                        <span class="n">key_intf</span><span class="p">,</span>
                        <span class="n">key_primary</span><span class="p">,</span>
                        <span class="n">key_secondary</span><span class="p">,</span>
                        <span class="n">term</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="c1"># Store values in self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable_combinations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">variable_combinations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grid_variable_term_combinations</span> <span class="o">=</span> <span class="n">grid_variable_term_combinations</span>

<div class="viewcode-block" id="Assembler.update_dof_count"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler.html#porepy.numerics.mixed_dim.assembler.Assembler.update_dof_count">[docs]</a>    <span class="k">def</span> <span class="nf">update_dof_count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update the count of degrees of freedom related to a MixedDimensionalGrid.</span>

<span class="sd">        The method loops through the defined combinations of grids (standard or mortar)</span>
<span class="sd">        and variables, and updates the number of fine-scale degree of freedom for this</span>
<span class="sd">        combination. The system size will be updated if the grid has changed or</span>
<span class="sd">        (perhaps less realistically) a variable has had its number of dofs per grid</span>
<span class="sd">        quantity changed.</span>

<span class="sd">        The method will not identify any new variables, for this, the preferred approach</span>
<span class="sd">        is to define a new assembler object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Loop over identified grid-variable combinations</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">block_dof</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Grid quantity (grid or interface), and variable</span>
            <span class="n">grid</span><span class="p">,</span> <span class="n">variable</span> <span class="o">=</span> <span class="n">key</span>
            <span class="c1"># Get data dictionary - this is slightly different for grid and interface</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomain_data</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># This is an interface</span>
                <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_data</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

            <span class="c1"># Dofs related to cell</span>
            <span class="n">dof</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PRIMARY_VARIABLES</span><span class="p">][</span><span class="n">variable</span><span class="p">]</span>
            <span class="n">num_dofs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_cells</span> <span class="o">*</span> <span class="n">dof</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cells&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">):</span>
                <span class="c1"># Add dofs on faces and nodes, but not on interfaces</span>
                <span class="n">num_dofs</span> <span class="o">+=</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_faces</span> <span class="o">*</span> <span class="n">dof</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;faces&quot;</span><span class="p">,</span> <span class="mi">0</span>
                <span class="p">)</span> <span class="o">+</span> <span class="n">grid</span><span class="o">.</span><span class="n">num_nodes</span> <span class="o">*</span> <span class="n">dof</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nodes&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Update local counting</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">full_dof</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_dofs</span></div>

    <span class="k">def</span> <span class="nf">_initialize_matrix_rhs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sps_matrix</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">csc_or_csr_matrix</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">csc_or_csr_matrix</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a set of matrices (for left-hand sides) and vectors (rhs)</span>
<span class="sd">        for all operators associated with a variable (example: a temperature</span>
<span class="sd">        variable in an advection-diffusion problem will typically have two</span>
<span class="sd">        operators, one for advection, one for diffusion).</span>

<span class="sd">        It is useful to differ between the discretization matrices of different</span>
<span class="sd">        variables and terms for at least two reasons:</span>
<span class="sd">          1) It is useful in time stepping methods, where only some terms</span>
<span class="sd">             are time dependent</span>
<span class="sd">          2) In some discretization schemes, the coupling discretization can</span>
<span class="sd">             override discretizations on the neighboring subdomains. It is critical</span>
<span class="sd">             that this only overrides values associated with the relevant terms.</span>
<span class="sd">        We therefore generate one discretization matrix and right hand side</span>
<span class="sd">        per term, as identified in variable_combinations.</span>

<span class="sd">        NOTE: It is possible to construct cases where variable and discretization</span>
<span class="sd">        names give unfortunate consequences. However, it does not seem worth</span>
<span class="sd">        the effort to split the matrix even further.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            sps_matrix (class): Class for sparse matrices, used to initialize</span>
<span class="sd">                individual blocks in the matrix.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Global system matrices, on block form (one per subdomain/interface</span>
<span class="sd">                per variable). There is one item per term (e.g. diffusion/advection)</span>
<span class="sd">                per variable.</span>
<span class="sd">            dict: Right hand sides. Similar to the system matrix.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We will have one discretization matrix per variable</span>
        <span class="n">matrix_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">csc_or_csr_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">rhs_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">num_blocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">full_dof</span><span class="p">)</span>

        <span class="c1"># Uniquify list of variable combinations. Then iterate over all variable</span>
        <span class="c1"># combinations and initialize matrices of the right size</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable_combinations</span><span class="p">)):</span>

            <span class="c1"># Generate a block matrix</span>
            <span class="n">matrix_dict</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_blocks</span><span class="p">,</span> <span class="n">num_blocks</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="n">rhs_dict</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

            <span class="c1"># Loop over all blocks, initialize the diagonal block.</span>
            <span class="c1"># We could also initialize off-diagonal blocks, however, this turned</span>
            <span class="c1"># out to be computationally expensive.</span>
            <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">):</span>
                <span class="c1"># Initilize the block diagonal parts, this is useful for the bmat done</span>
                <span class="c1"># at the end of assemble_matrix_rhs to know the correct shape of the</span>
                <span class="c1"># full matrix</span>
                <span class="n">matrix_dict</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="n">di</span><span class="p">,</span> <span class="n">di</span><span class="p">]</span> <span class="o">=</span> <span class="n">sps_matrix</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">full_dof</span><span class="p">[</span><span class="n">di</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">full_dof</span><span class="p">[</span><span class="n">di</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="n">rhs_dict</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="n">di</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">full_dof</span><span class="p">[</span><span class="n">di</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">matrix_dict</span><span class="p">,</span> <span class="n">rhs_dict</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_assign_matrix_vector</span><span class="p">(</span>
        <span class="n">dof</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sps_matrix</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">csc_or_csr_matrix</span><span class="p">],</span> <span class="n">create_matrix</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Assign a block matrix and vector with specified number of dofs per block&quot;&quot;&quot;</span>
        <span class="n">num_blocks</span> <span class="o">=</span> <span class="n">dof</span><span class="o">.</span><span class="n">size</span>

        <span class="k">if</span> <span class="n">create_matrix</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_blocks</span><span class="p">,</span> <span class="n">num_blocks</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">):</span>
            <span class="n">rhs</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dof</span><span class="p">[</span><span class="n">ri</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">create_matrix</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">):</span>
                    <span class="n">matrix</span><span class="p">[</span><span class="n">ri</span><span class="p">,</span> <span class="n">ci</span><span class="p">]</span> <span class="o">=</span> <span class="n">sps_matrix</span><span class="p">((</span><span class="n">dof</span><span class="p">[</span><span class="n">ri</span><span class="p">],</span> <span class="n">dof</span><span class="p">[</span><span class="n">ci</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">create_matrix</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">rhs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rhs</span>

<div class="viewcode-block" id="Assembler.assemble_operator"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler.html#porepy.numerics.mixed_dim.assembler.Assembler.assemble_operator">[docs]</a>    <span class="k">def</span> <span class="nf">assemble_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">operator_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assemble a global agebraic operator from the local algebraic operators on</span>
<span class="sd">        the subdomains or interfaces of a mixed-dimensional grid.</span>
<span class="sd">        The global operator is a block diagonal matrix with the local operators</span>
<span class="sd">        on the diagonal.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            keyword (string): Keyword for the dictionary in</span>
<span class="sd">                d[pp.DISCRETIZATION_MATRICES] for which the operator is stored.</span>
<span class="sd">            operator_name (string): keyword for the operator in the</span>
<span class="sd">                d[pp.DISCRETIZATION_MATRICES][keyword] dictionary.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Operator (sps.block_diag): Global algebraic operator.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">_get_operator</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">_keyword</span><span class="p">,</span> <span class="n">_operator_name</span><span class="p">):</span>
            <span class="n">loc_disc</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">DISCRETIZATION_MATRICES</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">_keyword</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">loc_disc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Return if keyword is not found</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">loc_op</span> <span class="o">=</span> <span class="n">loc_disc</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">_operator_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">loc_op</span>

        <span class="c1"># Loop over subdomains in the mdg to find the local operators</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">_get_operator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">operator_name</span><span class="p">)</span>
            <span class="c1"># If a subdomain does not have the keyword or operator, do not add it.</span>
            <span class="k">if</span> <span class="n">op</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

        <span class="c1"># Loop over interfaces in the mdg to find the local operators</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interfaces</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">_get_operator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">operator_name</span><span class="p">)</span>
            <span class="c1"># If an interface does not have the keyword or operator, do not add it.</span>
            <span class="k">if</span> <span class="n">op</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Could not find operator: &quot;</span> <span class="o">+</span> <span class="n">operator_name</span> <span class="o">+</span> <span class="s2">&quot; for keyword: &quot;</span> <span class="o">+</span> <span class="n">keyword</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">sps</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembler.assemble_parameter"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler.html#porepy.numerics.mixed_dim.assembler.Assembler.assemble_parameter">[docs]</a>    <span class="k">def</span> <span class="nf">assemble_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">parameter_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assemble a global parameter from the local parameters defined on</span>
<span class="sd">        the subdomains or interfaces of a mixed-dimensional grid.</span>
<span class="sd">        The global parameter is a nd-vector of the stacked local parameters.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            keyword (string): Keyword to access the dictionary</span>
<span class="sd">                d[pp.PARAMETERS][keyword] for which the parameters are stored.</span>
<span class="sd">            parameter_name (string): keyword of the parameter. Will access</span>
<span class="sd">                d[pp.DISCRETIZATION_MATRICES][keyword][parameter].</span>

<span class="sd">        Returns:</span>
<span class="sd">            Operator (np.ndarray): Global parameter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parameter</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">return_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">parameter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">PARAMETERS</span><span class="p">][</span><span class="n">keyword</span><span class="p">][</span><span class="n">parameter_name</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_local_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Find variables defined in a data dictionary, and do intersection</span>
<span class="sd">        with defined active variables.</span>

<span class="sd">        If no active variables are specified, returned all declared variables.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            d (dict): Data dictionary defined on a MixedDimensionalGrid subdomain</span>
<span class="sd">                or interface.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: With variable names and information (#dofs of various kinds), as</span>
<span class="sd">                specified by user, but possibly restricted to the active variables</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Active variables</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">PRIMARY_VARIABLES</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="Assembler.distribute_variable"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler.html#porepy.numerics.mixed_dim.assembler.Assembler.distribute_variable">[docs]</a>    <span class="k">def</span> <span class="nf">distribute_variable</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">variable_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Distribute a vector to the subdomains and interfaces in the</span>
<span class="sd">        MixedDimensionalGrid.</span>

<span class="sd">        The intended use is to split a multi-physics solution vector into its</span>
<span class="sd">        component parts.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            values (np.array): Vector to be split. It is assumed that it corresponds</span>
<span class="sd">                to the ordering implied in block_dof and full_dof, e.g. that it is</span>
<span class="sd">                the solution of a linear system assembled with the assembler.</span>
<span class="sd">            variable_names (list of str, optional): Names of the variable to be</span>
<span class="sd">                distributed. If not provided, all variables found in block_dof</span>
<span class="sd">                will be distributed</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">distribute_variable</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="n">variable_names</span><span class="p">)</span></div>

<div class="viewcode-block" id="Assembler.num_dof"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler.html#porepy.numerics.mixed_dim.assembler.Assembler.num_dof">[docs]</a>    <span class="k">def</span> <span class="nf">num_dof</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get total number of unknowns of the identified variables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.int_: Number of unknowns. Size of solution vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">num_dofs</span><span class="p">()</span></div>

<div class="viewcode-block" id="Assembler.variables_of_grid"><a class="viewcode-back" href="../../../../docsrc/porepy/porepy.numerics.mixed_dim.assembler.html#porepy.numerics.mixed_dim.assembler.Assembler.variables_of_grid">[docs]</a>    <span class="k">def</span> <span class="nf">variables_of_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pp</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">MortarGrid</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get all variables defined for a given subdomain or interface.</span>

<span class="sd">        Args:</span>
<span class="sd">            g (Union[pp.Grid, Tuple[pp.Grid, pp.Grid]]): Target subdomain, or an interface.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[str]: List of all variables known for this entity.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">block_dof</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">g</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">block_dof</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
        <span class="n">unique_vars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Assembler object on a MixedDimensionalGrid with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">num_subdomains</span><span class="p">()</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;subdomains and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">num_interfaces</span><span class="p">()</span><span class="si">}</span><span class="s2"> interfaces.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Total number of degrees of freedom: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dof</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;Total number of subdomain and interface variables:&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">block_dof</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Variable names: </span><span class="si">{</span><span class="n">unique_vars</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Assembler objcet with in total </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dof</span><span class="p">()</span><span class="si">}</span><span class="s2"> dofs&quot;</span>
            <span class="sa">f</span><span class="s2">&quot; on </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">block_dof</span><span class="p">)</span><span class="si">}</span><span class="s2"> subdomain and interface variables.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Maximum grid dimension: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">dim_max</span><span class="p">()</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Minimum grid dimension: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">dim_min</span><span class="p">()</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">dim_max</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">dim_min</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;In dimension </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">len</span><span class="p">([</span><span class="n">sd</span> <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">)])</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;grids.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">unique_vars</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dof_manager</span><span class="o">.</span><span class="n">block_dof</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="n">dim</span>
            <span class="p">}</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;All variables present in dimension </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">unique_vars</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>

            <span class="c1"># Also check if some subdomains of this dimension have a subset of the</span>
            <span class="c1"># variables defined on the totality of the subdomains</span>

            <span class="c1"># List of found special (subset) variable combinations</span>
            <span class="n">found_special_var_combination</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Loop over all grids of this dimension</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">):</span>
                <span class="c1"># All variables on this subdomain</span>
                <span class="n">var</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables_of_grid</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
                <span class="c1"># Check if this is a subset of the full variable list on this dimension</span>
                <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">unique_vars</span><span class="p">):</span>
                    <span class="c1"># We will only report each subset variable definition once.</span>
                    <span class="c1"># If this subset hasn&#39;t already been reported, report it.</span>
                    <span class="n">already_reported</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">var</span> <span class="o">==</span> <span class="n">spec</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">found_special_var_combination</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">already_reported</span><span class="p">:</span>
                        <span class="n">found_special_var_combination</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                        <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Variable subset on at least one subdomain in &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;dimension </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="p">)</span>

        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">dim_max</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">dim_min</span><span class="p">(),</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">unique_vars</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">var</span>
                <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span>  <span class="c1"># For each grid of dimension dim</span>
                <span class="k">for</span> <span class="n">mg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomain_to_interfaces</span><span class="p">(</span>  <span class="c1"># type:ignore</span>
                    <span class="n">g</span>
                <span class="p">)</span>  <span class="c1"># for each interface of that grid</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">interface_to_subdomain_pair</span><span class="p">(</span><span class="n">mg</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="o">==</span> <span class="n">g</span>  <span class="c1"># such that the interface neighbors a lower-dimensional subdomain</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables_of_grid</span><span class="p">(</span>
                    <span class="n">mg</span>
                <span class="p">)</span>  <span class="c1"># get all variables on that interface</span>
            <span class="p">}</span>

            <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;All variables present on interfaces between dimensions </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">dim</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">unique_vars</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Also check if some subdomains of this dimension have a subset of the</span>
            <span class="c1"># variables defined on the totality of the subdomains</span>

            <span class="c1"># List of found special (subset) variable combinations</span>
            <span class="n">found_special_var_combination</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomains</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">intf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdg</span><span class="o">.</span><span class="n">subdomain_to_interfaces</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
                    <span class="n">var</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables_of_grid</span><span class="p">(</span><span class="n">intf</span><span class="p">))</span>
                    <span class="c1"># Check if this is a subset of the full variable list on this dimension</span>
                    <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">unique_vars</span><span class="p">):</span>
                        <span class="c1"># We will only report each subset variable definition once.</span>
                        <span class="c1"># If this subset hasn&#39;t already been reported, report it.</span>
                        <span class="n">already_reported</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">var</span> <span class="o">==</span> <span class="n">spec</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">found_special_var_combination</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">already_reported</span><span class="p">:</span>
                            <span class="n">found_special_var_combination</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                            <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Variable subset on at least one interface between &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;dimension </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">dim</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="p">)</span>

        <span class="k">return</span> <span class="n">s</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022 UiB Center for Modeling of Coupled Subsurface Dynamics, GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007..</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>