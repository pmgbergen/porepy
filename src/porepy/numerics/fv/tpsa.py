import numpy as np
import scipy.sparse as sps

from porepy.numerics.fv import fvutils
from porepy.grids.grid import Grid
from porepy.numerics.linalg.matrix_operations import sparse_array_to_row_col_data
from porepy.params.tensor import FourthOrderTensor
import porepy as pp
import warnings
from dataclasses import dataclass


@dataclass
class _Numbering:
    nc: int
    nf: int
    nd: int
    fi: np.ndarray
    ci: np.ndarray
    fi_expanded: np.ndarray
    ci_expanded: np.ndarray
    sgn: np.ndarray
    sgn_nd: np.ndarray


@dataclass
class _BoundaryFilters:
    """Helper class to store filters for applying various boundary conditions.

    The class stores only attributes needed in the implementation; it may well be that
    different choices in implementation would have needed different filters.
    """

    dir_pass_nd: sps.sparray
    """Filter that only lets through boundary faces with Dirichlet conditions."""

    dir_nopass: sps.sparray
    """Filter that removes Dirichlet conditions. TODO: WHY NOT ND"""

    dir_nopass_nd: sps.sparray
    """Filter that removes boundary faces with Dirichlet conditions. """

    neu_nopass_nd: sps.sparray
    """Filter that removes boundary faces with Neumann conditions. """

    neu_rob_pass_nd: sps.sparray
    """Filter that only lets through boundary faces with Neumann or Robin conditions."""

    rob_pass_nd: sps.sparray
    """Filter that only lets through boundary faces with Robin conditions."""


@dataclass
class _CellToFaceMaps:
    c2f: sps.sparray
    c2f_compl: sps.sparray
    c2f_compl_scalar_2_nd: sps.sparray
    b2f_rob: sps.sparray
    b2f_rob_compl: sps.sparray


@dataclass
class _Distances:
    dist_fc_cc: np.ndarray
    mu_by_dist_fc_cc: np.ndarray
    mu_by_dist_fc_cc_bound: np.ndarray
    inv_mu_by_dist_array: sps.dia_array
    rob_weight: np.ndarray


class Tpsa:

    def __init__(self, keyword: str) -> None:

        self.keyword: str = keyword
        """Keyword used to identify the parameter dictionary."""

        self.stress_displacement_matrix_key: str = "stress"
        """Keyword used to identify the discretization matrix for the stress generated
        by the cell center displacements. Defaults to 'stress'.
        """
        self.stress_rotation_matrix_key: str = "stress_rotation"
        """Keyword used to identify the discretization matrix for the rotational stress
        generated by the cell center rotational stress. Defaults to 'stress_rotation'."""

        self.stress_total_pressure_matrix_key: str = "stress_total_pressure"
        """Keyword used to identify the discretization matrix for the solid mass
        conservation generated by the cell center solid pressure. Defaults to 
        'stress_total_pressure'."""

        self.rotation_displacement_matrix_key: str = "rotation_displacement"
        """Keyword used to identify the discretization matrix for the rotation 
        generated by the cell center displacements. Defaults to
        'rotation_displacement'."""

        self.rotation_diffusion_matrix_key: str = "rotation_diffusion"
        """Keyword used to identify the discretization matrix for the rotational
        diffusion generated by the cell center rotational stress. Defaults to
        'rotation_diffusion'."""

        self.mass_total_pressure_matrix_key = "solid_mass_total_pressure"
        """Keyword used to identify the discretization matrix for the solid mass
        conservation generated by the cell center solid pressure. Defaults to
        'solid_mass_total_pressure'."""

        self.mass_displacement_matrix_key = "solid_mass_displacement"
        """Keyword used to identify the discretization matrix for the solid mass
        conservation generated by the cell center displacements. Defaults to
        'solid_mass_displacement'."""

        # Boundary conditions
        self.bound_stress_matrix_key: str = "bound_stress"
        self.bound_mass_displacement_matrix_key = "bound_mass_displacement"
        self.bound_rotation_diffusion_matrix_key = "bound_rotation_diffusion"
        self.bound_rotation_displacement_matrix_key = "bound_rotation_displacement"

    def discretize(self, sd: Grid, data: dict) -> None:
        """Discretize linear elasticity equation using a two-point stress approximation
        (TPSA).

        Optionally, the discretization can include microrotations, in the form of a
        Cosserat material.

        The method constructs a set of discretization matrices for the balance of linear
        and angular momentum, as well as conservation of solid mass.

        We assume the following two sub-dictionaries to be present in the data
        dictionary:
            parameter_dictionary, storing all parameters.
                Stored in ``data[pp.PARAMETERS][self.keyword]``.
            matrix_dictionary, for storage of discretization matrices.
                Stored in ``data[pp.DISCRETIZATION_MATRICES][self.keyword]``

        parameter_dictionary contains the entries:
            - fourth_order_tensor: ``class:~porepy.params.tensor.FourthOrderTensor``
                Stiffness tensor defined cell-wise. Note that the discretization will
                act directly on the lame parameters ``FourthOrderTensor.mu``,
                ``FourthOrderTensor.lmbda``. That is, anisotropy encoded into the
                stiffness tensor will not be considered.

            - bc: ``class:~porepy.params.bc.BoundaryConditionVectorial``
                Boundary conditions

            - cosserat_parameter (optional): np.ndarray giving the Cosserat parameter,
                which can be considered a parameter for diffusion of microrotations.
                Should have length equal to the number of cells. If not provided, the
                Cosserat parameter is set to zero.

        TOOD: Complete documentation.

        matrix_dictionary will be updated with the following entries:
            - ``stress: sps.csc_matrix (sd.dim * sd.num_faces, sd.dim * sd.num_cells)``
                stress discretization, cell center contribution
            - ``bound_flux: sps.csc_matrix (sd.dim * sd.num_faces, sd.dim *
                sd.num_faces)`` stress discretization, face contribution
            - ``bound_displacement_cell: sps.csc_matrix (sd.dim * sd.num_faces,
                                                         sd.dim * sd.num_cells)``
                Operator for reconstructing the displacement trace. Cell center
                contribution.
            - ``bound_displacement_face: sps.csc_matrix (sd.dim * sd.num_faces,
                                                         sd.dim * sd.num_faces)``
                Operator for reconstructing the displacement trace. Face contribution.

        Parameters:
            sd: grid, or a subclass, with geometry fields computed.

            data: For entries, see above.

        """

        parameter_dictionary: dict[str, Any] = data[pp.PARAMETERS][self.keyword]
        matrix_dictionary: dict[str, sps.spmatrix] = data[pp.DISCRETIZATION_MATRICES][
            self.keyword
        ]

        numbering = self._create_numbering(sd)

        # Fetch parameters for the mechanical behavior
        stiffness: FourthOrderTensor = parameter_dictionary["fourth_order_tensor"]
        # The Cosserat parameter, if present. If this is None, the Cosserat parameter is
        # considered to be zero. In practice, we will set all Cosserat discretization
        # matrices to zero with no explicit computations
        cosserat_values: np.ndarray | None = parameter_dictionary.get(
            "cosserat_parameter", None
        )

        # Boundary condition object. Use the keyword 'bc' here to be compatible with the
        # implementation in mpsa.py, although symmetry with the boundary conditions for
        # rotation seems to call for a keyword like 'bc_disp'.
        bnd_disp: pp.BoundaryConditionVectorial = parameter_dictionary["bc"]

        # Boundary conditions for the rotation variable. This should only be used if
        # the Cosserat parameter is non-zero. Since the rotation variable is scalar if
        # nd == 2 and vector if nd == 3, the type of boundary condition depends on the
        # dimension.
        bnd_rot: pp.BoundaryCondition | pp.BoundaryConditionVectorial = (
            parameter_dictionary.get("bc_rot", None)
        )

        # Check that the type of boundary condition is consistent with the dimension.
        # This is a bit awkward, since it requires an if-else on the client side, but
        # the alternative is to always use a vectorial boundary condition and make a
        # hack to interpret the vectorial condition as a scalar one for 2d problems.
        # Note that, if the Cosserat parameter is zero, all of this is irrelevant.
        if numbering.nd == 2:
            if isinstance(bnd_rot, pp.BoundaryConditionVectorial):
                raise ValueError(
                    "Boundary conditions for rotations should be scalar if nd == 2"
                )
        elif numbering.nd == 3:
            if isinstance(bnd_rot, pp.BoundaryCondition):
                raise ValueError(
                    "Boundary conditions for rotations should be vectorial if nd == 3"
                )

        # Sanity check: If the Cosserat parameter is None, the boundary conditions for
        # the rotation variable are not relevant.
        if bnd_rot is not None and cosserat_values is None:
            # TODO: Should this be a warning, an error, or just ignored? The latter
            # allows for a more unified implementation of the pure elasticity and
            # Cosserat cases on the client side.
            warnings.warn(
                "Boundary conditions for rotations are only relevant if the Cosserat "
                "parameter is non-zero."
            )
        if bnd_rot is not None and np.sum(bnd_rot.is_rob) > 0:
            # The implementation should not be difficult, but has not been prioritized.
            raise NotImplementedError(
                "Robin conditions for rotations have not been implemented"
            )

        # Map the stiffness tensor to the face-wise ordering
        mu = stiffness.mu[numbering.ci]
        if cosserat_values is not None:
            cosserat_parameter = cosserat_values[numbering.ci]


        # For Dirichlet conditions, set the averaging map to zero (as is the correct
        # discretization). TODO: Treat Neumann, and possibly Robin, conditions.
        is_dir_nd = bnd_disp.is_dir
        is_dir = is_dir_nd.ravel("F")
        is_neu_nd = bnd_disp.is_neu
        is_neu = is_neu_nd.ravel("F")

        # It is not clear to EK whether it is meaningful to consider a mixture of Robin
        # and other boundary conditions; it has not been accounted for.
        is_rob_nd = bnd_disp.is_rob
        has_rob = np.any(is_rob_nd, axis=0)
        if np.any(np.logical_not(is_rob_nd[:, has_rob])) > 0:
            raise NotImplementedError(
                "Have not implemnented a mixture of Robin and other boundary conditions"
            )
        is_rob = is_rob_nd.ravel("F")

        if (
            np.linalg.norm(
                np.array(
                    [
                        bnd_disp.basis[:, :, i] - np.eye(numbering.nd)
                        for i in range(numbering.nf)
                    ]
                )
            )
            > 0
        ):
            raise NotImplementedError(
                "Have not implemented Robin conditions with a non-trivial basis"
            )

        # The Robin weight will be an nd x nd x nf array, with nd={2, 3}. For the
        # implementation to be valid in both cases, we use slices ([2:]) instead of
        # indexing ([2]), as the former will work also if the array has less than three
        # rows.
        if np.logical_or.reduce(
            (
                np.any(bnd_disp.robin_weight[0, 1:, :] > 0),
                np.any(bnd_disp.robin_weight[1, 0, :] > 0),
                np.any(bnd_disp.robin_weight[1, 2:, :] > 0),
                np.any(bnd_disp.robin_weight[2:, :2, :] > 0),
            )
        ):
            raise NotImplementedError(
                "Non-diagonal Robin weights have not been implemnted"
            )

        # Construct filters that are used to isolate faces with different types of
        # boundary conditions assigned. We do this only for the displacement variable;
        # for the rotation variable (in the case of a non-zero Cosserat parameter) we
        # only need to deal with Dirichlet and Neumann conditions on a diffusion problem
        # (Robin conditions have not been implemented, see above), which is relatively
        # easy and handled on the fly.
        filters = self._create_filters(bnd_disp, numbering, sd)

        dist, t_shear_rob = self._compute_distances(sd, numbering, mu, bnd_disp)
        
        c2f_maps = self._create_cell_to_face_maps(
            numbering,
            filters,
            bnd_disp,
            sd.get_all_boundary_faces(),
            dist,
        )

        # Finally we are ready to construct the discretization matrices.

        # Harmonic average of the shear modulus divided by the distance between the face
        # center and the cell center.

        # Compute t_shear as the sum of the contribution from the interior faces
        # (computed here) and the Robin boundary conditions (represented in t_shear_rob,
        # computed previously). Since the Robin conditions are already handled, we use
        # mu_by_dist_fc_cc, not mu_by_dist_fc_cc_bound.
        t_shear_nd = (
            2
            * np.repeat(sd.face_areas, numbering.nd)
            / (np.bincount(numbering.fi_expanded,
                weights=1.0 / np.repeat(dist.mu_by_dist_fc_cc, numbering.nd)) + t_shear_rob
            )
        ).reshape((numbering.nd, numbering.nf), order="F")



        # Discretize the stress-displacement relation:
        stress, bound_stress = self._vector_laplace_matrices(
            t_shear_nd, bnd_disp, numbering, c2f_maps.b2f_rob_compl
        )

        # Face normals (note: in the usual ordering, not the face-wise ordering used in
        # the variable n_fi)
        n = sd.face_normals

        # The stress generated by the total pressure is computed using the complement of
        # the average map (this is just how the algebra works out), scaled with the
        # normal vector. The latter also gives the correct scaling with the face area.
        # The effect of boundary conditions are already included in
        # cell_to_face_average_complement.

        stress_total_pressure = (
            filters.neu_nopass_nd
            @ sps.dia_matrix(
                (n[: numbering.nd].ravel("F"), 0),
                shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd),
            )
            @ c2f_maps.c2f_compl_scalar_2_nd
        )

        # The solid mass conservation equation is discretized by taking the average
        # displacement over the faces (not using the complement, again, this is just how
        # it is), and scaling with the normal vector. To that end, construct a sparse
        # matrix that has one normal vector per row.
        normal_vector_nd = sps.csr_matrix(
            (
                n[: numbering.nd].ravel("F"),
                np.arange(numbering.nf * numbering.nd),
                np.arange(0, numbering.nf * numbering.nd + 1, numbering.nd),
            ),
            shape=(numbering.nf, numbering.nf * numbering.nd),
        )
        # The impact on the solid mass flux from the displacement is then the matrix of
        # normal vectors multiplied with the average displacement over the faces.
        # This matrix will be empty on Dirichlet faces due to the filtering in
        # cell_to_face_average_nd.
        mass_displacement = normal_vector_nd @ c2f_maps.c2f

        # While there is no spatial operator that that relates the total pressure to the
        # conservation of solid mass in the continuous equation, the TPSA discretization
        # naturally leads to a stabilization term, as computed below. This acts on
        # differences in the total pressure, and is scaled with the face area. Since the
        # solid pressure is a derived boundary quantity for which there is no boundary
        # condition set, it is unclear what to actually do with boundary terms. The
        # current implementation seems to work.

        # Arithmetic average of shear modulus. No contribution from boundary conditions,
        # thus do not use mu_by_dist_fc_cc_bound (NOTE: It is not clear to EK this is
        # the final version of this part of the code, but I have no ideas how to do this
        # better).
        arithmetic_average_shear_modulus = np.bincount(
            numbering.fi,
            weights=dist.mu_by_dist_fc_cc,
            minlength=numbering.nf,
        )
        # Following the paper, we filter away Dirichlet boundary conditions.
        mass_total_pressure = -filters.dir_nopass @ (
            sps.dia_matrix(
                (sd.face_areas / (2 * arithmetic_average_shear_modulus), 0),
                shape=(numbering.nf, numbering.nf),
            )
            @ sd.cell_faces
        )

        # Take the harmonic average of the Cosserat parameter.
        # TODO: For zero Cosserat parameters, this involves a division by zero. This
        # gives no actual problem, but filtering would have been more elegant.
        if cosserat_values is not None:
            t_cosserat = sd.face_areas / np.bincount(
                numbering.fi,
                weights=1 / (cosserat_parameter / dist.dist_fc_cc),
                minlength=numbering.nf,
            )

        # The relations involving rotations are more cumbersome, as a rotation in 2d has
        # a single degree of freedom, while a 3d rotation has 3 degrees of freedom. This
        # necessitates (or at least is most easily realized) by a split into a 2d and a
        # 3d code. In the below if-else, we construct the matrices Rn_hat and Rn_bar
        # (see the TPSA paper for details) and use this to discretize stress generated by
        # cell center rotations. Moreover, we discretize the diffusion of rotations
        # generated by cell center displacements, which is different in 2d and 3d.
        if numbering.nd == 3:
            # In this case, \hat{R}_k^n = \bar{R}_k^n is the 3x3 projection matrix as
            # given in the TPSA paper reads
            #
            #    R^n = [[0, -n2, n0], [n2, 0, -n0], [-n1, n0, 0]]
            #
            # However, for efficient implementation we will use the function, which
            # in turns out, requires a transpose in the inner array. Quite likely this
            # could have been achieved by a different order of raveling (see below), but
            # this also worked.
            #
            # For reference, it is possible to use the following code to construct R_hat
            #
            # Rn_data = np.array([[z, -n[2], n[1]], [n[2], z, -n[0]], [-n[1], n[0], z]])
            # Rn_hat = sps.block_diag([Rn_data[:, :, i] for i in range(Rn.shape[2])])
            #
            # but this is much slower due to the block_diag construction.

            z = np.zeros(numbering.nf)
            Rn_data = np.array([[z, n[2], -n[1]], [-n[2], z, n[0]], [n[1], -n[0], z]])

            Rn_hat = pp.matrix_operations.csr_matrix_from_blocks(
                Rn_data.ravel("F"), numbering.nd, numbering.nf
            )
            Rn_bar = Rn_hat

            # Discretization of the stress generated by cell center rotations.
            stress_rotation = -filters.neu_nopass_nd @ Rn_hat @ c2f_maps.c2f_compl

            if cosserat_values is not None:
                # Use the discretization of Laplace's problem. The transmissibility will
                # be the same in all directions.
                rotation_diffusion, bound_rotation_diffusion = (
                    self._vector_laplace_matrices(
                        np.tile(t_cosserat, (numbering.nd, 1)),
                        bnd_rot,
                        numbering,
                        c2f_maps.b2f_rob_compl,
                    )
                )

            else:
                # If the Cosserat parameter is zero, the diffusion operator is zero.
                rotation_diffusion = sps.csr_matrix(
                    (numbering.nf * numbering.nd, numbering.nc * numbering.nd)
                )
                bound_rotation_diffusion = sps.csr_matrix(
                    (numbering.nf * numbering.nd, numbering.nf * numbering.nd)
                )

        elif numbering.nd == 2:
            # In this case, \hat{R}_k^n and \bar{R}_k^n differ, and read, respectively
            #   \hat{R}_k^n = [[n2], [-n1]],
            #   \bar{R}_k^n = [-n2, n1].

            # Vector of normal vectors
            normal_vector_data = np.array([n[1], -n[0]])

            # Mapping from average displacements over faces to rotations on the face.
            # minus sign from definition of Rn_bar
            Rn_bar = sps.csr_matrix(
                (
                    -normal_vector_data.ravel("F"),
                    np.arange(numbering.nf * numbering.nd),
                    np.arange(0, numbering.nd * numbering.nf + 1, numbering.nd),
                ),
                shape=(numbering.nf, numbering.nf * numbering.nd),
            )
            # Mapping from average rotations over faces to stresses
            Rn_hat = sps.dia_matrix(
                (normal_vector_data.ravel("F"), 0),
                shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd),
            )
            # # Discretization of the stress generated by cell center rotations.
            stress_rotation = (
                -filters.neu_nopass_nd @ Rn_hat @ c2f_maps.c2f_compl_scalar_2_nd
            )

            # Diffusion operator on the rotation if relevant.
            if cosserat_values is not None:
                # In 2d, the rotation is a scalar variable and we can treat this by
                # essentially, tpfa.

                t_cosserat_bnd = np.zeros(numbering.nf)
                t_cosserat_bnd[bnd_rot.is_dir] = t_cosserat[bnd_rot.is_dir]
                # The boundary condition should simply be imposed. Put a -1 to
                # counteract the minus sign in the construction of the discretization
                # matrix.
                t_cosserat_bnd[bnd_rot.is_neu] = 1
                t_cosserat[bnd_rot.is_neu] = 0

                # TODO: Why minus sign here, but not in tpfa? Darcy vs Hook.
                rotation_diffusion = -sps.coo_matrix(
                    (
                        t_cosserat[numbering.fi] * numbering.sgn,
                        (numbering.fi, numbering.ci),
                    ),
                    shape=(numbering.nf, numbering.nc),
                ).tocsr()

                bound_rotation_diffusion = sps.coo_matrix(
                    (
                        t_cosserat_bnd[numbering.fi] * numbering.sgn,
                        (numbering.fi, numbering.fi),
                    ),
                    shape=(numbering.nf, numbering.nf),
                ).tocsr()

            else:
                rotation_diffusion = sps.csr_matrix((numbering.nf, numbering.nc))
                bound_rotation_diffusion = sps.csr_matrix((numbering.nf, numbering.nf))

        # The rotation generated by the cell center displacements is computed from the
        # average displacement over the faces, multiplied by Rn_bar. This construction
        # is common for both 2d and 3d.
        rotation_displacement = -Rn_bar @ c2f_maps.c2f

        # The boundary condition for the rotation equation's dependency on the
        # cell center displacements.

        # This is the expression \delta_k^mu.
        mu_face = sps.dia_matrix(
            (1 / (2 * dist.mu_by_dist_fc_cc_bound), 0),
            shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd),
        )
        # TODO: Implement Dirichlet conditions
        bound_rotation_displacement = Rn_bar @ (
            filters.neu_rob_pass_nd @ mu_face - filters.dir_pass_nd - c2f_maps.b2f_rob
        )

        # Boundary condition. There should be no contribution from Dofs which are
        # assigned a Dirichlet condition, so filter out these variables (this is likely
        # not fully consistent for domains with boundaries not aligned with the
        # coordinate axes, and with rolling boundary conditions, but EK does not know
        # what to do there).
        bound_mass_displacement = normal_vector_nd @ (
            filters.neu_rob_pass_nd @ mu_face + filters.dir_pass_nd
        )
        ## Store the computed fields

        # Discretization matrices
        matrix_dictionary[self.stress_displacement_matrix_key] = stress
        matrix_dictionary[self.stress_rotation_matrix_key] = stress_rotation
        matrix_dictionary[self.stress_total_pressure_matrix_key] = stress_total_pressure
        matrix_dictionary[self.rotation_displacement_matrix_key] = rotation_displacement
        matrix_dictionary[self.rotation_diffusion_matrix_key] = rotation_diffusion
        matrix_dictionary[self.mass_total_pressure_matrix_key] = mass_total_pressure
        matrix_dictionary[self.mass_displacement_matrix_key] = mass_displacement

        # Boundary conditions (NB: Only Dirichlet implemented for now)
        matrix_dictionary[self.bound_stress_matrix_key] = bound_stress
        matrix_dictionary[self.bound_mass_displacement_matrix_key] = (
            bound_mass_displacement
        )
        matrix_dictionary[self.bound_rotation_diffusion_matrix_key] = (
            bound_rotation_diffusion
        )
        matrix_dictionary[self.bound_rotation_displacement_matrix_key] = (
            bound_rotation_displacement
        )

    @staticmethod
    def _create_filters(
        bnd_disp: pp.BoundaryConditionVectorial, numbering: _Numbering, sd: pp.Grid
    ) -> _BoundaryFilters:

        is_dir = bnd_disp.is_dir.ravel("F")
        is_neu = bnd_disp.is_neu.ravel("F")
        is_rob = bnd_disp.is_rob.ravel("F")
        is_internal = np.logical_not(np.logical_or.reduce((is_dir, is_neu, is_rob)))

        dir_nd = sps.dia_matrix(
            (is_dir.astype(int), 0),
            shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd),
        )

        dir_nopass_nd = sps.dia_matrix(
            (np.logical_or.reduce((is_neu, is_rob, is_internal)).astype(int), 0),
            shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd),
        )

        neu_nopass_nd = sps.dia_matrix(
            (np.logical_or.reduce((is_dir, is_rob, is_internal)).astype(int), 0),
            shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd),
        )

        neu_rob_pass_nd = sps.dia_matrix(
            (np.logical_or(is_neu, is_rob).astype(int), 0),
            shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd),
        )
        rob_nd = sps.dia_array(
            (is_rob.astype(int), 0),
            shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd),
        )

        # We also need to deal with BCs on the numerical diffusion term for the solid
        # pressure. It is not fully clear what to do with this term on the boundary:
        # There is no boundary condition for the total pressure, this is in a sense
        # inherited from the displacement. The discretization scheme must however be
        # adjusted, so that it is zero on Dirichlet faces. The question is, what to do
        # with rolling boundary conditions, where a mixture of Dirichlet and Neumann
        # conditions are applied? For now, we pick the condition in the direction which
        # is closest to the normal vector of the face. While this should work nicely for
        # domains where the grid is aligned with the coordinate axis, it is more of a
        # question mark how this will work for rotated domains.
        max_ind = np.argmax(np.abs(sd.face_normals), axis=0)
        dir_scalar = bnd_disp.is_dir[max_ind, np.arange(numbering.nf)]
        dir_nopass = sps.dia_matrix(
            (np.logical_not(dir_scalar).astype(int), 0),
            shape=(numbering.nf, numbering.nf),
        )

        return _BoundaryFilters(
            dir_nd, dir_nopass, dir_nopass_nd, neu_nopass_nd, neu_rob_pass_nd, rob_nd
        )

    @staticmethod
    def _create_cell_to_face_maps(
        numbering: _Numbering,
        filters: _BoundaryFilters,
        bnd_disp: pp.BoundaryConditionVectorial,
        boundary_faces: np.ndarray,
        dist: _Distances,
    ):
        """Helper method to construct mappings from cells, and boundary conditions, to
        faces.

        Parameters:
            numbering: Structure for bookkeeping.
            filters: Necessary filters for imposing boundary conditions
            bnd_disp: Boundary condition object for the displacement variable
            mu_by_dist_fc_cc: The first Lame parameter, mu, divided
                mu the distance between cell and face centers. Expanded to nd.
        """
        # Handling of Dirichlet conditions
        is_dir_nd = bnd_disp.is_dir
        is_rob_nd = bnd_disp.is_rob
        is_dir = is_dir_nd.ravel("F")

        # Mapping from cell to face, with a weighting of mu / dist.
        cell_to_face = sps.coo_array(
            ((dist.mu_by_dist_fc_cc, (numbering.fi, numbering.ci))),
            shape=(numbering.nf, numbering.nc),
        ).tocsr()

        # Create the nd version, multiply with a scaling matrix to get an averaging map,
        # and filter away Dirichlet boundary conditions (these will be enforced
        # elsewhere in the code).
        c2f = filters.dir_nopass_nd @ dist.inv_mu_by_dist_array @ sps.kron(cell_to_face, sps.eye(numbering.nd), format='csr')
        # Complement map.
        c2f_compl = sps.csr_matrix(
            (
                1 - c2f.data,
                c2f.indices,
                c2f.indptr
            ),
            shape=c2f.shape,
        )

        # Create a mapping for Robin boundary values specifically (note the filter that
        # lets Robin conditions pass). Inspection of the part of the code where this map
        # is used will show that Dirichlet and Neumann conditions are treated separately
        # using filters (which are binary, we cannot do this with Robin since this is a
        # weighted map).
        b2f_rob = (
            filters.rob_pass_nd
            @ dist.inv_mu_by_dist_array
            @ sps.dia_array(
                (dist.rob_weight.ravel("F"), 0),
                shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd),
            )
        )
        # For the complement, we only need the diagnoal data.
        b2f_rob_compl = 1 - b2f_rob.diagonal()

        # Map from scalar cell quantities to nd face quantities (used e.g. for the solid
        # pressure).
        c2f_scalar_2_nd = dist.inv_mu_by_dist_array @ sps.kron(
            cell_to_face, sps.csr_array(np.ones((numbering.nd, 1))), format='csr'
        )
        # Specifically set a zero value for faces that have Dirichlet conditions, as
        # these will draw their values from the boundary condition. While this could
        # have been realized by multiplication with filters.dir_nopass_nd, this would
        # have left implicit (not represented) zeros at the boundaries, whereas we need
        # explicit zeros to construct the complement map below. Hence we enforce the
        # zeros by manipulating the data array.
        c2f_rows, *_ = sps.find(c2f_scalar_2_nd)
        c2f_rows_is_dir = np.in1d(c2f_rows, np.where(is_dir))
        c2f_scalar_2_nd.data[c2f_rows_is_dir] = 0
        # Complement map.
        c2f_compl_scalar_2_nd = sps.csr_array(
            (
                1 - c2f_scalar_2_nd.data,
                c2f_scalar_2_nd.indices,
                c2f_scalar_2_nd.indptr,
            ),
            shape=c2f_scalar_2_nd.shape,
        )

        mappings = _CellToFaceMaps(
            c2f,
            c2f_compl,
            c2f_compl_scalar_2_nd,
            b2f_rob,
            b2f_rob_compl,
        )
        return mappings


    @staticmethod
    def _compute_distances(sd: pp.Grid, numbering: _Numbering,
        mu: np.ndarray, bnd_disp: pp.BoundaryConditionVectorial):
        """Compute grid-related distance measures, including the distance weighted
        shear modulus.

        This is also where the discretization coefficients related to Robin boundary
        conditions are computed.

        Parameters:
            sd: Grid
            numbering: Related to grid counting
            mu: The shear modulus
            bnd_disp: Boundary condition for the displacement variable

        Returns:
            Various distance measures needed in the discretization
            Discretization coefficients for Robin boundary conditions.

        """

        # Normal vectors in the face-wise ordering
        n_fi = sd.face_normals[:, numbering.fi]
        # Switch signs where relevant
        n_fi *= numbering.sgn

        # Get a vector from cell center to face center and project to the direction of
        # the face normal. Divide by the face area to get a unit vector in the normal
        # direction.
        fc_cc = (
            n_fi
            * (sd.face_centers[::, numbering.fi] - sd.cell_centers[::, numbering.ci])
            / sd.face_areas[numbering.fi]
        )
        # Get the length of the projected vector; take the absolute value to avoid
        # negative distances.
        dist_fc_cc = np.abs(np.sum(fc_cc, axis=0))

        # Construct mu_i / delta_k^i, and its nd version
        mu_by_dist_fc_cc = mu / dist_fc_cc
        mu_by_dist_fc_cc_nd = np.repeat(mu_by_dist_fc_cc, numbering.nd)

        # Extract the diagonal of the Robin weight. Non-diagonal elements are ignored
        # here and specifically ruled out (with error messages) elsewhere in the code.
        rob_weight = np.vstack(
            (bnd_disp.robin_weight[0, 0], bnd_disp.robin_weight[1, 1])
        )
        if numbering.nd == 3:
            rob_weight = np.vstack((rob_weight, bnd_disp.robin_weight[2, 2]))

        # Nd version of the faces with Robin boundary conditions.
        rob_boundary_faces_expanded = pp.fvutils.expand_indices_nd(
            np.arange(numbering.nf), numbering.nd
        ).reshape((numbering.nd, numbering.nf), order="F")[bnd_disp.is_rob]
        rob_weights_boundary_faces = rob_weight[bnd_disp.is_rob]

        # This is the face-wise sum of the expressions mu/delta, also accounting for
        # boundary conditions. For reference, the reciprocal of this field is also,
        # almost, the expression \delta_k^mu (used in the paper to describe the
        # discretization scheme), missing is a factor 1/2.
        mu_by_dist_fc_cc_bound = np.bincount(
            np.hstack((numbering.fi_expanded, rob_boundary_faces_expanded)),
            weights=np.hstack((mu_by_dist_fc_cc_nd, rob_weights_boundary_faces)),
        )

        # Create a diagonal matrix that can be used to scale face-to-cell maps to have
        # unit row sum (thus they become true averaging maps), both in the interior and
        # on faces with Robin boundary conditions.
        inv_mu_by_dist_array = sps.dia_array(
            (1 / mu_by_dist_fc_cc_bound, 0),
            shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd),
        )        

        # Finally, since we have obtained the Robin weights and the associated indices
        # of the faces, we might as well compute the discretization coefficients for
        # this boundary condition here.
        t_shear_rob = np.bincount(rob_boundary_faces_expanded,
                weights=1.0 / rob_weights_boundary_faces,
                minlength=numbering.nd * numbering.nf
                )

        dist = _Distances(dist_fc_cc, mu_by_dist_fc_cc, mu_by_dist_fc_cc_bound, inv_mu_by_dist_array, rob_weight)

        return dist, t_shear_rob

    @staticmethod
    def _vector_laplace_matrices(
        trm_nd: np.ndarray,
        bnd: pp.BoundaryConditionVectorial,
        numbering: _Numbering,
        b2f_rob_compl: np.ndarray,
    ) -> tuple[sps.spmatrix, sps.spmatrix]:
        # The linear stress due to cell center displacements is computed from the
        # harmonic average of the shear modulus, scaled by the face areas. The
        # transmissibility is the same for each dimension, implying that the
        # material is in a sense isotropic.

        # Get the types of boundary conditions.
        dir_faces = bnd.is_dir
        neu_faces = bnd.is_neu
        rob_faces = bnd.is_rob

        # Data structure for the discretization of the boundary conditions
        trm_bnd = np.zeros((numbering.nd, numbering.nf))
        # On Dirichlet faces, the coefficient of the boundary condition is the same
        # as weight of the nearby cell, but with the opposite sign (EITHER HERE OR
        # IN THE MATRIX DEFINITION). Since the coefficient is multiplied with the
        # sign on the internal dof, we need to multiply with the sign here as well.
        trm_bnd[dir_faces] = trm_nd[dir_faces]
        # EK Note to self regarding implementation: The call 'trm_nd[dir_faces]' and
        # similar, when made in an interpreter gives a 1d array, obtained raveling
        # the 2d array using C-ordering. However, the line below really uses
        # dir_faces to produce views of the 2d array, with trm_bnd being updated in
        # place. In other words, everything is fine (EK has verified this by
        # inspection).
        # trm_bnd[dir_faces] = unique_sgn_nd[dir_faces] * trm_nd[dir_faces]

        trm_bnd[dir_faces] = trm_nd[dir_faces]
        # On Neumann faces, the coefficient of the discretization itself is
        # zero, as the 'flux' through the boundary face is given by the boundary
        # condition.
        trm_nd[neu_faces] = 0
        # The boundary condition should simply be imposed. Put a -1 to counteract
        # the minus sign in the construction of the discretization matrix.
        # IMPLEMENTATION NOTE: Contrary to the tpfa implementation, the coefficients
        # of Neumann boundary conditions in tpsa are not multiplied with the sign of
        # the normal vector. This reflects that Neumann boundary values for
        # mechanics are set in terms of global coordinate directions, while for the
        # flow/scalar problem, the conditions are set with respect to the face-wise
        # normal vector.
        trm_bnd[neu_faces] = 1

        trm_bnd[rob_faces] = (
            b2f_rob_compl.reshape(
                (numbering.nd, numbering.nf), order="F"
            )[rob_faces]
            + trm_nd[rob_faces]
        )

        # Discretization of the vector Laplacian. Regarding indexing,
        # the ravel gives a vector-sized array in linear ordering, which is
        # shuffled to the (vector version of the) face-wise ordering. The sign is
        # set so that the stress is positive in tension.
        discr = -sps.coo_matrix(
            (
                trm_nd.ravel("F")[numbering.fi_expanded] * numbering.sgn_nd,
                (numbering.fi_expanded, numbering.ci_expanded),
            ),
            shape=(numbering.nf * numbering.nd, numbering.nc * numbering.nd),
        ).tocsr()

        # Boundary condition.
        bound_discr = sps.coo_matrix(
            (
                trm_bnd.ravel("F")[numbering.fi_expanded] * numbering.sgn_nd,
                (numbering.fi_expanded, numbering.fi_expanded),
            ),
            shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd),
        ).tocsr()
        return discr, bound_discr

    @staticmethod
    def _create_numbering(sd: pp.Grid):
        # Bookkeeping
        nf = sd.num_faces
        nc = sd.num_cells
        nd = sd.dim

        # The discretization matrices give generalized fluxes across faces in terms of
        # variables in the centers of adjacent cells. The discretization is based on a
        # two-point scheme, thus we need a mapping between cells and faces. The below
        # code generates a triplet of (face index, cell index, sign), where the sign
        # indicates the orientation of the face normal. Internal faces will occur twice,
        # with two different cell indices and opposite signs. Boundary faces will occur
        # only once. In the documentation below, we will refer to this ordering as the
        # **face-wise ordering**.
        fi, ci, sgn = sparse_array_to_row_col_data(sd.cell_faces)

        # Expand face and cell indices to construct nd discretization matrices
        fi_expanded = fvutils.expand_indices_nd(fi, nd)
        ci_expanded = fvutils.expand_indices_nd(ci, nd)
        # For vector quantities, we need fi repeated nd times, do this once and for all
        # here.
        sgn_nd = np.repeat(sgn, nd)

        return _Numbering(nc, nf, nd, fi, ci, fi_expanded, ci_expanded, sgn, sgn_nd)
