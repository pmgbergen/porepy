import numpy as np
import scipy.sparse as sps

from porepy.numerics.fv import fvutils
from porepy.grids.grid import Grid
from porepy.numerics.linalg.matrix_operations import sparse_array_to_row_col_data
from porepy.params.tensor import FourthOrderTensor
import porepy as pp
import warnings
from dataclasses import dataclass


@dataclass
class _Numbering:
    nc: int
    nf: int
    nd: int
    fi: np.ndarray
    ci: np.ndarray
    fi_expanded: np.ndarray
    ci_expanded: np.ndarray
    sgn: np.ndarray
    sgn_nd: np.ndarray

@dataclass
class _BoundaryFilters:
    """Helper class to store filters for applying various boundary conditions.

    The class stores only attributes needed in the implementation; it may well be that
    different choices in implementation would have needed different filters.
    """

    dir_pass_nd: sps.sparray
    """Filter that only lets through boundary faces with Dirichlet conditions."""

    dir_nopass: sps.sparray
    """Filter that removes Dirichlet conditions. TODO: WHY NOT ND"""

    dir_nopass_nd: sps.sparray
    """Filter that removes boundary faces with Dirichlet conditions. """

    neu_nopass_nd: sps.sparray
    """Filter that removes boundary faces with Neumann conditions. """

    neu_rob_pass_nd: sps.sparray
    """Filter that only lets through boundary faces with Neumann or Robin conditions."""    

    rob_pass_nd: sps.sparray
    """Filter that only lets through boundary faces with Robin conditions."""


class Tpsa:

    def __init__(self, keyword: str) -> None:

        self.keyword: str = keyword
        """Keyword used to identify the parameter dictionary."""

        self.stress_displacement_matrix_key: str = "stress"
        """Keyword used to identify the discretization matrix for the stress generated
        by the cell center displacements. Defaults to 'stress'.
        """
        self.stress_rotation_matrix_key: str = "stress_rotation"
        """Keyword used to identify the discretization matrix for the rotational stress
        generated by the cell center rotational stress. Defaults to 'stress_rotation'."""

        self.stress_total_pressure_matrix_key: str = "stress_total_pressure"
        """Keyword used to identify the discretization matrix for the solid mass
        conservation generated by the cell center solid pressure. Defaults to 
        'stress_total_pressure'."""

        self.rotation_displacement_matrix_key: str = "rotation_displacement"
        """Keyword used to identify the discretization matrix for the rotation 
        generated by the cell center displacements. Defaults to
        'rotation_displacement'."""

        self.rotation_diffusion_matrix_key: str = "rotation_diffusion"
        """Keyword used to identify the discretization matrix for the rotational
        diffusion generated by the cell center rotational stress. Defaults to
        'rotation_diffusion'."""

        self.mass_total_pressure_matrix_key = "solid_mass_total_pressure"
        """Keyword used to identify the discretization matrix for the solid mass
        conservation generated by the cell center solid pressure. Defaults to
        'solid_mass_total_pressure'."""

        self.mass_displacement_matrix_key = "solid_mass_displacement"
        """Keyword used to identify the discretization matrix for the solid mass
        conservation generated by the cell center displacements. Defaults to
        'solid_mass_displacement'."""

        # Boundary conditions
        self.bound_stress_matrix_key: str = "bound_stress"
        self.bound_mass_displacement_matrix_key = "bound_mass_displacement"
        self.bound_rotation_diffusion_matrix_key = "bound_rotation_diffusion"
        self.bound_rotation_displacement_matrix_key = "bound_rotation_displacement"

    def discretize(self, sd: Grid, data: dict) -> None:
        """Discretize linear elasticity equation using a two-point stress approximation
        (TPSA).

        Optionally, the discretization can include microrotations, in the form of a
        Cosserat material.

        The method constructs a set of discretization matrices for the balance of linear
        and angular momentum, as well as conservation of solid mass.

        We assume the following two sub-dictionaries to be present in the data
        dictionary:
            parameter_dictionary, storing all parameters.
                Stored in ``data[pp.PARAMETERS][self.keyword]``.
            matrix_dictionary, for storage of discretization matrices.
                Stored in ``data[pp.DISCRETIZATION_MATRICES][self.keyword]``

        parameter_dictionary contains the entries:
            - fourth_order_tensor: ``class:~porepy.params.tensor.FourthOrderTensor``
                Stiffness tensor defined cell-wise. Note that the discretization will
                act directly on the lame parameters ``FourthOrderTensor.mu``,
                ``FourthOrderTensor.lmbda``. That is, anisotropy encoded into the
                stiffness tensor will not be considered.

            - bc: ``class:~porepy.params.bc.BoundaryConditionVectorial``
                Boundary conditions

            - cosserat_parameter (optional): np.ndarray giving the Cosserat parameter,
                which can be considered a parameter for diffusion of microrotations.
                Should have length equal to the number of cells. If not provided, the
                Cosserat parameter is set to zero.

        TOOD: Complete documentation.

        matrix_dictionary will be updated with the following entries:
            - ``stress: sps.csc_matrix (sd.dim * sd.num_faces, sd.dim * sd.num_cells)``
                stress discretization, cell center contribution
            - ``bound_flux: sps.csc_matrix (sd.dim * sd.num_faces, sd.dim *
                sd.num_faces)`` stress discretization, face contribution
            - ``bound_displacement_cell: sps.csc_matrix (sd.dim * sd.num_faces,
                                                         sd.dim * sd.num_cells)``
                Operator for reconstructing the displacement trace. Cell center
                contribution.
            - ``bound_displacement_face: sps.csc_matrix (sd.dim * sd.num_faces,
                                                         sd.dim * sd.num_faces)``
                Operator for reconstructing the displacement trace. Face contribution.

        Parameters:
            sd: grid, or a subclass, with geometry fields computed.

            data: For entries, see above.

        """

        parameter_dictionary: dict[str, Any] = data[pp.PARAMETERS][self.keyword]
        matrix_dictionary: dict[str, sps.spmatrix] = data[pp.DISCRETIZATION_MATRICES][
            self.keyword
        ]

        numbering = self._create_numbering(sd)


        # Fetch parameters for the mechanical behavior
        stiffness: FourthOrderTensor = parameter_dictionary["fourth_order_tensor"]
        # The Cosserat parameter, if present. If this is None, the Cosserat parameter is
        # considered to be zero. In practice, we will set all Cosserat discretization
        # matrices to zero with no explicit computations
        cosserat_values: np.ndarray | None = parameter_dictionary.get(
            "cosserat_parameter", None
        )

        # Boundary condition object. Use the keyword 'bc' here to be compatible with the
        # implementation in mpsa.py, although symmetry with the boundary conditions for
        # rotation seems to call for a keyword like 'bc_disp'.
        bnd_disp: pp.BoundaryConditionVectorial = parameter_dictionary["bc"]

        # Boundary conditions for the rotation variable. This should only be used if
        # the Cosserat parameter is non-zero. Since the rotation variable is scalar if
        # nd == 2 and vector if nd == 3, the type of boundary condition depends on the
        # dimension.
        bnd_rot: pp.BoundaryCondition | pp.BoundaryConditionVectorial = (
            parameter_dictionary.get("bc_rot", None)
        )

        # Check that the type of boundary condition is consistent with the dimension.
        # This is a bit awkward, since it requires an if-else on the client side, but
        # the alternative is to always use a vectorial boundary condition and make a
        # hack to interpret the vectorial condition as a scalar one for 2d problems.
        # Note that, if the Cosserat parameter is zero, all of this is irrelevant.
        if numbering.nd == 2:
            if isinstance(bnd_rot, pp.BoundaryConditionVectorial):
                raise ValueError(
                    "Boundary conditions for rotations should be scalar if nd == 2"
                )
        elif numbering.nd == 3:
            if isinstance(bnd_rot, pp.BoundaryCondition):
                raise ValueError(
                    "Boundary conditions for rotations should be vectorial if nd == 3"
                )

        # Sanity check: If the Cosserat parameter is None, the boundary conditions for
        # the rotation variable are not relevant.
        if bnd_rot is not None and cosserat_values is None:
            # TODO: Should this be a warning, an error, or just ignored? The latter
            # allows for a more unified implementation of the pure elasticity and
            # Cosserat cases on the client side.
            warnings.warn(
                "Boundary conditions for rotations are only relevant if the Cosserat "
                "parameter is non-zero."
            )
        if bnd_rot is not None and np.sum(bnd_rot.is_rob) > 0:
            # The implementation should not be difficult, but has not been prioritized.
            raise NotImplementedError(
                "Robin conditions for rotations have not been implemented"
            )

       

        # Map the stiffness tensor to the face-wise ordering
        mu = stiffness.mu[numbering.ci]
        if cosserat_values is not None:
            cosserat_parameter = cosserat_values[numbering.ci]



        # Normal vectors in the face-wise ordering
        n_fi = sd.face_normals[:, numbering.fi]
        # Switch signs where relevant
        n_fi *= numbering.sgn

        # Get a vector from cell center to face center and project to the direction of
        # the face normal. Divide by the face area to get a unit vector in the normal
        # direction.
        fc_cc = (
            n_fi
            * (sd.face_centers[::, numbering.fi] - sd.cell_centers[::, numbering.ci])
            / sd.face_areas[numbering.fi]
        )
        # Get the length of the projected vector; take the absolute value to avoid
        # negative distances.
        dist_fc_cc = np.abs(np.sum(fc_cc, axis=0))

        shear_modulus_by_face_cell_distance = mu / dist_fc_cc

        # For Dirichlet conditions, set the averaging map to zero (as is the correct
        # discretization). TODO: Treat Neumann, and possibly Robin, conditions.
        is_dir_nd = bnd_disp.is_dir
        is_dir = is_dir_nd.ravel("F")
        is_neu_nd = bnd_disp.is_neu
        is_neu = is_neu_nd.ravel("F")

        # It is not clear to EK whether it is meaningful to consider a mixture of Robin
        # and other boundary conditions; it has not been accounted for.
        is_rob_nd = bnd_disp.is_rob
        has_rob = np.any(is_rob_nd, axis=0)
        if np.any(np.logical_not(is_rob_nd[:, has_rob])) > 0:
            raise NotImplementedError(
                "Have not implemnented a mixture of Robin and other boundary conditions"
            )
        is_rob = is_rob_nd.ravel("F")

        if (
            np.linalg.norm(
                np.array([bnd_disp.basis[:, :, i] - np.eye(numbering.nd) for i in range(numbering.nf)])
            )
            > 0
        ):
            raise NotImplementedError(
                "Have not implemented Robin conditions with a non-trivial basis"
            )

        # The Robin weight will be an nd x nd x nf array, with nd={2, 3}. For the
        # implementation to be valid in both cases, we use slices ([2:]) instead of
        # indexing ([2]), as the former will work also if the array has less than three
        # rows.
        if np.logical_or.reduce(
            (
                np.any(bnd_disp.robin_weight[0, 1:, :] > 0),
                np.any(bnd_disp.robin_weight[1, 0, :] > 0),
                np.any(bnd_disp.robin_weight[1, 2:, :] > 0),
                np.any(bnd_disp.robin_weight[2:, :2, :] > 0),
            )
        ):
            raise NotImplementedError(
                "Non-diagonal Robin weights have not been implemnted"
            )

        # Construct filters that are used to isolate faces with different types of
        # boundary conditions assigned. We do this only for the displacement variable;
        # for the rotation variable (in the case of a non-zero Cosserat parameter) we
        # only need to deal with Dirichlet and Neumann conditions on a diffusion problem
        # (Robin conditions have not been implemented, see above), which is relatively
        # easy and handled on the fly.
        filters = self._create_filters(bnd_disp, numbering, sd)

        robin_weight = np.vstack(
            (bnd_disp.robin_weight[0, 0], bnd_disp.robin_weight[1, 1])
        )
        if numbering.nd == 3:
            robin_weight = np.vstack((robin_weight, bnd_disp.robin_weight[2, 2]))

        dir_weight = np.zeros((numbering.nd, numbering.nf), dtype=float)
        dir_weight[is_dir_nd] = 1
        dir_weight[is_rob_nd] = robin_weight[is_rob_nd]

        # Construct an averaging operator from cell centers to faces. The averaging
        # weights are the cell-wise shear modulus, divided by the distance between the
        # face center and the cell center (projected to the face normal direction). The
        # scalar cell-to-face averaging is not used directly, but will form the basis
        # for its nd equivalent (which is needed in several places), and the (scalar)
        # complement which is used in a few places.

        weighted_distance_expanded = np.repeat(shear_modulus_by_face_cell_distance, numbering.nd)

        cell_to_face = sps.coo_array(
            ((shear_modulus_by_face_cell_distance, (numbering.fi, numbering.ci))), shape=(numbering.nf, numbering.nc)
        ).tocsr()
        cell_to_face_nd = sps.kron(cell_to_face, sps.eye(numbering.nd)).tocsr()

        rob_boundary_faces_expanded = pp.fvutils.expand_indices_nd(
            np.arange(numbering.nf), numbering.nd
        ).reshape((numbering.nd, numbering.nf), order="F")[is_rob_nd]
        rob_weights_boundary_faces = robin_weight[is_rob_nd]

        # This is the face-wise sum of the expressions mu/delta, also accounting for
        # boundary conditions. The reciprocal of this field is also, almost, the
        # expression \delta_k^mu, missing is a factor 1/2.
        distance_scaling = np.bincount(
            np.hstack((numbering.fi_expanded, rob_boundary_faces_expanded)),
            weights=np.hstack((weighted_distance_expanded, rob_weights_boundary_faces)),
        )

        distance_scaling_matrix = sps.dia_array(
            (1 / distance_scaling, 0), shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd)
        )

        cell_to_face_average_nd_new = (
            filters.dir_nopass_nd @ distance_scaling_matrix @ cell_to_face_nd
        )

        # This is a diagonal matrix. Do we need it, or only the diagonal data? TODO
        boundary_to_face_average_nd = (
            filters.rob_pass_nd
            @ distance_scaling_matrix
            @ sps.dia_array((dir_weight.ravel("F"), 0), shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd))
        )
        # For the complement, we only need the diagnoal data.
        boundary_to_face_average_complement_nd = (
            1 - boundary_to_face_average_nd.diagonal()
        )

        cell_to_face_average_nd = cell_to_face_average_nd_new

        # Construct an averaging operator from cell centers to faces. The averaging
        # weights are the cell-wise shear modulus, divided by the distance between the
        # face center and the cell center (projected to the face normal direction). The
        # scalar cell-to-face averaging is not used directly, but will form the basis
        # for its nd equivalent (which is needed in several places), and the (scalar)
        # complement which is used in a few places.

        cell_to_face_average = (
            sps.dia_matrix(
                (1 / np.bincount(numbering.fi, shear_modulus_by_face_cell_distance), 0),
                shape=(numbering.nf, numbering.nf),
            )
            @ sps.coo_matrix(
                ((shear_modulus_by_face_cell_distance, (numbering.fi, numbering.ci))), shape=(numbering.nf, numbering.nc)
            ).tocsr()
        )
        cell_to_face_weighted = sps.coo_matrix(
            ((shear_modulus_by_face_cell_distance, (numbering.fi, numbering.ci))), shape=(numbering.nf, numbering.nc)
        ).tocsr()
        cell_to_face_scalar_to_nd = sps.kron(
            cell_to_face_weighted, sps.csr_array(np.ones((numbering.nd, 1)))
        )

        cell_to_face_average_scalar_to_nd = (
            distance_scaling_matrix @ cell_to_face_scalar_to_nd
        )

        c2f_rows, *_ = sps.find(cell_to_face_average_scalar_to_nd)
        c2f_rows_is_dir = np.in1d(c2f_rows, np.where(is_dir))
        cell_to_face_average_scalar_to_nd.data[c2f_rows_is_dir] = 0

        cell_to_face_average_scalar_to_nd_complement = sps.csr_array(
            (
                1 - cell_to_face_average_scalar_to_nd.data,
                cell_to_face_average_scalar_to_nd.indices,
                cell_to_face_average_scalar_to_nd.indptr,
            ),
            shape=cell_to_face_average_scalar_to_nd.shape,
        )

        # Complement average map, defined as 1 - the average map. Note that this will
        # have a zero value for all boundary faces (since the average map has a
        # one-sided weight of 1 here). This is corrected below.
        cell_to_face_average_complement = sps.csr_matrix(
            (
                1 - cell_to_face_average.data,
                cell_to_face_average.indices,
                cell_to_face_average.indptr,
            ),
            shape=cell_to_face_average.shape,
        )
        # Find all rows in the complement average map that correspond to boundary faces,
        # and set the data to 1. Note the contrast with the nd version, where the data
        # of the averaging map is set to zero on Dirichlet faces (thus the complement
        # map has 0 on Neumann faces), and thus a kind of filtering on the boundary
        # condition is imposed by the averaging map. Since the boundary condition is
        # given for the (vector) displacement variable, it is not possible to do a
        # similar filtering applied to a scalar variable (total pressure and, in 2d,
        # rotation). Instead, we let the complement averaging map be non-zero on all
        # boundary faces, and do the filtering explicitly (again, the original scalar
        # averaging map is not used in the discretization).
        c2f_rows, *_ = sps.find(cell_to_face_average)
        c2f_rows_is_bound = np.in1d(c2f_rows, sd.get_all_boundary_faces())
        cell_to_face_average_complement.data[c2f_rows_is_bound] = 1

        # .. as is the nd version. The data is taken from cell_to_face_average_nd, thus
        # the correct treatment of boundary conditions is already included.
        cell_to_face_average_complement_nd = sps.csr_matrix(
            (
                1 - cell_to_face_average_nd.data,
                cell_to_face_average_nd.indices,
                cell_to_face_average_nd.indptr,
            ),
            shape=cell_to_face_average_nd.shape,
        )

        # Finally we are ready to construct the discretization matrices.



        # Harmonic average of the shear modulus divided by the distance between the face
        # center and the cell center.

        # Replace t_shear with nd version that also contains boundary weights. This is
        # similar, but not identical, to distance_scaling above.
        t_shear_nd = (
            2
            * np.repeat(sd.face_areas, numbering.nd)
            / np.bincount(
                np.hstack((numbering.fi_expanded, rob_boundary_faces_expanded)),
                weights=np.hstack(
                    (1.0 / weighted_distance_expanded, 1.0 / rob_weights_boundary_faces)
                ),
            )
        ).reshape((numbering.nd, numbering.nf), order="F")

        # Arithmetic average of the shear modulus.
        arithmetic_average_shear_modulus = np.bincount(
            numbering.fi, weights=shear_modulus_by_face_cell_distance, minlength=numbering.nf
        )

        # Discretize the stress-displacement relation:
        stress, bound_stress = self._vector_laplace_matrices(t_shear_nd, bnd_disp, numbering, boundary_to_face_average_complement_nd)

        # Face normals (note: in the usual ordering, not the face-wise ordering used in
        # the variable n_fi)
        n = sd.face_normals

        # The stress generated by the total pressure is computed using the complement of
        # the average map (this is just how the algebra works out), scaled with the
        # normal vector. The latter also gives the correct scaling with the face area.
        # The effect of boundary conditions are already included in
        # cell_to_face_average_complement.
        stress_total_pressure = (
            filters.neu_nopass_nd
            @ sps.csc_matrix(
                (
                    n[:numbering.nd].ravel("F"),
                    np.arange(0, numbering.nf * numbering.nd),
                    np.arange(0, numbering.nf * numbering.nd + 1, numbering.nd),
                ),
                shape=(numbering.nd * numbering.nf, numbering.nf),
            )
            @ cell_to_face_average_complement
        )
        stress_total_pressure = (
            filters.neu_nopass_nd
            @ sps.dia_matrix((n[:numbering.nd].ravel("F"), 0),
            shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd))
            @ cell_to_face_average_scalar_to_nd_complement
        )

        # The solid mass conservation equation is discretized by taking the average
        # displacement over the faces (not using the complement, again, this is just how
        # it is), and scaling with the normal vector. To that end, construct a sparse
        # matrix that has one normal vector per row.
        normal_vector_nd = sps.csr_matrix(
            (n[:numbering.nd].ravel("F"), np.arange(numbering.nf * numbering.nd),
             np.arange(0, numbering.nf * numbering.nd + 1, numbering.nd)),
            shape=(numbering.nf, numbering.nf * numbering.nd),
        )
        # The impact on the solid mass flux from the displacement is then the matrix of
        # normal vectors multiplied with the average displacement over the faces.
        # This matrix will be empty on Dirichlet faces due to the filtering in
        # cell_to_face_average_nd.
        mass_displacement = normal_vector_nd @ cell_to_face_average_nd

        # While there is no spatial operator that that relates the total pressure to the
        # conservation of solid mass in the continuous equation, the TPSA discretization
        # naturally leads to a stabilization term, as computed below. This acts on
        # differences in the total pressure, and is scaled with the face area. The
        # setting of the boundary condition is a bit tricky, since the solid pressure is
        # a derived boundary quantity for which there is no boundary condition set. 
        mass_total_pressure = -filters.dir_nopass @ (
            sps.dia_matrix(
                (sd.face_areas / (2 * arithmetic_average_shear_modulus), 0),
                shape=(numbering.nf, numbering.nf),
            )
            @ sd.cell_faces
        )

        # Take the harmonic average of the Cosserat parameter.
        # TODO: For zero Cosserat parameters, this involves a division by zero. This
        # gives no actual problem, but filtering would have been more elegant.
        if cosserat_values is not None:
            t_cosserat = sd.face_areas / np.bincount(numbering.fi,
             weights=1 / (cosserat_parameter / dist_fc_cc), minlength=numbering.nf)

        # The relations involving rotations are more cumbersome, as a rotation in 2d has
        # a single degree of freedom, while a 3d rotation has 3 degrees of freedom. This
        # necessitates (or at least is most easily realized) by a split into a 2d and a
        # 3d code. In the below if-else, we construct the matrices Rn_hat and Rn_bar
        # (see the TPSA paper for details) and use this to discretize stress generated by
        # cell center rotations. Moreover, we discretize the diffusion of rotations
        # generated by cell center displacements, which is different in 2d and 3d.
        if numbering.nd == 3:
            # In this case, \hat{R}_k^n = \bar{R}_k^n is the 3x3 projection matrix as
            # given in the TPSA paper reads
            #
            #    R^n = [[0, -n2, n0], [n2, 0, -n0], [-n1, n0, 0]]
            #
            # However, for efficient implementation we will use the function, which
            # in turns out, requires a transpose in the inner array. Quite likely this
            # could have been achieved by a different order of raveling (see below), but
            # this also worked.
            #
            # For reference, it is possible to use the following code to construct R_hat
            #
            # Rn_data = np.array([[z, -n[2], n[1]], [n[2], z, -n[0]], [-n[1], n[0], z]])
            # Rn_hat = sps.block_diag([Rn_data[:, :, i] for i in range(Rn.shape[2])])
            #
            # but this is much slower due to the block_diag construction.

            z = np.zeros(numbering.nf)
            Rn_data = np.array([[z, n[2], -n[1]], [-n[2], z, n[0]], [n[1], -n[0], z]])

            Rn_hat = pp.matrix_operations.csr_matrix_from_blocks(
                Rn_data.ravel("F"), numbering.nd, numbering.nf
            )
            Rn_bar = Rn_hat

            # Discretization of the stress generated by cell center rotations.
            stress_rotation = (
                -filters.neu_nopass_nd @ Rn_hat @ cell_to_face_average_complement_nd
            )

            if cosserat_values is not None:
                # Use the discretization of Laplace's problem. The transmissibility will
                # be the same in all directions.
                rotation_diffusion, bound_rotation_diffusion = self._vector_laplace_matrices(
                    np.tile(t_cosserat, (numbering.nd, 1)), bnd_rot, numbering, boundary_to_face_average_complement_nd
                )

            else:
                # If the Cosserat parameter is zero, the diffusion operator is zero.
                rotation_diffusion = sps.csr_matrix((numbering.nf * numbering.nd, numbering.nc * numbering.nd))
                bound_rotation_diffusion = sps.csr_matrix((numbering.nf * numbering.nd, numbering.nf * numbering.nd))

        elif numbering.nd == 2:
            # In this case, \hat{R}_k^n and \bar{R}_k^n differ, and read, respectively
            #   \hat{R}_k^n = [[n2], [-n1]],
            #   \bar{R}_k^n = [-n2, n1].

            # Vector of normal vectors
            normal_vector_data = np.array([n[1], -n[0]])

            # Mapping from average displacements over faces to rotations on the face.
            # minus sign from definition of Rn_bar
            Rn_bar = sps.csr_matrix(
                (
                    -normal_vector_data.ravel("F"),
                    np.arange(numbering.nf * numbering.nd),
                    np.arange(0, numbering.nd * numbering.nf + 1, numbering.nd),
                ),
                shape=(numbering.nf, numbering.nf * numbering.nd),
            )
            # Mapping from average rotations over faces to stresses
            Rn_hat = sps.dia_matrix(
                (normal_vector_data.ravel("F"), 0), shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd)
            )
            # # Discretization of the stress generated by cell center rotations.
            stress_rotation = (
                -filters.neu_nopass_nd
                @ Rn_hat
                @ cell_to_face_average_scalar_to_nd_complement
            )

            # Diffusion operator on the rotation if relevant.
            if cosserat_values is not None:
                # In 2d, the rotation is a scalar variable and we can treat this by
                # essentially, tpfa.

                t_cosserat_bnd = np.zeros(numbering.nf)
                t_cosserat_bnd[bnd_rot.is_dir] = t_cosserat[bnd_rot.is_dir]
                # The boundary condition should simply be imposed. Put a -1 to
                # counteract the minus sign in the construction of the discretization
                # matrix.
                t_cosserat_bnd[bnd_rot.is_neu] = 1
                t_cosserat[bnd_rot.is_neu] = 0

                # TODO: Why minus sign here, but not in tpfa? Darcy vs Hook.
                rotation_diffusion = -sps.coo_matrix(
                    (t_cosserat[numbering.fi] * numbering.sgn, (numbering.fi, numbering.ci)),
                    shape=(numbering.nf, numbering.nc),
                ).tocsr()

                bound_rotation_diffusion = sps.coo_matrix(
                    (t_cosserat_bnd[numbering.fi] * numbering.sgn, (numbering.fi, numbering.fi)), shape=(numbering.nf, numbering.nf)
                ).tocsr()

            else:
                rotation_diffusion = sps.csr_matrix((numbering.nf, numbering.nc))
                bound_rotation_diffusion = sps.csr_matrix((numbering.nf, numbering.nf))

        # The rotation generated by the cell center displacements is computed from the
        # average displacement over the faces, multiplied by Rn_bar. This construction
        # is common for both 2d and 3d.
        rotation_displacement = -Rn_bar @ cell_to_face_average_nd

        # The boundary condition for the rotation equation's dependency on the
        # cell center displacements.

        # This is the expression \delta_k^mu.
        mu_face = sps.dia_matrix(
            (1 / (2 * distance_scaling), 0),
            shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd),
        )
        # TODO: Implement Dirichlet conditions
        bound_rotation_displacement = Rn_bar @ (
            filters.neu_rob_pass_nd @ mu_face
            - filters.dir_pass_nd
            - boundary_to_face_average_nd
        )

        # Boundary condition. There should be no contribution from Dofs which are
        # assigned a Dirichlet condition, so filter out these variables (this is likely
        # not fully consistent for domains with boundaries not aligned with the
        # coordinate axes, and with rolling boundary conditions, but EK does not know
        # what to do there).

        bound_mass_displacement = normal_vector_nd @ (
            filters.neu_rob_pass_nd @ mu_face + filters.dir_pass_nd
        )
        ## Store the computed fields

        # Discretization matrices
        matrix_dictionary[self.stress_displacement_matrix_key] = stress
        matrix_dictionary[self.stress_rotation_matrix_key] = stress_rotation
        matrix_dictionary[self.stress_total_pressure_matrix_key] = stress_total_pressure
        matrix_dictionary[self.rotation_displacement_matrix_key] = rotation_displacement
        matrix_dictionary[self.rotation_diffusion_matrix_key] = rotation_diffusion
        matrix_dictionary[self.mass_total_pressure_matrix_key] = mass_total_pressure
        matrix_dictionary[self.mass_displacement_matrix_key] = mass_displacement

        # Boundary conditions (NB: Only Dirichlet implemented for now)
        matrix_dictionary[self.bound_stress_matrix_key] = bound_stress
        matrix_dictionary[self.bound_mass_displacement_matrix_key] = (
            bound_mass_displacement
        )
        matrix_dictionary[self.bound_rotation_diffusion_matrix_key] = (
            bound_rotation_diffusion
        )
        matrix_dictionary[self.bound_rotation_displacement_matrix_key] = (
            bound_rotation_displacement
        )

    @staticmethod
    def _create_filters(bnd_disp: pp.BoundaryConditionVectorial,
        numbering: _Numbering, sd: pp.Grid) -> _BoundaryFilters:

        is_dir = bnd_disp.is_dir.ravel("F")
        is_neu = bnd_disp.is_neu.ravel("F")
        is_rob = bnd_disp.is_rob.ravel("F")
        is_internal = np.logical_not(np.logical_or.reduce((is_dir, is_neu, is_rob)))

        dir_nd = sps.dia_matrix(
            (is_dir.astype(int), 0), shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd)
        )

        dir_nopass_nd = sps.dia_matrix(
            (np.logical_or.reduce((is_neu, is_rob, is_internal)).astype(int), 0),
            shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd),
        )

        neu_nopass_nd = sps.dia_matrix(
            (np.logical_or.reduce((is_dir, is_rob, is_internal)).astype(int), 0),
            shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd),
        )

        neu_rob_pass_nd = sps.dia_matrix(
            (np.logical_or(is_neu, is_rob).astype(int), 0), shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd)
        )
        rob_nd = sps.dia_array(
            (is_rob.astype(int), 0), shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd)
        )        

        # We also need to deal with BCs on the numerical diffusion term for the solid
        # pressure. It is not fully clear what to do with this term on the boundary:
        # There is no boundary condition for the total pressure, this is in a sense
        # inherited from the displacement. The discretization scheme must however be
        # adjusted, so that it is zero on Dirichlet faces. The question is, what to do
        # with rolling boundary conditions, where a mixture of Dirichlet and Neumann
        # conditions are applied? For now, we pick the condition in the direction which
        # is closest to the normal vector of the face. While this should work nicely for
        # domains where the grid is aligned with the coordinate axis, it is more of a
        # question mark how this will work for rotated domains.
        max_ind = np.argmax(np.abs(sd.face_normals), axis=0)
        dir_scalar = bnd_disp.is_dir[max_ind, np.arange(numbering.nf)]
        dir_nopass = sps.dia_matrix(
            (np.logical_not(dir_scalar).astype(int), 0), shape=(numbering.nf, numbering.nf)
        )        

        return _BoundaryFilters(dir_nd, dir_nopass, dir_nopass_nd, neu_nopass_nd, neu_rob_pass_nd, rob_nd)




    @staticmethod
    def _vector_laplace_matrices(
        trm_nd: np.ndarray, bnd: pp.BoundaryConditionVectorial, numbering: _Numbering,
        boundary_to_face_average_complement_nd: np.ndarray
    ) -> tuple[sps.spmatrix, sps.spmatrix]:
        # The linear stress due to cell center displacements is computed from the
        # harmonic average of the shear modulus, scaled by the face areas. The
        # transmissibility is the same for each dimension, implying that the
        # material is in a sense isotropic.

        # Get the types of boundary conditions.
        dir_faces = bnd.is_dir
        neu_faces = bnd.is_neu
        rob_faces = bnd.is_rob

        # Data structure for the discretization of the boundary conditions
        trm_bnd = np.zeros((numbering.nd, numbering.nf))
        # On Dirichlet faces, the coefficient of the boundary condition is the same
        # as weight of the nearby cell, but with the opposite sign (EITHER HERE OR
        # IN THE MATRIX DEFINITION). Since the coefficient is multiplied with the
        # sign on the internal dof, we need to multiply with the sign here as well.
        trm_bnd[dir_faces] = trm_nd[dir_faces]
        # EK Note to self regarding implementation: The call 'trm_nd[dir_faces]' and
        # similar, when made in an interpreter gives a 1d array, obtained raveling
        # the 2d array using C-ordering. However, the line below really uses
        # dir_faces to produce views of the 2d array, with trm_bnd being updated in
        # place. In other words, everything is fine (EK has verified this by
        # inspection).
        # trm_bnd[dir_faces] = unique_sgn_nd[dir_faces] * trm_nd[dir_faces]

        trm_bnd[dir_faces] = trm_nd[dir_faces]
        # On Neumann faces, the coefficient of the discretization itself is
        # zero, as the 'flux' through the boundary face is given by the boundary
        # condition.
        trm_nd[neu_faces] = 0
        # The boundary condition should simply be imposed. Put a -1 to counteract
        # the minus sign in the construction of the discretization matrix.
        # IMPLEMENTATION NOTE: Contrary to the tpfa implementation, the coefficients
        # of Neumann boundary conditions in tpsa are not multiplied with the sign of
        # the normal vector. This reflects that Neumann boundary values for
        # mechanics are set in terms of global coordinate directions, while for the
        # flow/scalar problem, the conditions are set with respect to the face-wise
        # normal vector.
        trm_bnd[neu_faces] = 1

        trm_bnd[rob_faces] = (
            boundary_to_face_average_complement_nd.reshape((numbering.nd, numbering.nf), order="F")[
                rob_faces
            ]
            + trm_nd[rob_faces]
        )

        # Discretization of the vector Laplacian. Regarding indexing,
        # the ravel gives a vector-sized array in linear ordering, which is
        # shuffled to the (vector version of the) face-wise ordering. The sign is
        # set so that the stress is positive in tension.
        discr = -sps.coo_matrix(
            (
                trm_nd.ravel("F")[numbering.fi_expanded] * numbering.sgn_nd,
                (numbering.fi_expanded, numbering.ci_expanded),
            ),
            shape=(numbering.nf * numbering.nd, numbering.nc * numbering.nd),
        ).tocsr()

        # Boundary condition.
        bound_discr = sps.coo_matrix(
            (
                trm_bnd.ravel("F")[numbering.fi_expanded] * numbering.sgn_nd,
                (numbering.fi_expanded, numbering.fi_expanded),
            ),
            shape=(numbering.nf * numbering.nd, numbering.nf * numbering.nd),
        ).tocsr()
        return discr, bound_discr

    @staticmethod
    def _create_numbering(sd: pp.Grid):
            # Bookkeeping
        nf = sd.num_faces
        nc = sd.num_cells
        nd = sd.dim

        # The discretization matrices give generalized fluxes across faces in terms of
        # variables in the centers of adjacent cells. The discretization is based on a
        # two-point scheme, thus we need a mapping between cells and faces. The below
        # code generates a triplet of (face index, cell index, sign), where the sign
        # indicates the orientation of the face normal. Internal faces will occur twice,
        # with two different cell indices and opposite signs. Boundary faces will occur
        # only once. In the documentation below, we will refer to this ordering as the
        # **face-wise ordering**.
        fi, ci, sgn = sparse_array_to_row_col_data(sd.cell_faces)

        # Expand face and cell indices to construct nd discretization matrices
        fi_expanded = fvutils.expand_indices_nd(fi, nd)
        ci_expanded = fvutils.expand_indices_nd(ci, nd) 
        # For vector quantities, we need fi repeated nd times, do this once and for all
        # here.
        sgn_nd = np.repeat(sgn, nd)

        return _Numbering(nc, nf, nd, fi, ci, fi_expanded, ci_expanded, sgn, sgn_nd)


