import numpy as np
import scipy.sparse as sps

from porepy.numerics.fv import fvutils
from porepy.grids.grid import Grid
from porepy.numerics.linalg.matrix_operations import sparse_array_to_row_col_data
from porepy.params.tensor import FourthOrderTensor
import porepy as pp


class Tpsa:

    def __init__(self, keyword: str) -> None:

        self.keyword: str = keyword
        """Keyword used to identify the parameter dictionary."""

        self.stress_displacement_matrix_key: str = "stress"
        """Keyword used to identify the discretization matrix for the stress generated
        by the cell center displacements. Defaults to 'stress'.
        """
        self.stress_rotation_matrix_key: str = "stress_rotation"
        """Keyword used to identify the discretization matrix for the rotational stress
        generated by the cell center rotational stress. Defaults to 'stress_rotation'."""

        self.stress_total_pressure_matrix_key: str = "total_pressure_stress"
        """Keyword used to identify the discretization matrix for the solid mass
        conservation generated by the cell center solid pressure. Defaults to 
        'total_pressure_stress'."""

        self.rotation_displacement_matrix_key: str = "rotation_displacement"
        """Keyword used to identify the discretization matrix for the rotation 
        generated by the cell center displacements. Defaults to
        'rotation_displacement'."""

        self.rotation_diffusion_matrix_key: str = "rotation_diffusion"
        """Keyword used to identify the discretization matrix for the rotational
        diffusion generated by the cell center rotational stress. Defaults to
        'rotation_diffusion'."""

        self.mass_total_pressure_matrix_key = "solid_mass_total_pressure"
        """Keyword used to identify the discretization matrix for the solid mass
        conservation generated by the cell center solid pressure. Defaults to
        'solid_mass_total_pressure'."""

        self.mass_displacement_matrix_key = "solid_mass_displacement"
        """Keyword used to identify the discretization matrix for the solid mass
        conservation generated by the cell center displacements. Defaults to
        'solid_mass_displacement'."""

        # Boundary conditions
        self.bound_stress_matrix_key: str = "bound_stress"
        self.bound_mass_displacement_matrix_key = "bound_mass_displacement"
        self.bound_rotation_diffusion_matrix_key = "bound_rotation_diffusion"
        self.bound_rotation_displacement_matrix_key = "bound_rotation_displacement"

    def discretize(self, sd: Grid, data: dict) -> None:
        """Discretize linear elasticity equation using a two-point stress approximation
        (TPSA).

        Optionally, the discretization can include microrotations, in the form of a
        Cosserat material.

        The method constructs a set of discretization matrices for the balance of linear
        and angular momentum, as well as conservation of solid mass.

        We assume the following two sub-dictionaries to be present in the data
        dictionary:
            parameter_dictionary, storing all parameters.
                Stored in ``data[pp.PARAMETERS][self.keyword]``.
            matrix_dictionary, for storage of discretization matrices.
                Stored in ``data[pp.DISCRETIZATION_MATRICES][self.keyword]``

        parameter_dictionary contains the entries:
            - fourth_order_tensor: ``class:~porepy.params.tensor.FourthOrderTensor``
                Stiffness tensor defined cell-wise. Note that the discretization will
                act directly on the lame parameters ``FourthOrderTensor.mu``,
                ``FourthOrderTensor.lmbda``. That is, anisotropy encoded into the
                stiffness tensor will not be considered.

            - bc: ``class:~porepy.params.bc.BoundaryConditionVectorial``
                Boundary conditions

            - cosserat_parameter (optional): np.ndarray giving the Cosserat parameter,
                which can be considered a parameter for diffusion of microrotations.
                Should have length equal to the number of cells. If not provided, the
                Cosserat parameter is set to zero.

        TOOD: Complete documentation.

        matrix_dictionary will be updated with the following entries:
            - ``stress: sps.csc_matrix (sd.dim * sd.num_faces, sd.dim * sd.num_cells)``
                stress discretization, cell center contribution
            - ``bound_flux: sps.csc_matrix (sd.dim * sd.num_faces, sd.dim *
                sd.num_faces)`` stress discretization, face contribution
            - ``bound_displacement_cell: sps.csc_matrix (sd.dim * sd.num_faces,
                                                         sd.dim * sd.num_cells)``
                Operator for reconstructing the displacement trace. Cell center
                contribution.
            - ``bound_displacement_face: sps.csc_matrix (sd.dim * sd.num_faces,
                                                         sd.dim * sd.num_faces)``
                Operator for reconstructing the displacement trace. Face contribution.

        Parameters:
            sd: grid, or a subclass, with geometry fields computed.

            data: For entries, see above.

        """

        parameter_dictionary: dict[str, Any] = data[pp.PARAMETERS][self.keyword]
        matrix_dictionary: dict[str, sps.spmatrix] = data[pp.DISCRETIZATION_MATRICES][
            self.keyword
        ]

        # Bookkeeping
        nf = sd.num_faces
        nc = sd.num_cells
        nd = sd.dim

        # Fetch parameters for the mechanical behavior
        stiffness: FourthOrderTensor = parameter_dictionary["fourth_order_tensor"]
        # The Cosserat parameter, if present, else set to zero
        cosserat_values = parameter_dictionary.get("cosserat_parameter", None)
        if cosserat_values is None:
            cosserat_values = np.zeros(nc)

        # Boundary condition object
        bnd: pp.BoundaryConditionVectorial = parameter_dictionary["bc"]

        # The discretization matrices give generalized fluxes across faces in terms of
        # variables in the centers of adjacent cells. The discretization is based on a
        # two-point scheme, thus we need a mapping between cells and faces. The below
        # code generates a triplet of (face index, cell index, sign), where the sign
        # indicates the orientation of the face normal. Internal faces will occur twice,
        # with two different cell indices and opposite signs. Boundary faces will occur
        # only once. In the documentation below, we will refer to this ordering as the
        # **face-wise ordering**.
        fi, ci, sgn = sparse_array_to_row_col_data(sd.cell_faces)

        # Map the stiffness tensor to the face-wise ordering
        mu = stiffness.mu[ci]
        lmbda = stiffness.lmbda[ci]
        cosserat_parameter = cosserat_values[ci]

        # For vector quantities, we need fi repeated nd times, do this once and for all
        # here. Also repeat the face areas and signs
        fi_nd = np.repeat(fi, nd)
        face_areas_fi_nd = sd.face_areas[fi_nd]
        sgn_nd = np.repeat(sgn, nd)

        # Expand face and cell indices to construct nd discretization matrices
        fi_expanded = fvutils.expand_indices_nd(fi, nd)
        ci_expanded = fvutils.expand_indices_nd(ci, nd)

        # Data structures for boundary conditions. Only homogeneous Dirichlet conditions
        # treated so far.
        dir_displacement = bnd.is_dir.ravel("f")
        dir_scalar = bnd.is_dir[0]

        # Normal vectors in the face-wise ordering
        n_fi = sd.face_normals[:, fi]
        # Switch signs where relevant
        n_fi *= sgn

        # Get a vector from cell center to face center and project to the direction of
        # the face normal. Divide by the face area to get a unit vector in the normal
        # direction.
        fc_cc = (
            n_fi
            * (sd.face_centers[::, fi] - sd.cell_centers[::, ci])
            / sd.face_areas[fi]
        )
        # Get the length of the projected vector; take the absolute value to avoid
        # negative distances.
        dist_fc_cc = np.abs(np.sum(fc_cc, axis=0))

        # For each face, the summed length of the vectors from the face center to the
        # cell centers on either side of the face. For boundary faces, there is only one
        # contribution.
        dist_cc_cc = np.bincount(fi, weights=dist_fc_cc, minlength=nc)

        # Helper function to compute the harmonic mean of a field over faces.
        def facewise_harmonic_mean(field: np.ndarray) -> np.ndarray:
            return 1 / np.bincount(fi, weights=1 / field, minlength=nf)

        # Harmonic average of the shear modulus divided by the distance between the face
        # center and the cell center.
        shear_modulus_by_face_cell_distance = mu / dist_fc_cc
        t_shear = facewise_harmonic_mean(shear_modulus_by_face_cell_distance)

        # Arithmetic average of the shear modulus.
        arithmetic_average_shear_modulus = np.bincount(
            fi, weights=shear_modulus_by_face_cell_distance, minlength=nf
        )

        # Construct an averaging operator from cell centers to faces. The averaging
        # weights are the cell-wise shear modulus, divided by the distance between the
        # face center and the cell center (projected to the face normal direction).
        cell_to_face_average = (
            sps.dia_matrix(
                (1 / np.bincount(fi, shear_modulus_by_face_cell_distance), 0),
                shape=(nf, nf),
            )
            @ sps.coo_matrix(
                ((shear_modulus_by_face_cell_distance, (fi, ci))), shape=(nf, nc)
            ).tocsr()
        )

        # For Dirichlet conditions, set the averaging map to zero (as is the correct
        # discretization). TODO: Treat Neumann, and possibly Robin, conditions.
        dir_indices = np.where(dir_scalar)[0]
        r, _, _ = sps.find(cell_to_face_average)
        hit = np.in1d(r, dir_indices)
        cell_to_face_average.data[hit] = 0

        # For vector quantities we need a nd version of the averaging operator
        cell_to_face_average_nd = sps.kron(cell_to_face_average, sps.eye(nd)).tocsr()

        # Complement average map, defined as 1 - the average map, are also needed.
        cell_to_face_average_complement = sps.csr_matrix(
            (
                1 - cell_to_face_average.data,
                cell_to_face_average.indices,
                cell_to_face_average.indptr,
            ),
            shape=cell_to_face_average.shape,
        )
        # .. as is the nd version
        cell_to_face_average_complement_nd = sps.kron(
            cell_to_face_average_complement, sps.eye(nd)
        ).tocsr()

        dir_filter = sps.dia_matrix((dir_scalar.astype(int), 0), shape=(nf, nf))
        dir_filter_nd = sps.dia_matrix(
            (np.repeat(dir_scalar.astype(int), nd), 0), shape=(nf * nd, nf * nd)
        )
        dir_nopass_filter = sps.dia_matrix(
            (1 - dir_scalar.astype(int), 0), shape=(nf, nf)
        )
        dir_nopass_filter_nd = sps.dia_matrix(
            (1 - np.repeat(dir_scalar.astype(int), nd), 0), shape=(nf * nd, nf * nd)
        )

        # Finally we are ready to construct the discretization matrices.

        # The linear stress due to cell center displacements is computed from the
        # harmonic average of the shear modulus, scaled by the face areas. The
        # transmissibility is the same for each dimension, implying that the material is
        # in a sense isotropic.
        stress = -(
            sps.coo_matrix(
                (
                    2 * face_areas_fi_nd * t_shear[fi_nd] * sgn_nd,
                    (fi_expanded, ci_expanded),
                ),
                shape=(nf * nd, nc * nd),
            ).tocsr()
        )

        bound_stress = (
            -dir_filter_nd
            @ sps.coo_matrix(
                (
                    2 * face_areas_fi_nd * t_shear[fi_nd] * sgn_nd,
                    (fi_expanded, fi_expanded),
                ),
                shape=(nf * nd, nf * nd),
            ).tocsr()
        )

        # Face normals (note: in the usual ordering, not the face-wise ordering used in
        # the variable n_fi)
        n = sd.face_normals

        # The stress generated by the total pressure is computed using the complement
        # of the average map (this is just how the algebra works out), scaled with the
        # normal vector. The latter also gives the correct scaling with the face area.
        stress_total_pressure = (
            sps.csc_matrix(
                (
                    n[:nd].ravel("F"),
                    np.arange(0, nd * nf),
                    np.arange(0, nd * nf + 1, nd),
                ),
                shape=(nd * nf, nf),
            )
            @ cell_to_face_average_complement
        )

        # The solid mass conservation equation is discretized by taking the average
        # displacement over the faces (not using the complement, again, this is just how
        # it is), and scaling with the normal vector. To that end, construct a sparse
        # matrix that has one normal vector per row.
        normal_vector_nd = sps.csr_matrix(
            (n[:nd].ravel("F"), np.arange(nd * nf), np.arange(0, nd * nf + 1, nd)),
            shape=(nf, nd * nf),
        )
        # The impact on the solid mass flux from the displacement is then the matrix of
        # normal vectors multiplied with the average displacement over the faces.
        mass_displacement = normal_vector_nd @ cell_to_face_average_nd
        bound_mass_displacement = dir_filter @ normal_vector_nd

        # While there is no spatial operator that that relates the total pressure to the
        # conservation of solid mass in the continuous equation, the TPSA discretization
        # naturally leads to a stabilization term, as computed below. This acts on
        # differences in the total pressure, and is scaled with the face area.
        mass_total_pressure = -dir_nopass_filter @ (
            sps.dia_matrix(
                (sd.face_areas / (2 * arithmetic_average_shear_modulus), 0),
                shape=(nf, nf),
            )
            @ sd.cell_faces
        )

        # Take the harmonic average of the Cosserat parameter.
        # TODO: For zero Cosserat parameters, this involves a division by zero. This
        # gives no actual problem, but filtering would have been more elegant.
        t_cosserat = facewise_harmonic_mean(cosserat_parameter / dist_fc_cc)

        # The relations involving rotations are more cumbersome, as a rotation in 2d has
        # a single degree of freedom, while a 3d rotation has 3 degrees of freedom. This
        # necessitates (or at least is most easily realized) by a split into a 2d and a
        # 3d code. In the below if-else, we construct the matrices Rn_hat and Rn_bar
        # (see the TPSA paper for details) and use this to discretize stress generated by
        # cell center rotations. Moreover, we discretize the diffusion of rotations
        # generated by cell center displacements, which is different in 2d and 3d.
        if nd == 3:
            # In this case, \hat{R}_k^n = \bar{R}_k^n is the 3x3 projection matrix as
            # given in the TPSA paper reads
            #
            #    R^n = [[0, -n2, n0], [n2, 0, -n0], [-n1, n0, 0]]
            #
            # However, for efficient implementation we will use the function, which
            # in turns out, requires a transpose in the inner array. Quite likely this
            # could have been achieved by a different order of raveling (see below), but
            # this also worked.
            #
            # For reference, it is possible to use the following code to construct R_hat
            #
            # Rn_data = np.array([[z, -n[2], n[1]], [n[2], z, -n[0]], [-n[1], n[0], z]])
            # Rn_hat = sps.block_diag([Rn_data[:, :, i] for i in range(Rn.shape[2])])
            #
            # but this is much slower due to the block_diag construction.

            z = np.zeros(nf)
            Rn_data = np.array([[z, n[2], -n[1]], [-n[2], z, n[0]], [n[1], -n[0], z]])

            Rn_hat = pp.matrix_operations.csr_matrix_from_blocks(
                Rn_data.ravel("F"), nd, nf
            )
            Rn_bar = Rn_hat

            # Discretization of the stress generated by cell center rotations.
            stress_rotation = -Rn_hat @ cell_to_face_average_complement_nd
            # The diffusion operator for the rotation expands the (scalar) Cosserat
            # transmissibility to a vector by face-wise ordering (this implies that the
            # diffusion is isotropic).
            rotation_diffusion = -(
                sps.coo_matrix(
                    (
                        face_areas_fi_nd * t_cosserat[fi_nd] * sgn_nd,
                        (fi_expanded, ci_expanded),
                    ),
                    shape=(nf * nd, nc * nd),
                ).tocsr()
            )
            bound_rotation_diffusion = -dir_filter_nd @ (
                sps.coo_matrix(
                    (
                        face_areas_fi_nd * t_cosserat[fi_nd] * sgn_nd,
                        (fi_expanded, fi_expanded),
                    ),
                    shape=(nf * nd, nf * nd),
                ).tocsr()
            )

        elif nd == 2:
            # In this case, \hat{R}_k^n and \bar{R}_k^n differ, and read, respectively
            #   \hat{R}_k^n = [[n2], [-n1]],
            #   \bar{R}_k^n = [-n2, n1].

            # Vector of normal vectors
            normal_vector_data = np.array([n[1], -n[0]])

            # Mapping from average displacements over faces to rotations on the face.
            # minus sign from definition of Rn_bar
            Rn_bar = sps.csr_matrix(
                (
                    -normal_vector_data.ravel("F"),
                    np.arange(nd * nf),
                    np.arange(0, nd * nf + 1, nd),
                ),
                shape=(nf, nd * nf),
            )
            # Mapping from average rotations over faces to stresses
            Rn_hat = sps.csc_matrix(
                (
                    normal_vector_data.ravel("F"),
                    np.arange(nf * nd),
                    np.arange(0, nd * nf + 1, nd),
                ),
                shape=(nd * nf, nf),
            )
            # # Discretization of the stress generated by cell center rotations.
            stress_rotation = -Rn_hat @ cell_to_face_average_complement
            # Diffusion operator on the rotations.
            rotation_diffusion = -sps.coo_matrix(
                (sd.face_areas[fi] * t_cosserat[fi] * sgn, (fi, ci)),
                shape=(nf, nc),
            ).tocsr()

            bound_rotation_diffusion = (
                -dir_filter
                @ sps.coo_matrix(
                    (sd.face_areas[fi] * t_cosserat[fi] * sgn, (fi, fi)), shape=(nf, nf)
                ).tocsr()
            )

        # The rotation generated by the cell center displacements is computed from the
        # average displacement over the faces, multiplied by Rn_bar. This construction
        # is common for both 2d and 3d.
        rotation_displacement = -Rn_bar @ cell_to_face_average_nd

        if nd == 2:
            bound_rotation_displacement = -dir_filter @ Rn_bar
        else:  # 3D
            bound_rotation_displacement = -dir_filter_nd @ Rn_bar

        ## Store the computed fields

        # Discretization matrices
        matrix_dictionary[self.stress_displacement_matrix_key] = stress
        matrix_dictionary[self.stress_rotation_matrix_key] = stress_rotation
        matrix_dictionary[self.stress_total_pressure_matrix_key] = stress_total_pressure
        matrix_dictionary[self.rotation_displacement_matrix_key] = rotation_displacement
        matrix_dictionary[self.rotation_diffusion_matrix_key] = rotation_diffusion
        matrix_dictionary[self.mass_total_pressure_matrix_key] = mass_total_pressure
        matrix_dictionary[self.mass_displacement_matrix_key] = mass_displacement

        # Boundary conditions (NB: Only Dirichlet implemented for now)
        matrix_dictionary[self.bound_stress_matrix_key] = bound_stress
        matrix_dictionary[self.bound_mass_displacement_matrix_key] = (
            bound_mass_displacement
        )
        matrix_dictionary[self.bound_rotation_diffusion_matrix_key] = (
            bound_rotation_diffusion
        )
        matrix_dictionary[self.bound_rotation_displacement_matrix_key] = (
            bound_rotation_displacement
        )
